// ignore_for_file: non_constant_identifier_names

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'package:orm/orm.dart' as _i1;

import 'prisma.dart' as _i2;

class NestedIntFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedIntFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<int, _i1.Reference<int>>? equals;

  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<int, _i2.NestedIntFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class IntFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<int, _i1.Reference<int>>? equals;

  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<int, _i2.NestedIntFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class NestedStringNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedStringNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  final _i1.PrismaUnion<String,
      _i1.PrismaUnion<_i1.Reference<String>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final _i1.PrismaUnion<String,
      _i1.PrismaUnion<_i2.NestedStringNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'not': not,
      };
}

class StringNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StringNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
  });

  final _i1.PrismaUnion<String,
      _i1.PrismaUnion<_i1.Reference<String>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final _i1.PrismaUnion<String,
      _i1.PrismaUnion<_i2.NestedStringNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'not': not,
      };
}

class NestedIntNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedIntNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1
      .PrismaUnion<int, _i1.PrismaUnion<_i1.Reference<int>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<int,
      _i1.PrismaUnion<_i2.NestedIntNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class IntNullableFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1
      .PrismaUnion<int, _i1.PrismaUnion<_i1.Reference<int>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<int,
      _i1.PrismaUnion<_i2.NestedIntNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class BannerWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<_i2.BannerWhereInput, Iterable<_i2.BannerWhereInput>>?
      AND;

  final Iterable<_i2.BannerWhereInput>? OR;

  final _i1.PrismaUnion<_i2.BannerWhereInput, Iterable<_i2.BannerWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? type;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? imagen;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? data;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      zoneId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class BannerWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.BannerWhereInput, Iterable<_i2.BannerWhereInput>>?
      AND;

  final Iterable<_i2.BannerWhereInput>? OR;

  final _i1.PrismaUnion<_i2.BannerWhereInput, Iterable<_i2.BannerWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? type;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? imagen;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? data;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      zoneId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class BannerSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerSelect({
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final bool? id;

  final bool? title;

  final bool? type;

  final bool? imagen;

  final bool? status;

  final bool? data;

  final bool? zoneId;

  final bool? createAt;

  final bool? updateAt;

  final bool? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

enum SortOrder implements _i1.PrismaEnum {
  asc._('asc'),
  desc._('desc');

  const SortOrder._(this.name);

  @override
  final String name;
}

enum NullsOrder implements _i1.PrismaEnum {
  first._('first'),
  last._('last');

  const NullsOrder._(this.name);

  @override
  final String name;
}

class SortOrderInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SortOrderInput({
    required this.sort,
    this.nulls,
  });

  final _i2.SortOrder sort;

  final _i2.NullsOrder? nulls;

  @override
  Map<String, dynamic> toJson() => {
        'sort': sort,
        'nulls': nulls,
      };
}

class BannerOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerOrderByWithRelationInput({
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? title;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? type;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? imagen;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? data;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? zoneId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updateAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

enum BannerScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Banner'),
  title<String>('title', 'Banner'),
  type<String>('type', 'Banner'),
  imagen<String>('imagen', 'Banner'),
  status<String>('status', 'Banner'),
  data<String>('data', 'Banner'),
  zoneId<int>('zone_id', 'Banner'),
  createAt<String>('create_at', 'Banner'),
  updateAt<String>('update_at', 'Banner'),
  deleteAt<String>('delete_at', 'Banner');

  const BannerScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class BannerCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerCreateInput({
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? type;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? imagen;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? data;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? zoneId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? createAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? updateAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class BannerUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerUncheckedCreateInput({
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? type;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? imagen;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? data;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? zoneId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? createAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? updateAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class AffectedRowsOutput {
  const AffectedRowsOutput({this.count});

  factory AffectedRowsOutput.fromJson(Map json) =>
      AffectedRowsOutput(count: json['count']);

  final int? count;

  Map<String, dynamic> toJson() => {'count': count};
}

class BannerCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerCreateManyInput({
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? type;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? imagen;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? data;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? zoneId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? createAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? updateAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class NullableStringFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableStringFieldUpdateOperationsInput({this.set});

  final _i1.PrismaUnion<String, _i1.PrismaNull>? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class NullableIntFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableIntFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  final _i1.PrismaUnion<int, _i1.PrismaNull>? set;

  final int? increment;

  final int? decrement;

  final int? multiply;

  final int? divide;

  @override
  Map<String, dynamic> toJson() => {
        'set': set,
        'increment': increment,
        'decrement': decrement,
        'multiply': multiply,
        'divide': divide,
      };
}

class BannerUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerUpdateInput({
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? type;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? imagen;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? data;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? zoneId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class IntFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  final int? set;

  final int? increment;

  final int? decrement;

  final int? multiply;

  final int? divide;

  @override
  Map<String, dynamic> toJson() => {
        'set': set,
        'increment': increment,
        'decrement': decrement,
        'multiply': multiply,
        'divide': divide,
      };
}

class BannerUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerUncheckedUpdateInput({
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? type;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? imagen;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? data;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? zoneId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class BannerUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerUpdateManyMutationInput({
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? type;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? imagen;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? data;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? zoneId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class BannerUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerUncheckedUpdateManyInput({
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? type;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? imagen;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? data;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? zoneId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class BannerCountAggregateOutputType {
  const BannerCountAggregateOutputType({
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
    this.$all,
  });

  factory BannerCountAggregateOutputType.fromJson(Map json) =>
      BannerCountAggregateOutputType(
        id: json['id'],
        title: json['title'],
        type: json['type'],
        imagen: json['imagen'],
        status: json['status'],
        data: json['data'],
        zoneId: json['zone_id'],
        createAt: json['create_at'],
        updateAt: json['update_at'],
        deleteAt: json['delete_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? title;

  final int? type;

  final int? imagen;

  final int? status;

  final int? data;

  final int? zoneId;

  final int? createAt;

  final int? updateAt;

  final int? deleteAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
        '_all': $all,
      };
}

class BannerAvgAggregateOutputType {
  const BannerAvgAggregateOutputType({
    this.id,
    this.zoneId,
  });

  factory BannerAvgAggregateOutputType.fromJson(Map json) =>
      BannerAvgAggregateOutputType(
        id: json['id'],
        zoneId: json['zone_id'],
      );

  final double? id;

  final double? zoneId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'zone_id': zoneId,
      };
}

class BannerSumAggregateOutputType {
  const BannerSumAggregateOutputType({
    this.id,
    this.zoneId,
  });

  factory BannerSumAggregateOutputType.fromJson(Map json) =>
      BannerSumAggregateOutputType(
        id: json['id'],
        zoneId: json['zone_id'],
      );

  final int? id;

  final int? zoneId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'zone_id': zoneId,
      };
}

class BannerMinAggregateOutputType {
  const BannerMinAggregateOutputType({
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  factory BannerMinAggregateOutputType.fromJson(Map json) =>
      BannerMinAggregateOutputType(
        id: json['id'],
        title: json['title'],
        type: json['type'],
        imagen: json['imagen'],
        status: json['status'],
        data: json['data'],
        zoneId: json['zone_id'],
        createAt: json['create_at'],
        updateAt: json['update_at'],
        deleteAt: json['delete_at'],
      );

  final int? id;

  final String? title;

  final String? type;

  final String? imagen;

  final String? status;

  final String? data;

  final int? zoneId;

  final String? createAt;

  final String? updateAt;

  final String? deleteAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class BannerMaxAggregateOutputType {
  const BannerMaxAggregateOutputType({
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  factory BannerMaxAggregateOutputType.fromJson(Map json) =>
      BannerMaxAggregateOutputType(
        id: json['id'],
        title: json['title'],
        type: json['type'],
        imagen: json['imagen'],
        status: json['status'],
        data: json['data'],
        zoneId: json['zone_id'],
        createAt: json['create_at'],
        updateAt: json['update_at'],
        deleteAt: json['delete_at'],
      );

  final int? id;

  final String? title;

  final String? type;

  final String? imagen;

  final String? status;

  final String? data;

  final int? zoneId;

  final String? createAt;

  final String? updateAt;

  final String? deleteAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class BannerGroupByOutputType {
  const BannerGroupByOutputType({
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory BannerGroupByOutputType.fromJson(Map json) => BannerGroupByOutputType(
        id: json['id'],
        title: json['title'],
        type: json['type'],
        imagen: json['imagen'],
        status: json['status'],
        data: json['data'],
        zoneId: json['zone_id'],
        createAt: json['create_at'],
        updateAt: json['update_at'],
        deleteAt: json['delete_at'],
        $count: json['_count'] is Map
            ? _i2.BannerCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.BannerAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.BannerSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.BannerMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.BannerMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? title;

  final String? type;

  final String? imagen;

  final String? status;

  final String? data;

  final int? zoneId;

  final String? createAt;

  final String? updateAt;

  final String? deleteAt;

  final _i2.BannerCountAggregateOutputType? $count;

  final _i2.BannerAvgAggregateOutputType? $avg;

  final _i2.BannerSumAggregateOutputType? $sum;

  final _i2.BannerMinAggregateOutputType? $min;

  final _i2.BannerMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class BannerCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerCountOrderByAggregateInput({
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? type;

  final _i2.SortOrder? imagen;

  final _i2.SortOrder? status;

  final _i2.SortOrder? data;

  final _i2.SortOrder? zoneId;

  final _i2.SortOrder? createAt;

  final _i2.SortOrder? updateAt;

  final _i2.SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class BannerAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerAvgOrderByAggregateInput({
    this.id,
    this.zoneId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? zoneId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'zone_id': zoneId,
      };
}

class BannerMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerMaxOrderByAggregateInput({
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? type;

  final _i2.SortOrder? imagen;

  final _i2.SortOrder? status;

  final _i2.SortOrder? data;

  final _i2.SortOrder? zoneId;

  final _i2.SortOrder? createAt;

  final _i2.SortOrder? updateAt;

  final _i2.SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class BannerMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerMinOrderByAggregateInput({
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? type;

  final _i2.SortOrder? imagen;

  final _i2.SortOrder? status;

  final _i2.SortOrder? data;

  final _i2.SortOrder? zoneId;

  final _i2.SortOrder? createAt;

  final _i2.SortOrder? updateAt;

  final _i2.SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class BannerSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerSumOrderByAggregateInput({
    this.id,
    this.zoneId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? zoneId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'zone_id': zoneId,
      };
}

class BannerOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerOrderByWithAggregationInput({
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? title;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? type;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? imagen;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? data;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? zoneId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updateAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? deleteAt;

  final _i2.BannerCountOrderByAggregateInput? $count;

  final _i2.BannerAvgOrderByAggregateInput? $avg;

  final _i2.BannerMaxOrderByAggregateInput? $max;

  final _i2.BannerMinOrderByAggregateInput? $min;

  final _i2.BannerSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class NestedFloatFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedFloatFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<double, _i1.Reference<double>>? equals;

  final Iterable<double>? $in;

  final Iterable<double>? notIn;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lte;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gte;

  final _i1.PrismaUnion<double, _i2.NestedFloatFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class NestedIntWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedIntWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<int, _i1.Reference<int>>? equals;

  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<int, _i2.NestedIntWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedFloatFilter? $avg;

  final _i2.NestedIntFilter? $sum;

  final _i2.NestedIntFilter? $min;

  final _i2.NestedIntFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class IntWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<int, _i1.Reference<int>>? equals;

  final Iterable<int>? $in;

  final Iterable<int>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<int, _i2.NestedIntWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedFloatFilter? $avg;

  final _i2.NestedIntFilter? $sum;

  final _i2.NestedIntFilter? $min;

  final _i2.NestedIntFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class NestedStringNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedStringNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<String,
      _i1.PrismaUnion<_i1.Reference<String>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NestedStringNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedStringNullableFilter? $min;

  final _i2.NestedStringNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class StringNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StringNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.contains,
    this.startsWith,
    this.endsWith,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<String,
      _i1.PrismaUnion<_i1.Reference<String>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<String>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? lte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gt;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? gte;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? contains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? startsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? endsWith;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NestedStringNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedStringNullableFilter? $min;

  final _i2.NestedStringNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'contains': contains,
        'startsWith': startsWith,
        'endsWith': endsWith,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class NestedFloatNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedFloatNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<double,
      _i1.PrismaUnion<_i1.Reference<double>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<double>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<double>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? lte;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gt;

  final _i1.PrismaUnion<double, _i1.Reference<double>>? gte;

  final _i1.PrismaUnion<double,
      _i1.PrismaUnion<_i2.NestedFloatNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class NestedIntNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedIntNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1
      .PrismaUnion<int, _i1.PrismaUnion<_i1.Reference<int>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NestedIntNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedFloatNullableFilter? $avg;

  final _i2.NestedIntNullableFilter? $sum;

  final _i2.NestedIntNullableFilter? $min;

  final _i2.NestedIntNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class IntNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const IntNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1
      .PrismaUnion<int, _i1.PrismaUnion<_i1.Reference<int>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<int>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? lte;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gt;

  final _i1.PrismaUnion<int, _i1.Reference<int>>? gte;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NestedIntNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedFloatNullableFilter? $avg;

  final _i2.NestedIntNullableFilter? $sum;

  final _i2.NestedIntNullableFilter? $min;

  final _i2.NestedIntNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class BannerScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<_i2.BannerScalarWhereWithAggregatesInput,
      Iterable<_i2.BannerScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.BannerScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.BannerScalarWhereWithAggregatesInput,
      Iterable<_i2.BannerScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? type;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? imagen;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? data;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? zoneId;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class BannerCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerCountAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
    this.$all,
  });

  final bool? id;

  final bool? title;

  final bool? type;

  final bool? imagen;

  final bool? status;

  final bool? data;

  final bool? zoneId;

  final bool? createAt;

  final bool? updateAt;

  final bool? deleteAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
        '_all': $all,
      };
}

class BannerGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerGroupByOutputTypeCountArgs({this.select});

  final _i2.BannerCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class BannerAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerAvgAggregateOutputTypeSelect({
    this.id,
    this.zoneId,
  });

  final bool? id;

  final bool? zoneId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'zone_id': zoneId,
      };
}

class BannerGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerGroupByOutputTypeAvgArgs({this.select});

  final _i2.BannerAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class BannerSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerSumAggregateOutputTypeSelect({
    this.id,
    this.zoneId,
  });

  final bool? id;

  final bool? zoneId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'zone_id': zoneId,
      };
}

class BannerGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerGroupByOutputTypeSumArgs({this.select});

  final _i2.BannerSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class BannerMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerMinAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final bool? id;

  final bool? title;

  final bool? type;

  final bool? imagen;

  final bool? status;

  final bool? data;

  final bool? zoneId;

  final bool? createAt;

  final bool? updateAt;

  final bool? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class BannerGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerGroupByOutputTypeMinArgs({this.select});

  final _i2.BannerMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class BannerMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerMaxAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final bool? id;

  final bool? title;

  final bool? type;

  final bool? imagen;

  final bool? status;

  final bool? data;

  final bool? zoneId;

  final bool? createAt;

  final bool? updateAt;

  final bool? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class BannerGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerGroupByOutputTypeMaxArgs({this.select});

  final _i2.BannerMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class BannerGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BannerGroupByOutputTypeSelect({
    this.id,
    this.title,
    this.type,
    this.imagen,
    this.status,
    this.data,
    this.zoneId,
    this.createAt,
    this.updateAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? title;

  final bool? type;

  final bool? imagen;

  final bool? status;

  final bool? data;

  final bool? zoneId;

  final bool? createAt;

  final bool? updateAt;

  final bool? deleteAt;

  final _i1.PrismaUnion<bool, _i2.BannerGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.BannerGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.BannerGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.BannerGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.BannerGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'type': type,
        'imagen': imagen,
        'status': status,
        'data': data,
        'zone_id': zoneId,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateBanner {
  const AggregateBanner({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateBanner.fromJson(Map json) => AggregateBanner(
        $count: json['_count'] is Map
            ? _i2.BannerCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.BannerAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.BannerSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.BannerMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.BannerMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.BannerCountAggregateOutputType? $count;

  final _i2.BannerAvgAggregateOutputType? $avg;

  final _i2.BannerSumAggregateOutputType? $sum;

  final _i2.BannerMinAggregateOutputType? $min;

  final _i2.BannerMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateBannerCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateBannerCountArgs({this.select});

  final _i2.BannerCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateBannerAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateBannerAvgArgs({this.select});

  final _i2.BannerAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateBannerSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateBannerSumArgs({this.select});

  final _i2.BannerSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateBannerMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateBannerMinArgs({this.select});

  final _i2.BannerMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateBannerMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateBannerMaxArgs({this.select});

  final _i2.BannerMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateBannerSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateBannerSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateBannerCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateBannerAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateBannerSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateBannerMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateBannerMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class NestedDecimalFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDecimalFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? equals;

  final Iterable<_i1.Decimal>? $in;

  final Iterable<_i1.Decimal>? notIn;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lte;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gte;

  final _i1.PrismaUnion<_i1.Decimal, _i2.NestedDecimalFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class DecimalFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DecimalFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? equals;

  final Iterable<_i1.Decimal>? $in;

  final Iterable<_i1.Decimal>? notIn;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lte;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gte;

  final _i1.PrismaUnion<_i1.Decimal, _i2.NestedDecimalFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class NestedDecimalNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDecimalNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<_i1.Decimal,
      _i1.PrismaUnion<_i1.Reference<_i1.Decimal>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<_i1.Decimal>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<_i1.Decimal>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lte;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gte;

  final _i1.PrismaUnion<_i1.Decimal,
      _i1.PrismaUnion<_i2.NestedDecimalNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class DecimalNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DecimalNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<_i1.Decimal,
      _i1.PrismaUnion<_i1.Reference<_i1.Decimal>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<_i1.Decimal>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<_i1.Decimal>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lte;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gte;

  final _i1.PrismaUnion<_i1.Decimal,
      _i1.PrismaUnion<_i2.NestedDecimalNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class NestedBoolNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedBoolNullableFilter({
    this.equals,
    this.not,
  });

  final _i1
      .PrismaUnion<bool, _i1.PrismaUnion<_i1.Reference<bool>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<bool,
      _i1.PrismaUnion<_i2.NestedBoolNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
      };
}

class BoolNullableFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BoolNullableFilter({
    this.equals,
    this.not,
  });

  final _i1
      .PrismaUnion<bool, _i1.PrismaUnion<_i1.Reference<bool>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<bool,
      _i1.PrismaUnion<_i2.NestedBoolNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
      };
}

class NestedBoolFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedBoolFilter({
    this.equals,
    this.not,
  });

  final _i1.PrismaUnion<bool, _i1.Reference<bool>>? equals;

  final _i1.PrismaUnion<bool, _i2.NestedBoolFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
      };
}

class BoolFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BoolFilter({
    this.equals,
    this.not,
  });

  final _i1.PrismaUnion<bool, _i1.Reference<bool>>? equals;

  final _i1.PrismaUnion<bool, _i2.NestedBoolFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
      };
}

class NestedDateTimeNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDateTimeNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<DateTime,
      _i1.PrismaUnion<_i1.Reference<DateTime>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<DateTime>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<DateTime>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<DateTime,
      _i1.PrismaUnion<_i2.NestedDateTimeNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class DateTimeNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DateTimeNullableFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<DateTime,
      _i1.PrismaUnion<_i1.Reference<DateTime>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<DateTime>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<DateTime>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<DateTime,
      _i1.PrismaUnion<_i2.NestedDateTimeNullableFilter, _i1.PrismaNull>>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class OrdersWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.OrdersWhereInput, Iterable<_i2.OrdersWhereInput>>?
      AND;

  final Iterable<_i2.OrdersWhereInput>? OR;

  final _i1.PrismaUnion<_i2.OrdersWhereInput, Iterable<_i2.OrdersWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntFilter, int>? userId;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? totalPrice;

  final _i1.PrismaUnion<_i2.IntFilter, int>? currencyId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? note;

  final _i1.PrismaUnion<_i2.IntFilter, int>? shopId;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? tax;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? commissionFee;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? username;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? totalDiscount;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? current;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? img;

  final _i1.PrismaUnion<_i2.IntFilter, int>? addressId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      waiterId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      tableId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      bookingId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      userBookingId;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? waiterFee;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? tips;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? serviceFee;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? address;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? imageAfterDelivered;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OrdersWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.OrdersWhereInput, Iterable<_i2.OrdersWhereInput>>?
      AND;

  final Iterable<_i2.OrdersWhereInput>? OR;

  final _i1.PrismaUnion<_i2.OrdersWhereInput, Iterable<_i2.OrdersWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? userId;

  final _i1.PrismaUnion<_i2.DecimalFilter, _i1.Decimal>? totalPrice;

  final _i1.PrismaUnion<_i2.IntFilter, int>? currencyId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? note;

  final _i1.PrismaUnion<_i2.IntFilter, int>? shopId;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? tax;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? commissionFee;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? username;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? totalDiscount;

  final _i1.PrismaUnion<_i2.BoolFilter, bool>? current;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? img;

  final _i1.PrismaUnion<_i2.IntFilter, int>? addressId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      waiterId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      tableId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      bookingId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      userBookingId;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? waiterFee;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? tips;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? serviceFee;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? address;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? imageAfterDelivered;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OrdersSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersSelect({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? userId;

  final bool? totalPrice;

  final bool? currencyId;

  final bool? note;

  final bool? shopId;

  final bool? tax;

  final bool? commissionFee;

  final bool? status;

  final bool? phone;

  final bool? username;

  final bool? totalDiscount;

  final bool? current;

  final bool? img;

  final bool? addressId;

  final bool? waiterId;

  final bool? tableId;

  final bool? bookingId;

  final bool? userBookingId;

  final bool? waiterFee;

  final bool? tips;

  final bool? serviceFee;

  final bool? address;

  final bool? location;

  final bool? email;

  final bool? imageAfterDelivered;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OrdersOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersOrderByWithRelationInput({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? totalPrice;

  final _i2.SortOrder? currencyId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? note;

  final _i2.SortOrder? shopId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? tax;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? commissionFee;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? phone;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? username;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? totalDiscount;

  final _i2.SortOrder? current;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? img;

  final _i2.SortOrder? addressId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? waiterId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? tableId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? bookingId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? userBookingId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? waiterFee;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? tips;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? serviceFee;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? address;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? location;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? email;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? imageAfterDelivered;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

enum OrdersScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Orders'),
  userId<int>('user_id', 'Orders'),
  totalPrice<_i1.Decimal>('total_price', 'Orders'),
  currencyId<int>('currency_id', 'Orders'),
  note<String>('note', 'Orders'),
  shopId<int>('shop_id', 'Orders'),
  tax<_i1.Decimal>('tax', 'Orders'),
  commissionFee<_i1.Decimal>('commission_fee', 'Orders'),
  status<bool>('status', 'Orders'),
  phone<String>('phone', 'Orders'),
  username<String>('username', 'Orders'),
  totalDiscount<_i1.Decimal>('total_discount', 'Orders'),
  current<bool>('current', 'Orders'),
  img<String>('img', 'Orders'),
  addressId<int>('address_id', 'Orders'),
  waiterId<int>('waiter_id', 'Orders'),
  tableId<int>('table_id', 'Orders'),
  bookingId<int>('booking_id', 'Orders'),
  userBookingId<int>('user_booking_id', 'Orders'),
  waiterFee<_i1.Decimal>('waiter_fee', 'Orders'),
  tips<_i1.Decimal>('tips', 'Orders'),
  serviceFee<_i1.Decimal>('service_fee', 'Orders'),
  address<String>('address', 'Orders'),
  location<String>('location', 'Orders'),
  email<String>('email', 'Orders'),
  imageAfterDelivered<String>('image_after_delivered', 'Orders'),
  createdAt<DateTime>('created_at', 'Orders'),
  updatedAt<DateTime>('updated_at', 'Orders');

  const OrdersScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class OrdersCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersCreateInput({
    required this.userId,
    required this.totalPrice,
    required this.currencyId,
    this.note,
    required this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    required this.current,
    this.img,
    required this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  final int userId;

  final _i1.Decimal totalPrice;

  final int currencyId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final int shopId;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? tax;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? commissionFee;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? username;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? totalDiscount;

  final bool current;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? img;

  final int addressId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? waiterId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? tableId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? bookingId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userBookingId;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? waiterFee;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? tips;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? serviceFee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? location;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? imageAfterDelivered;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OrdersUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersUncheckedCreateInput({
    this.id,
    required this.userId,
    required this.totalPrice,
    required this.currencyId,
    this.note,
    required this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    required this.current,
    this.img,
    required this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final int userId;

  final _i1.Decimal totalPrice;

  final int currencyId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final int shopId;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? tax;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? commissionFee;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? username;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? totalDiscount;

  final bool current;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? img;

  final int addressId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? waiterId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? tableId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? bookingId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userBookingId;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? waiterFee;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? tips;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? serviceFee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? location;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? imageAfterDelivered;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OrdersCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersCreateManyInput({
    this.id,
    required this.userId,
    required this.totalPrice,
    required this.currencyId,
    this.note,
    required this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    required this.current,
    this.img,
    required this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final int userId;

  final _i1.Decimal totalPrice;

  final int currencyId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final int shopId;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? tax;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? commissionFee;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? username;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? totalDiscount;

  final bool current;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? img;

  final int addressId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? waiterId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? tableId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? bookingId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userBookingId;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? waiterFee;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? tips;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? serviceFee;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? location;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? imageAfterDelivered;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class DecimalFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DecimalFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  final _i1.Decimal? set;

  final _i1.Decimal? increment;

  final _i1.Decimal? decrement;

  final _i1.Decimal? multiply;

  final _i1.Decimal? divide;

  @override
  Map<String, dynamic> toJson() => {
        'set': set,
        'increment': increment,
        'decrement': decrement,
        'multiply': multiply,
        'divide': divide,
      };
}

class NullableDecimalFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableDecimalFieldUpdateOperationsInput({
    this.set,
    this.increment,
    this.decrement,
    this.multiply,
    this.divide,
  });

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? set;

  final _i1.Decimal? increment;

  final _i1.Decimal? decrement;

  final _i1.Decimal? multiply;

  final _i1.Decimal? divide;

  @override
  Map<String, dynamic> toJson() => {
        'set': set,
        'increment': increment,
        'decrement': decrement,
        'multiply': multiply,
        'divide': divide,
      };
}

class NullableBoolFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableBoolFieldUpdateOperationsInput({this.set});

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class BoolFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BoolFieldUpdateOperationsInput({this.set});

  final bool? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class NullableDateTimeFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NullableDateTimeFieldUpdateOperationsInput({this.set});

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class OrdersUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersUpdateInput({
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalPrice;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? currencyId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? shopId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tax;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? commissionFee;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? username;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? totalDiscount;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? current;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? img;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? addressId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? waiterId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tableId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? bookingId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userBookingId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? waiterFee;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tips;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? serviceFee;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? address;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? imageAfterDelivered;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OrdersUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersUncheckedUpdateInput({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalPrice;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? currencyId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? shopId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tax;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? commissionFee;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? username;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? totalDiscount;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? current;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? img;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? addressId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? waiterId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tableId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? bookingId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userBookingId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? waiterFee;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tips;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? serviceFee;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? address;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? imageAfterDelivered;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OrdersUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersUpdateManyMutationInput({
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalPrice;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? currencyId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? shopId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tax;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? commissionFee;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? username;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? totalDiscount;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? current;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? img;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? addressId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? waiterId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tableId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? bookingId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userBookingId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? waiterFee;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tips;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? serviceFee;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? address;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? imageAfterDelivered;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OrdersUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersUncheckedUpdateManyInput({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? userId;

  final _i1.PrismaUnion<_i1.Decimal, _i2.DecimalFieldUpdateOperationsInput>?
      totalPrice;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? currencyId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? shopId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tax;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? commissionFee;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? username;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? totalDiscount;

  final _i1.PrismaUnion<bool, _i2.BoolFieldUpdateOperationsInput>? current;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? img;

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? addressId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? waiterId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tableId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? bookingId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userBookingId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? waiterFee;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? tips;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? serviceFee;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? address;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? imageAfterDelivered;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OrdersCountAggregateOutputType {
  const OrdersCountAggregateOutputType({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory OrdersCountAggregateOutputType.fromJson(Map json) =>
      OrdersCountAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        totalPrice: json['total_price'],
        currencyId: json['currency_id'],
        note: json['note'],
        shopId: json['shop_id'],
        tax: json['tax'],
        commissionFee: json['commission_fee'],
        status: json['status'],
        phone: json['phone'],
        username: json['username'],
        totalDiscount: json['total_discount'],
        current: json['current'],
        img: json['img'],
        addressId: json['address_id'],
        waiterId: json['waiter_id'],
        tableId: json['table_id'],
        bookingId: json['booking_id'],
        userBookingId: json['user_booking_id'],
        waiterFee: json['waiter_fee'],
        tips: json['tips'],
        serviceFee: json['service_fee'],
        address: json['address'],
        location: json['location'],
        email: json['email'],
        imageAfterDelivered: json['image_after_delivered'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? userId;

  final int? totalPrice;

  final int? currencyId;

  final int? note;

  final int? shopId;

  final int? tax;

  final int? commissionFee;

  final int? status;

  final int? phone;

  final int? username;

  final int? totalDiscount;

  final int? current;

  final int? img;

  final int? addressId;

  final int? waiterId;

  final int? tableId;

  final int? bookingId;

  final int? userBookingId;

  final int? waiterFee;

  final int? tips;

  final int? serviceFee;

  final int? address;

  final int? location;

  final int? email;

  final int? imageAfterDelivered;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class OrdersAvgAggregateOutputType {
  const OrdersAvgAggregateOutputType({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.totalDiscount,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
  });

  factory OrdersAvgAggregateOutputType.fromJson(Map json) =>
      OrdersAvgAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        totalPrice: json['total_price'],
        currencyId: json['currency_id'],
        shopId: json['shop_id'],
        tax: json['tax'],
        commissionFee: json['commission_fee'],
        totalDiscount: json['total_discount'],
        addressId: json['address_id'],
        waiterId: json['waiter_id'],
        tableId: json['table_id'],
        bookingId: json['booking_id'],
        userBookingId: json['user_booking_id'],
        waiterFee: json['waiter_fee'],
        tips: json['tips'],
        serviceFee: json['service_fee'],
      );

  final double? id;

  final double? userId;

  final _i1.Decimal? totalPrice;

  final double? currencyId;

  final double? shopId;

  final _i1.Decimal? tax;

  final _i1.Decimal? commissionFee;

  final _i1.Decimal? totalDiscount;

  final double? addressId;

  final double? waiterId;

  final double? tableId;

  final double? bookingId;

  final double? userBookingId;

  final _i1.Decimal? waiterFee;

  final _i1.Decimal? tips;

  final _i1.Decimal? serviceFee;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'total_discount': totalDiscount,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
      };
}

class OrdersSumAggregateOutputType {
  const OrdersSumAggregateOutputType({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.totalDiscount,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
  });

  factory OrdersSumAggregateOutputType.fromJson(Map json) =>
      OrdersSumAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        totalPrice: json['total_price'],
        currencyId: json['currency_id'],
        shopId: json['shop_id'],
        tax: json['tax'],
        commissionFee: json['commission_fee'],
        totalDiscount: json['total_discount'],
        addressId: json['address_id'],
        waiterId: json['waiter_id'],
        tableId: json['table_id'],
        bookingId: json['booking_id'],
        userBookingId: json['user_booking_id'],
        waiterFee: json['waiter_fee'],
        tips: json['tips'],
        serviceFee: json['service_fee'],
      );

  final int? id;

  final int? userId;

  final _i1.Decimal? totalPrice;

  final int? currencyId;

  final int? shopId;

  final _i1.Decimal? tax;

  final _i1.Decimal? commissionFee;

  final _i1.Decimal? totalDiscount;

  final int? addressId;

  final int? waiterId;

  final int? tableId;

  final int? bookingId;

  final int? userBookingId;

  final _i1.Decimal? waiterFee;

  final _i1.Decimal? tips;

  final _i1.Decimal? serviceFee;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'total_discount': totalDiscount,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
      };
}

class OrdersMinAggregateOutputType {
  const OrdersMinAggregateOutputType({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  factory OrdersMinAggregateOutputType.fromJson(Map json) =>
      OrdersMinAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        totalPrice: json['total_price'],
        currencyId: json['currency_id'],
        note: json['note'],
        shopId: json['shop_id'],
        tax: json['tax'],
        commissionFee: json['commission_fee'],
        status: json['status'],
        phone: json['phone'],
        username: json['username'],
        totalDiscount: json['total_discount'],
        current: json['current'],
        img: json['img'],
        addressId: json['address_id'],
        waiterId: json['waiter_id'],
        tableId: json['table_id'],
        bookingId: json['booking_id'],
        userBookingId: json['user_booking_id'],
        waiterFee: json['waiter_fee'],
        tips: json['tips'],
        serviceFee: json['service_fee'],
        address: json['address'],
        location: json['location'],
        email: json['email'],
        imageAfterDelivered: json['image_after_delivered'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final int? userId;

  final _i1.Decimal? totalPrice;

  final int? currencyId;

  final String? note;

  final int? shopId;

  final _i1.Decimal? tax;

  final _i1.Decimal? commissionFee;

  final bool? status;

  final String? phone;

  final String? username;

  final _i1.Decimal? totalDiscount;

  final bool? current;

  final String? img;

  final int? addressId;

  final int? waiterId;

  final int? tableId;

  final int? bookingId;

  final int? userBookingId;

  final _i1.Decimal? waiterFee;

  final _i1.Decimal? tips;

  final _i1.Decimal? serviceFee;

  final String? address;

  final String? location;

  final String? email;

  final String? imageAfterDelivered;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class OrdersMaxAggregateOutputType {
  const OrdersMaxAggregateOutputType({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  factory OrdersMaxAggregateOutputType.fromJson(Map json) =>
      OrdersMaxAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        totalPrice: json['total_price'],
        currencyId: json['currency_id'],
        note: json['note'],
        shopId: json['shop_id'],
        tax: json['tax'],
        commissionFee: json['commission_fee'],
        status: json['status'],
        phone: json['phone'],
        username: json['username'],
        totalDiscount: json['total_discount'],
        current: json['current'],
        img: json['img'],
        addressId: json['address_id'],
        waiterId: json['waiter_id'],
        tableId: json['table_id'],
        bookingId: json['booking_id'],
        userBookingId: json['user_booking_id'],
        waiterFee: json['waiter_fee'],
        tips: json['tips'],
        serviceFee: json['service_fee'],
        address: json['address'],
        location: json['location'],
        email: json['email'],
        imageAfterDelivered: json['image_after_delivered'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final int? userId;

  final _i1.Decimal? totalPrice;

  final int? currencyId;

  final String? note;

  final int? shopId;

  final _i1.Decimal? tax;

  final _i1.Decimal? commissionFee;

  final bool? status;

  final String? phone;

  final String? username;

  final _i1.Decimal? totalDiscount;

  final bool? current;

  final String? img;

  final int? addressId;

  final int? waiterId;

  final int? tableId;

  final int? bookingId;

  final int? userBookingId;

  final _i1.Decimal? waiterFee;

  final _i1.Decimal? tips;

  final _i1.Decimal? serviceFee;

  final String? address;

  final String? location;

  final String? email;

  final String? imageAfterDelivered;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class OrdersGroupByOutputType {
  const OrdersGroupByOutputType({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory OrdersGroupByOutputType.fromJson(Map json) => OrdersGroupByOutputType(
        id: json['id'],
        userId: json['user_id'],
        totalPrice: json['total_price'],
        currencyId: json['currency_id'],
        note: json['note'],
        shopId: json['shop_id'],
        tax: json['tax'],
        commissionFee: json['commission_fee'],
        status: json['status'],
        phone: json['phone'],
        username: json['username'],
        totalDiscount: json['total_discount'],
        current: json['current'],
        img: json['img'],
        addressId: json['address_id'],
        waiterId: json['waiter_id'],
        tableId: json['table_id'],
        bookingId: json['booking_id'],
        userBookingId: json['user_booking_id'],
        waiterFee: json['waiter_fee'],
        tips: json['tips'],
        serviceFee: json['service_fee'],
        address: json['address'],
        location: json['location'],
        email: json['email'],
        imageAfterDelivered: json['image_after_delivered'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        $count: json['_count'] is Map
            ? _i2.OrdersCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.OrdersAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.OrdersSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.OrdersMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.OrdersMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final int? userId;

  final _i1.Decimal? totalPrice;

  final int? currencyId;

  final String? note;

  final int? shopId;

  final _i1.Decimal? tax;

  final _i1.Decimal? commissionFee;

  final bool? status;

  final String? phone;

  final String? username;

  final _i1.Decimal? totalDiscount;

  final bool? current;

  final String? img;

  final int? addressId;

  final int? waiterId;

  final int? tableId;

  final int? bookingId;

  final int? userBookingId;

  final _i1.Decimal? waiterFee;

  final _i1.Decimal? tips;

  final _i1.Decimal? serviceFee;

  final String? address;

  final String? location;

  final String? email;

  final String? imageAfterDelivered;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.OrdersCountAggregateOutputType? $count;

  final _i2.OrdersAvgAggregateOutputType? $avg;

  final _i2.OrdersSumAggregateOutputType? $sum;

  final _i2.OrdersMinAggregateOutputType? $min;

  final _i2.OrdersMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class OrdersCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersCountOrderByAggregateInput({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? totalPrice;

  final _i2.SortOrder? currencyId;

  final _i2.SortOrder? note;

  final _i2.SortOrder? shopId;

  final _i2.SortOrder? tax;

  final _i2.SortOrder? commissionFee;

  final _i2.SortOrder? status;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? username;

  final _i2.SortOrder? totalDiscount;

  final _i2.SortOrder? current;

  final _i2.SortOrder? img;

  final _i2.SortOrder? addressId;

  final _i2.SortOrder? waiterId;

  final _i2.SortOrder? tableId;

  final _i2.SortOrder? bookingId;

  final _i2.SortOrder? userBookingId;

  final _i2.SortOrder? waiterFee;

  final _i2.SortOrder? tips;

  final _i2.SortOrder? serviceFee;

  final _i2.SortOrder? address;

  final _i2.SortOrder? location;

  final _i2.SortOrder? email;

  final _i2.SortOrder? imageAfterDelivered;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OrdersAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersAvgOrderByAggregateInput({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.totalDiscount,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? totalPrice;

  final _i2.SortOrder? currencyId;

  final _i2.SortOrder? shopId;

  final _i2.SortOrder? tax;

  final _i2.SortOrder? commissionFee;

  final _i2.SortOrder? totalDiscount;

  final _i2.SortOrder? addressId;

  final _i2.SortOrder? waiterId;

  final _i2.SortOrder? tableId;

  final _i2.SortOrder? bookingId;

  final _i2.SortOrder? userBookingId;

  final _i2.SortOrder? waiterFee;

  final _i2.SortOrder? tips;

  final _i2.SortOrder? serviceFee;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'total_discount': totalDiscount,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
      };
}

class OrdersMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersMaxOrderByAggregateInput({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? totalPrice;

  final _i2.SortOrder? currencyId;

  final _i2.SortOrder? note;

  final _i2.SortOrder? shopId;

  final _i2.SortOrder? tax;

  final _i2.SortOrder? commissionFee;

  final _i2.SortOrder? status;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? username;

  final _i2.SortOrder? totalDiscount;

  final _i2.SortOrder? current;

  final _i2.SortOrder? img;

  final _i2.SortOrder? addressId;

  final _i2.SortOrder? waiterId;

  final _i2.SortOrder? tableId;

  final _i2.SortOrder? bookingId;

  final _i2.SortOrder? userBookingId;

  final _i2.SortOrder? waiterFee;

  final _i2.SortOrder? tips;

  final _i2.SortOrder? serviceFee;

  final _i2.SortOrder? address;

  final _i2.SortOrder? location;

  final _i2.SortOrder? email;

  final _i2.SortOrder? imageAfterDelivered;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OrdersMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersMinOrderByAggregateInput({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? totalPrice;

  final _i2.SortOrder? currencyId;

  final _i2.SortOrder? note;

  final _i2.SortOrder? shopId;

  final _i2.SortOrder? tax;

  final _i2.SortOrder? commissionFee;

  final _i2.SortOrder? status;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? username;

  final _i2.SortOrder? totalDiscount;

  final _i2.SortOrder? current;

  final _i2.SortOrder? img;

  final _i2.SortOrder? addressId;

  final _i2.SortOrder? waiterId;

  final _i2.SortOrder? tableId;

  final _i2.SortOrder? bookingId;

  final _i2.SortOrder? userBookingId;

  final _i2.SortOrder? waiterFee;

  final _i2.SortOrder? tips;

  final _i2.SortOrder? serviceFee;

  final _i2.SortOrder? address;

  final _i2.SortOrder? location;

  final _i2.SortOrder? email;

  final _i2.SortOrder? imageAfterDelivered;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OrdersSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersSumOrderByAggregateInput({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.totalDiscount,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? totalPrice;

  final _i2.SortOrder? currencyId;

  final _i2.SortOrder? shopId;

  final _i2.SortOrder? tax;

  final _i2.SortOrder? commissionFee;

  final _i2.SortOrder? totalDiscount;

  final _i2.SortOrder? addressId;

  final _i2.SortOrder? waiterId;

  final _i2.SortOrder? tableId;

  final _i2.SortOrder? bookingId;

  final _i2.SortOrder? userBookingId;

  final _i2.SortOrder? waiterFee;

  final _i2.SortOrder? tips;

  final _i2.SortOrder? serviceFee;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'total_discount': totalDiscount,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
      };
}

class OrdersOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersOrderByWithAggregationInput({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? totalPrice;

  final _i2.SortOrder? currencyId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? note;

  final _i2.SortOrder? shopId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? tax;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? commissionFee;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? phone;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? username;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? totalDiscount;

  final _i2.SortOrder? current;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? img;

  final _i2.SortOrder? addressId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? waiterId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? tableId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? bookingId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? userBookingId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? waiterFee;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? tips;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? serviceFee;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? address;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? location;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? email;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? imageAfterDelivered;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i2.OrdersCountOrderByAggregateInput? $count;

  final _i2.OrdersAvgOrderByAggregateInput? $avg;

  final _i2.OrdersMaxOrderByAggregateInput? $max;

  final _i2.OrdersMinOrderByAggregateInput? $min;

  final _i2.OrdersSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class NestedDecimalWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDecimalWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? equals;

  final Iterable<_i1.Decimal>? $in;

  final Iterable<_i1.Decimal>? notIn;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lte;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gte;

  final _i1.PrismaUnion<_i1.Decimal, _i2.NestedDecimalWithAggregatesFilter>?
      not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedDecimalFilter? $avg;

  final _i2.NestedDecimalFilter? $sum;

  final _i2.NestedDecimalFilter? $min;

  final _i2.NestedDecimalFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class DecimalWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DecimalWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? equals;

  final Iterable<_i1.Decimal>? $in;

  final Iterable<_i1.Decimal>? notIn;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lte;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gte;

  final _i1.PrismaUnion<_i1.Decimal, _i2.NestedDecimalWithAggregatesFilter>?
      not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedDecimalFilter? $avg;

  final _i2.NestedDecimalFilter? $sum;

  final _i2.NestedDecimalFilter? $min;

  final _i2.NestedDecimalFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class NestedDecimalNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDecimalNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i1.Decimal,
      _i1.PrismaUnion<_i1.Reference<_i1.Decimal>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<_i1.Decimal>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<_i1.Decimal>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lte;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gte;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NestedDecimalNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedDecimalNullableFilter? $avg;

  final _i2.NestedDecimalNullableFilter? $sum;

  final _i2.NestedDecimalNullableFilter? $min;

  final _i2.NestedDecimalNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class DecimalNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DecimalNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<_i1.Decimal,
      _i1.PrismaUnion<_i1.Reference<_i1.Decimal>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<_i1.Decimal>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<_i1.Decimal>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? lte;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gt;

  final _i1.PrismaUnion<_i1.Decimal, _i1.Reference<_i1.Decimal>>? gte;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NestedDecimalNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedDecimalNullableFilter? $avg;

  final _i2.NestedDecimalNullableFilter? $sum;

  final _i2.NestedDecimalNullableFilter? $min;

  final _i2.NestedDecimalNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class NestedBoolNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedBoolNullableWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1
      .PrismaUnion<bool, _i1.PrismaUnion<_i1.Reference<bool>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NestedBoolNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedBoolNullableFilter? $min;

  final _i2.NestedBoolNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class BoolNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BoolNullableWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1
      .PrismaUnion<bool, _i1.PrismaUnion<_i1.Reference<bool>, _i1.PrismaNull>>?
      equals;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NestedBoolNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedBoolNullableFilter? $min;

  final _i2.NestedBoolNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class NestedBoolWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedBoolWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i1.Reference<bool>>? equals;

  final _i1.PrismaUnion<bool, _i2.NestedBoolWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedBoolFilter? $min;

  final _i2.NestedBoolFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class BoolWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BoolWithAggregatesFilter({
    this.equals,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i1.Reference<bool>>? equals;

  final _i1.PrismaUnion<bool, _i2.NestedBoolWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedBoolFilter? $min;

  final _i2.NestedBoolFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class NestedDateTimeNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDateTimeNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<DateTime,
      _i1.PrismaUnion<_i1.Reference<DateTime>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<DateTime>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<DateTime>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NestedDateTimeNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedDateTimeNullableFilter? $min;

  final _i2.NestedDateTimeNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class DateTimeNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DateTimeNullableWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<DateTime,
      _i1.PrismaUnion<_i1.Reference<DateTime>, _i1.PrismaNull>>? equals;

  final _i1.PrismaUnion<Iterable<DateTime>, _i1.PrismaNull>? $in;

  final _i1.PrismaUnion<Iterable<DateTime>, _i1.PrismaNull>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NestedDateTimeNullableWithAggregatesFilter,
          _i1.PrismaNull>>? not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedDateTimeNullableFilter? $min;

  final _i2.NestedDateTimeNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class OrdersScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.OrdersScalarWhereWithAggregatesInput,
      Iterable<_i2.OrdersScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.OrdersScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.OrdersScalarWhereWithAggregatesInput,
      Iterable<_i2.OrdersScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? userId;

  final _i1.PrismaUnion<_i2.DecimalWithAggregatesFilter, _i1.Decimal>?
      totalPrice;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? currencyId;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? note;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? shopId;

  final _i1.PrismaUnion<_i2.DecimalNullableWithAggregatesFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? tax;

  final _i1.PrismaUnion<_i2.DecimalNullableWithAggregatesFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? commissionFee;

  final _i1.PrismaUnion<_i2.BoolNullableWithAggregatesFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? username;

  final _i1.PrismaUnion<_i2.DecimalNullableWithAggregatesFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? totalDiscount;

  final _i1.PrismaUnion<_i2.BoolWithAggregatesFilter, bool>? current;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? img;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? addressId;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? waiterId;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? tableId;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? bookingId;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? userBookingId;

  final _i1.PrismaUnion<_i2.DecimalNullableWithAggregatesFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? waiterFee;

  final _i1.PrismaUnion<_i2.DecimalNullableWithAggregatesFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? tips;

  final _i1.PrismaUnion<_i2.DecimalNullableWithAggregatesFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? serviceFee;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? address;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? imageAfterDelivered;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OrdersCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersCountAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? userId;

  final bool? totalPrice;

  final bool? currencyId;

  final bool? note;

  final bool? shopId;

  final bool? tax;

  final bool? commissionFee;

  final bool? status;

  final bool? phone;

  final bool? username;

  final bool? totalDiscount;

  final bool? current;

  final bool? img;

  final bool? addressId;

  final bool? waiterId;

  final bool? tableId;

  final bool? bookingId;

  final bool? userBookingId;

  final bool? waiterFee;

  final bool? tips;

  final bool? serviceFee;

  final bool? address;

  final bool? location;

  final bool? email;

  final bool? imageAfterDelivered;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class OrdersGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersGroupByOutputTypeCountArgs({this.select});

  final _i2.OrdersCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrdersAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersAvgAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.totalDiscount,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
  });

  final bool? id;

  final bool? userId;

  final bool? totalPrice;

  final bool? currencyId;

  final bool? shopId;

  final bool? tax;

  final bool? commissionFee;

  final bool? totalDiscount;

  final bool? addressId;

  final bool? waiterId;

  final bool? tableId;

  final bool? bookingId;

  final bool? userBookingId;

  final bool? waiterFee;

  final bool? tips;

  final bool? serviceFee;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'total_discount': totalDiscount,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
      };
}

class OrdersGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersGroupByOutputTypeAvgArgs({this.select});

  final _i2.OrdersAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrdersSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersSumAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.totalDiscount,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
  });

  final bool? id;

  final bool? userId;

  final bool? totalPrice;

  final bool? currencyId;

  final bool? shopId;

  final bool? tax;

  final bool? commissionFee;

  final bool? totalDiscount;

  final bool? addressId;

  final bool? waiterId;

  final bool? tableId;

  final bool? bookingId;

  final bool? userBookingId;

  final bool? waiterFee;

  final bool? tips;

  final bool? serviceFee;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'total_discount': totalDiscount,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
      };
}

class OrdersGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersGroupByOutputTypeSumArgs({this.select});

  final _i2.OrdersSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrdersMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersMinAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? userId;

  final bool? totalPrice;

  final bool? currencyId;

  final bool? note;

  final bool? shopId;

  final bool? tax;

  final bool? commissionFee;

  final bool? status;

  final bool? phone;

  final bool? username;

  final bool? totalDiscount;

  final bool? current;

  final bool? img;

  final bool? addressId;

  final bool? waiterId;

  final bool? tableId;

  final bool? bookingId;

  final bool? userBookingId;

  final bool? waiterFee;

  final bool? tips;

  final bool? serviceFee;

  final bool? address;

  final bool? location;

  final bool? email;

  final bool? imageAfterDelivered;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OrdersGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersGroupByOutputTypeMinArgs({this.select});

  final _i2.OrdersMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrdersMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersMaxAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? userId;

  final bool? totalPrice;

  final bool? currencyId;

  final bool? note;

  final bool? shopId;

  final bool? tax;

  final bool? commissionFee;

  final bool? status;

  final bool? phone;

  final bool? username;

  final bool? totalDiscount;

  final bool? current;

  final bool? img;

  final bool? addressId;

  final bool? waiterId;

  final bool? tableId;

  final bool? bookingId;

  final bool? userBookingId;

  final bool? waiterFee;

  final bool? tips;

  final bool? serviceFee;

  final bool? address;

  final bool? location;

  final bool? email;

  final bool? imageAfterDelivered;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OrdersGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersGroupByOutputTypeMaxArgs({this.select});

  final _i2.OrdersMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OrdersGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OrdersGroupByOutputTypeSelect({
    this.id,
    this.userId,
    this.totalPrice,
    this.currencyId,
    this.note,
    this.shopId,
    this.tax,
    this.commissionFee,
    this.status,
    this.phone,
    this.username,
    this.totalDiscount,
    this.current,
    this.img,
    this.addressId,
    this.waiterId,
    this.tableId,
    this.bookingId,
    this.userBookingId,
    this.waiterFee,
    this.tips,
    this.serviceFee,
    this.address,
    this.location,
    this.email,
    this.imageAfterDelivered,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? userId;

  final bool? totalPrice;

  final bool? currencyId;

  final bool? note;

  final bool? shopId;

  final bool? tax;

  final bool? commissionFee;

  final bool? status;

  final bool? phone;

  final bool? username;

  final bool? totalDiscount;

  final bool? current;

  final bool? img;

  final bool? addressId;

  final bool? waiterId;

  final bool? tableId;

  final bool? bookingId;

  final bool? userBookingId;

  final bool? waiterFee;

  final bool? tips;

  final bool? serviceFee;

  final bool? address;

  final bool? location;

  final bool? email;

  final bool? imageAfterDelivered;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.OrdersGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.OrdersGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.OrdersGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.OrdersGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.OrdersGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'total_price': totalPrice,
        'currency_id': currencyId,
        'note': note,
        'shop_id': shopId,
        'tax': tax,
        'commission_fee': commissionFee,
        'status': status,
        'phone': phone,
        'username': username,
        'total_discount': totalDiscount,
        'current': current,
        'img': img,
        'address_id': addressId,
        'waiter_id': waiterId,
        'table_id': tableId,
        'booking_id': bookingId,
        'user_booking_id': userBookingId,
        'waiter_fee': waiterFee,
        'tips': tips,
        'service_fee': serviceFee,
        'address': address,
        'location': location,
        'email': email,
        'image_after_delivered': imageAfterDelivered,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateOrders {
  const AggregateOrders({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateOrders.fromJson(Map json) => AggregateOrders(
        $count: json['_count'] is Map
            ? _i2.OrdersCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.OrdersAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.OrdersSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.OrdersMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.OrdersMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.OrdersCountAggregateOutputType? $count;

  final _i2.OrdersAvgAggregateOutputType? $avg;

  final _i2.OrdersSumAggregateOutputType? $sum;

  final _i2.OrdersMinAggregateOutputType? $min;

  final _i2.OrdersMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateOrdersCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrdersCountArgs({this.select});

  final _i2.OrdersCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrdersAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrdersAvgArgs({this.select});

  final _i2.OrdersAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrdersSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrdersSumArgs({this.select});

  final _i2.OrdersSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrdersMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrdersMinArgs({this.select});

  final _i2.OrdersMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrdersMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrdersMaxArgs({this.select});

  final _i2.OrdersMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOrdersSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOrdersSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateOrdersCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateOrdersAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateOrdersSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateOrdersMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateOrdersMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class ProductsWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i1
      .PrismaUnion<_i2.ProductsWhereInput, Iterable<_i2.ProductsWhereInput>>?
      AND;

  final Iterable<_i2.ProductsWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.ProductsWhereInput, Iterable<_i2.ProductsWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? shopId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? categoryId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? brandId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? unitId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? keywords;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? img;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? qrCode;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? active;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class ProductsWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final int? id;

  final _i1
      .PrismaUnion<_i2.ProductsWhereInput, Iterable<_i2.ProductsWhereInput>>?
      AND;

  final Iterable<_i2.ProductsWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.ProductsWhereInput, Iterable<_i2.ProductsWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? shopId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? categoryId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? brandId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? unitId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? keywords;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? img;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? qrCode;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? active;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class ProductsSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsSelect({
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final bool? id;

  final bool? uuid;

  final bool? shopId;

  final bool? categoryId;

  final bool? brandId;

  final bool? unitId;

  final bool? keywords;

  final bool? img;

  final bool? qrCode;

  final bool? active;

  final bool? status;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class ProductsOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsOrderByWithRelationInput({
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? shopId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? categoryId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? brandId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? unitId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? keywords;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? img;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? qrCode;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? active;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

enum ProductsScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Products'),
  uuid<String>('uuid', 'Products'),
  shopId<String>('shop_id', 'Products'),
  categoryId<String>('category_id', 'Products'),
  brandId<String>('brand_id', 'Products'),
  unitId<String>('unit_id', 'Products'),
  keywords<String>('keywords', 'Products'),
  img<String>('img', 'Products'),
  qrCode<String>('qr_code', 'Products'),
  active<bool>('active', 'Products'),
  status<String>('status', 'Products'),
  createdAt<String>('created_at', 'Products'),
  updatedAt<String>('updated_at', 'Products'),
  deletedAt<String>('deleted_at', 'Products');

  const ProductsScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ProductsCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsCreateInput({
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? shopId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? categoryId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? brandId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? unitId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? keywords;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? img;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qrCode;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? active;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? updatedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class ProductsUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsUncheckedCreateInput({
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? shopId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? categoryId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? brandId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? unitId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? keywords;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? img;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qrCode;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? active;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? updatedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class ProductsCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsCreateManyInput({
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? shopId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? categoryId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? brandId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? unitId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? keywords;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? img;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? qrCode;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? active;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? updatedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class ProductsUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsUpdateInput({
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? shopId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? categoryId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? brandId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? unitId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? keywords;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? img;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? qrCode;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? active;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class ProductsUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsUncheckedUpdateInput({
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? shopId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? categoryId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? brandId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? unitId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? keywords;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? img;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? qrCode;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? active;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class ProductsUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsUpdateManyMutationInput({
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? shopId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? categoryId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? brandId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? unitId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? keywords;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? img;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? qrCode;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? active;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class ProductsUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsUncheckedUpdateManyInput({
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? shopId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? categoryId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? brandId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? unitId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? keywords;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? img;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? qrCode;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? active;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class ProductsCountAggregateOutputType {
  const ProductsCountAggregateOutputType({
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.$all,
  });

  factory ProductsCountAggregateOutputType.fromJson(Map json) =>
      ProductsCountAggregateOutputType(
        id: json['id'],
        uuid: json['uuid'],
        shopId: json['shop_id'],
        categoryId: json['category_id'],
        brandId: json['brand_id'],
        unitId: json['unit_id'],
        keywords: json['keywords'],
        img: json['img'],
        qrCode: json['qr_code'],
        active: json['active'],
        status: json['status'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        deletedAt: json['deleted_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? uuid;

  final int? shopId;

  final int? categoryId;

  final int? brandId;

  final int? unitId;

  final int? keywords;

  final int? img;

  final int? qrCode;

  final int? active;

  final int? status;

  final int? createdAt;

  final int? updatedAt;

  final int? deletedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        '_all': $all,
      };
}

class ProductsAvgAggregateOutputType {
  const ProductsAvgAggregateOutputType({this.id});

  factory ProductsAvgAggregateOutputType.fromJson(Map json) =>
      ProductsAvgAggregateOutputType(id: json['id']);

  final double? id;

  Map<String, dynamic> toJson() => {'id': id};
}

class ProductsSumAggregateOutputType {
  const ProductsSumAggregateOutputType({this.id});

  factory ProductsSumAggregateOutputType.fromJson(Map json) =>
      ProductsSumAggregateOutputType(id: json['id']);

  final int? id;

  Map<String, dynamic> toJson() => {'id': id};
}

class ProductsMinAggregateOutputType {
  const ProductsMinAggregateOutputType({
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  factory ProductsMinAggregateOutputType.fromJson(Map json) =>
      ProductsMinAggregateOutputType(
        id: json['id'],
        uuid: json['uuid'],
        shopId: json['shop_id'],
        categoryId: json['category_id'],
        brandId: json['brand_id'],
        unitId: json['unit_id'],
        keywords: json['keywords'],
        img: json['img'],
        qrCode: json['qr_code'],
        active: json['active'],
        status: json['status'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        deletedAt: json['deleted_at'],
      );

  final int? id;

  final String? uuid;

  final String? shopId;

  final String? categoryId;

  final String? brandId;

  final String? unitId;

  final String? keywords;

  final String? img;

  final String? qrCode;

  final bool? active;

  final String? status;

  final String? createdAt;

  final String? updatedAt;

  final String? deletedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class ProductsMaxAggregateOutputType {
  const ProductsMaxAggregateOutputType({
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  factory ProductsMaxAggregateOutputType.fromJson(Map json) =>
      ProductsMaxAggregateOutputType(
        id: json['id'],
        uuid: json['uuid'],
        shopId: json['shop_id'],
        categoryId: json['category_id'],
        brandId: json['brand_id'],
        unitId: json['unit_id'],
        keywords: json['keywords'],
        img: json['img'],
        qrCode: json['qr_code'],
        active: json['active'],
        status: json['status'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        deletedAt: json['deleted_at'],
      );

  final int? id;

  final String? uuid;

  final String? shopId;

  final String? categoryId;

  final String? brandId;

  final String? unitId;

  final String? keywords;

  final String? img;

  final String? qrCode;

  final bool? active;

  final String? status;

  final String? createdAt;

  final String? updatedAt;

  final String? deletedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class ProductsGroupByOutputType {
  const ProductsGroupByOutputType({
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ProductsGroupByOutputType.fromJson(Map json) =>
      ProductsGroupByOutputType(
        id: json['id'],
        uuid: json['uuid'],
        shopId: json['shop_id'],
        categoryId: json['category_id'],
        brandId: json['brand_id'],
        unitId: json['unit_id'],
        keywords: json['keywords'],
        img: json['img'],
        qrCode: json['qr_code'],
        active: json['active'],
        status: json['status'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        deletedAt: json['deleted_at'],
        $count: json['_count'] is Map
            ? _i2.ProductsCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ProductsAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ProductsSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ProductsMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ProductsMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? uuid;

  final String? shopId;

  final String? categoryId;

  final String? brandId;

  final String? unitId;

  final String? keywords;

  final String? img;

  final String? qrCode;

  final bool? active;

  final String? status;

  final String? createdAt;

  final String? updatedAt;

  final String? deletedAt;

  final _i2.ProductsCountAggregateOutputType? $count;

  final _i2.ProductsAvgAggregateOutputType? $avg;

  final _i2.ProductsSumAggregateOutputType? $sum;

  final _i2.ProductsMinAggregateOutputType? $min;

  final _i2.ProductsMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class ProductsCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsCountOrderByAggregateInput({
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? shopId;

  final _i2.SortOrder? categoryId;

  final _i2.SortOrder? brandId;

  final _i2.SortOrder? unitId;

  final _i2.SortOrder? keywords;

  final _i2.SortOrder? img;

  final _i2.SortOrder? qrCode;

  final _i2.SortOrder? active;

  final _i2.SortOrder? status;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SortOrder? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class ProductsAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsAvgOrderByAggregateInput({this.id});

  final _i2.SortOrder? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class ProductsMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsMaxOrderByAggregateInput({
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? shopId;

  final _i2.SortOrder? categoryId;

  final _i2.SortOrder? brandId;

  final _i2.SortOrder? unitId;

  final _i2.SortOrder? keywords;

  final _i2.SortOrder? img;

  final _i2.SortOrder? qrCode;

  final _i2.SortOrder? active;

  final _i2.SortOrder? status;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SortOrder? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class ProductsMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsMinOrderByAggregateInput({
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? shopId;

  final _i2.SortOrder? categoryId;

  final _i2.SortOrder? brandId;

  final _i2.SortOrder? unitId;

  final _i2.SortOrder? keywords;

  final _i2.SortOrder? img;

  final _i2.SortOrder? qrCode;

  final _i2.SortOrder? active;

  final _i2.SortOrder? status;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SortOrder? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class ProductsSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsSumOrderByAggregateInput({this.id});

  final _i2.SortOrder? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class ProductsOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsOrderByWithAggregationInput({
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? shopId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? categoryId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? brandId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? unitId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? keywords;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? img;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? qrCode;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? active;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? deletedAt;

  final _i2.ProductsCountOrderByAggregateInput? $count;

  final _i2.ProductsAvgOrderByAggregateInput? $avg;

  final _i2.ProductsMaxOrderByAggregateInput? $max;

  final _i2.ProductsMinOrderByAggregateInput? $min;

  final _i2.ProductsSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class ProductsScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i1.PrismaUnion<_i2.ProductsScalarWhereWithAggregatesInput,
      Iterable<_i2.ProductsScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ProductsScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ProductsScalarWhereWithAggregatesInput,
      Iterable<_i2.ProductsScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? shopId;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? categoryId;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? brandId;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? unitId;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? keywords;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? img;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? qrCode;

  final _i1.PrismaUnion<_i2.BoolNullableWithAggregatesFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? active;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class ProductsCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsCountAggregateOutputTypeSelect({
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.$all,
  });

  final bool? id;

  final bool? uuid;

  final bool? shopId;

  final bool? categoryId;

  final bool? brandId;

  final bool? unitId;

  final bool? keywords;

  final bool? img;

  final bool? qrCode;

  final bool? active;

  final bool? status;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? deletedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        '_all': $all,
      };
}

class ProductsGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsGroupByOutputTypeCountArgs({this.select});

  final _i2.ProductsCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductsAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsAvgAggregateOutputTypeSelect({this.id});

  final bool? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class ProductsGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsGroupByOutputTypeAvgArgs({this.select});

  final _i2.ProductsAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductsSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsSumAggregateOutputTypeSelect({this.id});

  final bool? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class ProductsGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsGroupByOutputTypeSumArgs({this.select});

  final _i2.ProductsSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductsMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsMinAggregateOutputTypeSelect({
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final bool? id;

  final bool? uuid;

  final bool? shopId;

  final bool? categoryId;

  final bool? brandId;

  final bool? unitId;

  final bool? keywords;

  final bool? img;

  final bool? qrCode;

  final bool? active;

  final bool? status;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class ProductsGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsGroupByOutputTypeMinArgs({this.select});

  final _i2.ProductsMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductsMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsMaxAggregateOutputTypeSelect({
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final bool? id;

  final bool? uuid;

  final bool? shopId;

  final bool? categoryId;

  final bool? brandId;

  final bool? unitId;

  final bool? keywords;

  final bool? img;

  final bool? qrCode;

  final bool? active;

  final bool? status;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class ProductsGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsGroupByOutputTypeMaxArgs({this.select});

  final _i2.ProductsMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProductsGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProductsGroupByOutputTypeSelect({
    this.id,
    this.uuid,
    this.shopId,
    this.categoryId,
    this.brandId,
    this.unitId,
    this.keywords,
    this.img,
    this.qrCode,
    this.active,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? uuid;

  final bool? shopId;

  final bool? categoryId;

  final bool? brandId;

  final bool? unitId;

  final bool? keywords;

  final bool? img;

  final bool? qrCode;

  final bool? active;

  final bool? status;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? deletedAt;

  final _i1.PrismaUnion<bool, _i2.ProductsGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.ProductsGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.ProductsGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.ProductsGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.ProductsGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'shop_id': shopId,
        'category_id': categoryId,
        'brand_id': brandId,
        'unit_id': unitId,
        'keywords': keywords,
        'img': img,
        'qr_code': qrCode,
        'active': active,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateProducts {
  const AggregateProducts({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateProducts.fromJson(Map json) => AggregateProducts(
        $count: json['_count'] is Map
            ? _i2.ProductsCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ProductsAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ProductsSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ProductsMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ProductsMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ProductsCountAggregateOutputType? $count;

  final _i2.ProductsAvgAggregateOutputType? $avg;

  final _i2.ProductsSumAggregateOutputType? $sum;

  final _i2.ProductsMinAggregateOutputType? $min;

  final _i2.ProductsMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateProductsCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductsCountArgs({this.select});

  final _i2.ProductsCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductsAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductsAvgArgs({this.select});

  final _i2.ProductsAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductsSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductsSumArgs({this.select});

  final _i2.ProductsSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductsMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductsMinArgs({this.select});

  final _i2.ProductsMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductsMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductsMaxArgs({this.select});

  final _i2.ProductsMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProductsSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProductsSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateProductsCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateProductsAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateProductsSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateProductsMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateProductsMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class StoreWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  final _i1.PrismaUnion<_i2.StoreWhereInput, Iterable<_i2.StoreWhereInput>>?
      AND;

  final Iterable<_i2.StoreWhereInput>? OR;

  final _i1.PrismaUnion<_i2.StoreWhereInput, Iterable<_i2.StoreWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? slug;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? uuid;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      vendorId;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? percentage;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? showType;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? open;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? visibility;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? backgroundImg;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? logoImg;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? statusNote;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      price;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? deletedAt;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? verify;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? orderPayment;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      moduleId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.StoreWhereInput, Iterable<_i2.StoreWhereInput>>?
      AND;

  final Iterable<_i2.StoreWhereInput>? OR;

  final _i1.PrismaUnion<_i2.StoreWhereInput, Iterable<_i2.StoreWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? slug;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? uuid;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      vendorId;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? percentage;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? showType;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? open;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? visibility;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? backgroundImg;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? logoImg;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? statusNote;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      price;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? deletedAt;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? verify;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? orderPayment;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      moduleId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreSelect({
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  final bool? id;

  final bool? slug;

  final bool? uuid;

  final bool? vendorId;

  final bool? percentage;

  final bool? location;

  final bool? phone;

  final bool? showType;

  final bool? open;

  final bool? visibility;

  final bool? backgroundImg;

  final bool? logoImg;

  final bool? status;

  final bool? statusNote;

  final bool? price;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? deletedAt;

  final bool? verify;

  final bool? orderPayment;

  final bool? moduleId;

  final bool? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreOrderByWithRelationInput({
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? slug;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? vendorId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? percentage;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? location;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? phone;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? showType;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? open;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? visibility;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? backgroundImg;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? logoImg;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? statusNote;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? price;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? deletedAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? verify;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? orderPayment;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? moduleId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

enum StoreScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Store'),
  slug<String>('slug', 'Store'),
  uuid<String>('uuid', 'Store'),
  vendorId<int>('vendor_id', 'Store'),
  percentage<_i1.Decimal>('percentage', 'Store'),
  location<String>('location', 'Store'),
  phone<String>('phone', 'Store'),
  showType<String>('show_type', 'Store'),
  open<bool>('open', 'Store'),
  visibility<bool>('visibility', 'Store'),
  backgroundImg<String>('background_img', 'Store'),
  logoImg<String>('logo_img', 'Store'),
  status<String>('status', 'Store'),
  statusNote<String>('status_note', 'Store'),
  price<int>('price', 'Store'),
  createdAt<DateTime>('created_at', 'Store'),
  updatedAt<DateTime>('updated_at', 'Store'),
  deletedAt<DateTime>('deleted_at', 'Store'),
  verify<bool>('verify', 'Store'),
  orderPayment<String>('order_payment', 'Store'),
  moduleId<int>('module_id', 'Store'),
  subcriptionId<int>('subcription_id', 'Store');

  const StoreScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class StoreCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreCreateInput({
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? slug;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? uuid;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? vendorId;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? percentage;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? location;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? showType;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? open;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? visibility;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? backgroundImg;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? logoImg;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statusNote;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? price;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? deletedAt;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? verify;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? orderPayment;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? moduleId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreUncheckedCreateInput({
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? slug;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? uuid;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? vendorId;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? percentage;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? location;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? showType;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? open;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? visibility;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? backgroundImg;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? logoImg;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statusNote;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? price;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? deletedAt;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? verify;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? orderPayment;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? moduleId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreCreateManyInput({
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? slug;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? uuid;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? vendorId;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? percentage;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? location;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? showType;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? open;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? visibility;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? backgroundImg;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? logoImg;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? statusNote;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? price;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? deletedAt;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? verify;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? orderPayment;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? moduleId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreUpdateInput({
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? slug;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? percentage;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? showType;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? open;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? visibility;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? backgroundImg;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? logoImg;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statusNote;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deletedAt;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? verify;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? orderPayment;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduleId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreUncheckedUpdateInput({
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? slug;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? percentage;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? showType;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? open;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? visibility;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? backgroundImg;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? logoImg;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statusNote;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deletedAt;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? verify;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? orderPayment;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduleId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreUpdateManyMutationInput({
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? slug;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? percentage;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? showType;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? open;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? visibility;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? backgroundImg;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? logoImg;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statusNote;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deletedAt;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? verify;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? orderPayment;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduleId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreUncheckedUpdateManyInput({
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? slug;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? percentage;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? showType;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? open;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? visibility;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? backgroundImg;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? logoImg;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? statusNote;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deletedAt;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? verify;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? orderPayment;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduleId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreCountAggregateOutputType {
  const StoreCountAggregateOutputType({
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
    this.$all,
  });

  factory StoreCountAggregateOutputType.fromJson(Map json) =>
      StoreCountAggregateOutputType(
        id: json['id'],
        slug: json['slug'],
        uuid: json['uuid'],
        vendorId: json['vendor_id'],
        percentage: json['percentage'],
        location: json['location'],
        phone: json['phone'],
        showType: json['show_type'],
        open: json['open'],
        visibility: json['visibility'],
        backgroundImg: json['background_img'],
        logoImg: json['logo_img'],
        status: json['status'],
        statusNote: json['status_note'],
        price: json['price'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        deletedAt: json['deleted_at'],
        verify: json['verify'],
        orderPayment: json['order_payment'],
        moduleId: json['module_id'],
        subcriptionId: json['subcription_id'],
        $all: json['_all'],
      );

  final int? id;

  final int? slug;

  final int? uuid;

  final int? vendorId;

  final int? percentage;

  final int? location;

  final int? phone;

  final int? showType;

  final int? open;

  final int? visibility;

  final int? backgroundImg;

  final int? logoImg;

  final int? status;

  final int? statusNote;

  final int? price;

  final int? createdAt;

  final int? updatedAt;

  final int? deletedAt;

  final int? verify;

  final int? orderPayment;

  final int? moduleId;

  final int? subcriptionId;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
        '_all': $all,
      };
}

class StoreAvgAggregateOutputType {
  const StoreAvgAggregateOutputType({
    this.id,
    this.vendorId,
    this.percentage,
    this.price,
    this.moduleId,
    this.subcriptionId,
  });

  factory StoreAvgAggregateOutputType.fromJson(Map json) =>
      StoreAvgAggregateOutputType(
        id: json['id'],
        vendorId: json['vendor_id'],
        percentage: json['percentage'],
        price: json['price'],
        moduleId: json['module_id'],
        subcriptionId: json['subcription_id'],
      );

  final double? id;

  final double? vendorId;

  final _i1.Decimal? percentage;

  final double? price;

  final double? moduleId;

  final double? subcriptionId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'percentage': percentage,
        'price': price,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreSumAggregateOutputType {
  const StoreSumAggregateOutputType({
    this.id,
    this.vendorId,
    this.percentage,
    this.price,
    this.moduleId,
    this.subcriptionId,
  });

  factory StoreSumAggregateOutputType.fromJson(Map json) =>
      StoreSumAggregateOutputType(
        id: json['id'],
        vendorId: json['vendor_id'],
        percentage: json['percentage'],
        price: json['price'],
        moduleId: json['module_id'],
        subcriptionId: json['subcription_id'],
      );

  final int? id;

  final int? vendorId;

  final _i1.Decimal? percentage;

  final int? price;

  final int? moduleId;

  final int? subcriptionId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'percentage': percentage,
        'price': price,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreMinAggregateOutputType {
  const StoreMinAggregateOutputType({
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  factory StoreMinAggregateOutputType.fromJson(Map json) =>
      StoreMinAggregateOutputType(
        id: json['id'],
        slug: json['slug'],
        uuid: json['uuid'],
        vendorId: json['vendor_id'],
        percentage: json['percentage'],
        location: json['location'],
        phone: json['phone'],
        showType: json['show_type'],
        open: json['open'],
        visibility: json['visibility'],
        backgroundImg: json['background_img'],
        logoImg: json['logo_img'],
        status: json['status'],
        statusNote: json['status_note'],
        price: json['price'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        deletedAt: switch (json['deleted_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['deleted_at']
        },
        verify: json['verify'],
        orderPayment: json['order_payment'],
        moduleId: json['module_id'],
        subcriptionId: json['subcription_id'],
      );

  final int? id;

  final String? slug;

  final String? uuid;

  final int? vendorId;

  final _i1.Decimal? percentage;

  final String? location;

  final String? phone;

  final String? showType;

  final bool? open;

  final bool? visibility;

  final String? backgroundImg;

  final String? logoImg;

  final String? status;

  final String? statusNote;

  final int? price;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final DateTime? deletedAt;

  final bool? verify;

  final String? orderPayment;

  final int? moduleId;

  final int? subcriptionId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        'deleted_at': deletedAt?.toIso8601String(),
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreMaxAggregateOutputType {
  const StoreMaxAggregateOutputType({
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  factory StoreMaxAggregateOutputType.fromJson(Map json) =>
      StoreMaxAggregateOutputType(
        id: json['id'],
        slug: json['slug'],
        uuid: json['uuid'],
        vendorId: json['vendor_id'],
        percentage: json['percentage'],
        location: json['location'],
        phone: json['phone'],
        showType: json['show_type'],
        open: json['open'],
        visibility: json['visibility'],
        backgroundImg: json['background_img'],
        logoImg: json['logo_img'],
        status: json['status'],
        statusNote: json['status_note'],
        price: json['price'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        deletedAt: switch (json['deleted_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['deleted_at']
        },
        verify: json['verify'],
        orderPayment: json['order_payment'],
        moduleId: json['module_id'],
        subcriptionId: json['subcription_id'],
      );

  final int? id;

  final String? slug;

  final String? uuid;

  final int? vendorId;

  final _i1.Decimal? percentage;

  final String? location;

  final String? phone;

  final String? showType;

  final bool? open;

  final bool? visibility;

  final String? backgroundImg;

  final String? logoImg;

  final String? status;

  final String? statusNote;

  final int? price;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final DateTime? deletedAt;

  final bool? verify;

  final String? orderPayment;

  final int? moduleId;

  final int? subcriptionId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        'deleted_at': deletedAt?.toIso8601String(),
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreGroupByOutputType {
  const StoreGroupByOutputType({
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory StoreGroupByOutputType.fromJson(Map json) => StoreGroupByOutputType(
        id: json['id'],
        slug: json['slug'],
        uuid: json['uuid'],
        vendorId: json['vendor_id'],
        percentage: json['percentage'],
        location: json['location'],
        phone: json['phone'],
        showType: json['show_type'],
        open: json['open'],
        visibility: json['visibility'],
        backgroundImg: json['background_img'],
        logoImg: json['logo_img'],
        status: json['status'],
        statusNote: json['status_note'],
        price: json['price'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        deletedAt: switch (json['deleted_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['deleted_at']
        },
        verify: json['verify'],
        orderPayment: json['order_payment'],
        moduleId: json['module_id'],
        subcriptionId: json['subcription_id'],
        $count: json['_count'] is Map
            ? _i2.StoreCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.StoreAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.StoreSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.StoreMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.StoreMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? slug;

  final String? uuid;

  final int? vendorId;

  final _i1.Decimal? percentage;

  final String? location;

  final String? phone;

  final String? showType;

  final bool? open;

  final bool? visibility;

  final String? backgroundImg;

  final String? logoImg;

  final String? status;

  final String? statusNote;

  final int? price;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final DateTime? deletedAt;

  final bool? verify;

  final String? orderPayment;

  final int? moduleId;

  final int? subcriptionId;

  final _i2.StoreCountAggregateOutputType? $count;

  final _i2.StoreAvgAggregateOutputType? $avg;

  final _i2.StoreSumAggregateOutputType? $sum;

  final _i2.StoreMinAggregateOutputType? $min;

  final _i2.StoreMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        'deleted_at': deletedAt?.toIso8601String(),
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class StoreCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreCountOrderByAggregateInput({
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? slug;

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? percentage;

  final _i2.SortOrder? location;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? showType;

  final _i2.SortOrder? open;

  final _i2.SortOrder? visibility;

  final _i2.SortOrder? backgroundImg;

  final _i2.SortOrder? logoImg;

  final _i2.SortOrder? status;

  final _i2.SortOrder? statusNote;

  final _i2.SortOrder? price;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SortOrder? deletedAt;

  final _i2.SortOrder? verify;

  final _i2.SortOrder? orderPayment;

  final _i2.SortOrder? moduleId;

  final _i2.SortOrder? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreAvgOrderByAggregateInput({
    this.id,
    this.vendorId,
    this.percentage,
    this.price,
    this.moduleId,
    this.subcriptionId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? percentage;

  final _i2.SortOrder? price;

  final _i2.SortOrder? moduleId;

  final _i2.SortOrder? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'percentage': percentage,
        'price': price,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreMaxOrderByAggregateInput({
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? slug;

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? percentage;

  final _i2.SortOrder? location;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? showType;

  final _i2.SortOrder? open;

  final _i2.SortOrder? visibility;

  final _i2.SortOrder? backgroundImg;

  final _i2.SortOrder? logoImg;

  final _i2.SortOrder? status;

  final _i2.SortOrder? statusNote;

  final _i2.SortOrder? price;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SortOrder? deletedAt;

  final _i2.SortOrder? verify;

  final _i2.SortOrder? orderPayment;

  final _i2.SortOrder? moduleId;

  final _i2.SortOrder? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreMinOrderByAggregateInput({
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? slug;

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? percentage;

  final _i2.SortOrder? location;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? showType;

  final _i2.SortOrder? open;

  final _i2.SortOrder? visibility;

  final _i2.SortOrder? backgroundImg;

  final _i2.SortOrder? logoImg;

  final _i2.SortOrder? status;

  final _i2.SortOrder? statusNote;

  final _i2.SortOrder? price;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SortOrder? deletedAt;

  final _i2.SortOrder? verify;

  final _i2.SortOrder? orderPayment;

  final _i2.SortOrder? moduleId;

  final _i2.SortOrder? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreSumOrderByAggregateInput({
    this.id,
    this.vendorId,
    this.percentage,
    this.price,
    this.moduleId,
    this.subcriptionId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? percentage;

  final _i2.SortOrder? price;

  final _i2.SortOrder? moduleId;

  final _i2.SortOrder? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'percentage': percentage,
        'price': price,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreOrderByWithAggregationInput({
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? slug;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? vendorId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? percentage;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? location;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? phone;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? showType;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? open;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? visibility;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? backgroundImg;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? logoImg;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? statusNote;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? price;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? deletedAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? verify;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? orderPayment;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? moduleId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? subcriptionId;

  final _i2.StoreCountOrderByAggregateInput? $count;

  final _i2.StoreAvgOrderByAggregateInput? $avg;

  final _i2.StoreMaxOrderByAggregateInput? $max;

  final _i2.StoreMinOrderByAggregateInput? $min;

  final _i2.StoreSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class StoreScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  final _i1.PrismaUnion<_i2.StoreScalarWhereWithAggregatesInput,
      Iterable<_i2.StoreScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.StoreScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.StoreScalarWhereWithAggregatesInput,
      Iterable<_i2.StoreScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? slug;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<_i2.DecimalNullableWithAggregatesFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? percentage;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? showType;

  final _i1.PrismaUnion<_i2.BoolNullableWithAggregatesFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? open;

  final _i1.PrismaUnion<_i2.BoolNullableWithAggregatesFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? visibility;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? backgroundImg;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? logoImg;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? statusNote;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? deletedAt;

  final _i1.PrismaUnion<_i2.BoolNullableWithAggregatesFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? verify;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? orderPayment;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? moduleId;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreCountAggregateOutputTypeSelect({
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
    this.$all,
  });

  final bool? id;

  final bool? slug;

  final bool? uuid;

  final bool? vendorId;

  final bool? percentage;

  final bool? location;

  final bool? phone;

  final bool? showType;

  final bool? open;

  final bool? visibility;

  final bool? backgroundImg;

  final bool? logoImg;

  final bool? status;

  final bool? statusNote;

  final bool? price;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? deletedAt;

  final bool? verify;

  final bool? orderPayment;

  final bool? moduleId;

  final bool? subcriptionId;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
        '_all': $all,
      };
}

class StoreGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreGroupByOutputTypeCountArgs({this.select});

  final _i2.StoreCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StoreAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreAvgAggregateOutputTypeSelect({
    this.id,
    this.vendorId,
    this.percentage,
    this.price,
    this.moduleId,
    this.subcriptionId,
  });

  final bool? id;

  final bool? vendorId;

  final bool? percentage;

  final bool? price;

  final bool? moduleId;

  final bool? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'percentage': percentage,
        'price': price,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreGroupByOutputTypeAvgArgs({this.select});

  final _i2.StoreAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StoreSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreSumAggregateOutputTypeSelect({
    this.id,
    this.vendorId,
    this.percentage,
    this.price,
    this.moduleId,
    this.subcriptionId,
  });

  final bool? id;

  final bool? vendorId;

  final bool? percentage;

  final bool? price;

  final bool? moduleId;

  final bool? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'percentage': percentage,
        'price': price,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreGroupByOutputTypeSumArgs({this.select});

  final _i2.StoreSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StoreMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreMinAggregateOutputTypeSelect({
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  final bool? id;

  final bool? slug;

  final bool? uuid;

  final bool? vendorId;

  final bool? percentage;

  final bool? location;

  final bool? phone;

  final bool? showType;

  final bool? open;

  final bool? visibility;

  final bool? backgroundImg;

  final bool? logoImg;

  final bool? status;

  final bool? statusNote;

  final bool? price;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? deletedAt;

  final bool? verify;

  final bool? orderPayment;

  final bool? moduleId;

  final bool? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreGroupByOutputTypeMinArgs({this.select});

  final _i2.StoreMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StoreMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreMaxAggregateOutputTypeSelect({
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
  });

  final bool? id;

  final bool? slug;

  final bool? uuid;

  final bool? vendorId;

  final bool? percentage;

  final bool? location;

  final bool? phone;

  final bool? showType;

  final bool? open;

  final bool? visibility;

  final bool? backgroundImg;

  final bool? logoImg;

  final bool? status;

  final bool? statusNote;

  final bool? price;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? deletedAt;

  final bool? verify;

  final bool? orderPayment;

  final bool? moduleId;

  final bool? subcriptionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
      };
}

class StoreGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreGroupByOutputTypeMaxArgs({this.select});

  final _i2.StoreMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class StoreGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const StoreGroupByOutputTypeSelect({
    this.id,
    this.slug,
    this.uuid,
    this.vendorId,
    this.percentage,
    this.location,
    this.phone,
    this.showType,
    this.open,
    this.visibility,
    this.backgroundImg,
    this.logoImg,
    this.status,
    this.statusNote,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.verify,
    this.orderPayment,
    this.moduleId,
    this.subcriptionId,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? slug;

  final bool? uuid;

  final bool? vendorId;

  final bool? percentage;

  final bool? location;

  final bool? phone;

  final bool? showType;

  final bool? open;

  final bool? visibility;

  final bool? backgroundImg;

  final bool? logoImg;

  final bool? status;

  final bool? statusNote;

  final bool? price;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? deletedAt;

  final bool? verify;

  final bool? orderPayment;

  final bool? moduleId;

  final bool? subcriptionId;

  final _i1.PrismaUnion<bool, _i2.StoreGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.StoreGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.StoreGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.StoreGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.StoreGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'slug': slug,
        'uuid': uuid,
        'vendor_id': vendorId,
        'percentage': percentage,
        'location': location,
        'phone': phone,
        'show_type': showType,
        'open': open,
        'visibility': visibility,
        'background_img': backgroundImg,
        'logo_img': logoImg,
        'status': status,
        'status_note': statusNote,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        'verify': verify,
        'order_payment': orderPayment,
        'module_id': moduleId,
        'subcription_id': subcriptionId,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateStore {
  const AggregateStore({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateStore.fromJson(Map json) => AggregateStore(
        $count: json['_count'] is Map
            ? _i2.StoreCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.StoreAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.StoreSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.StoreMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.StoreMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.StoreCountAggregateOutputType? $count;

  final _i2.StoreAvgAggregateOutputType? $avg;

  final _i2.StoreSumAggregateOutputType? $sum;

  final _i2.StoreMinAggregateOutputType? $min;

  final _i2.StoreMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateStoreCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStoreCountArgs({this.select});

  final _i2.StoreCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStoreAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStoreAvgArgs({this.select});

  final _i2.StoreAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStoreSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStoreSumArgs({this.select});

  final _i2.StoreSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStoreMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStoreMinArgs({this.select});

  final _i2.StoreMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStoreMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStoreMaxArgs({this.select});

  final _i2.StoreMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateStoreSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateStoreSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateStoreCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateStoreAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateStoreSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateStoreMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateStoreMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AdminWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.AdminWhereInput, Iterable<_i2.AdminWhereInput>>?
      AND;

  final Iterable<_i2.AdminWhereInput>? OR;

  final _i1.PrismaUnion<_i2.AdminWhereInput, Iterable<_i2.AdminWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AdminWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.AdminWhereInput, Iterable<_i2.AdminWhereInput>>?
      AND;

  final Iterable<_i2.AdminWhereInput>? OR;

  final _i1.PrismaUnion<_i2.AdminWhereInput, Iterable<_i2.AdminWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AdminSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminSelect({
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? lastname;

  final bool? email;

  final bool? password;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AdminOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminOrderByWithRelationInput({
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? lastname;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? email;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? password;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

enum AdminScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Admin'),
  name$<String>('name', 'Admin'),
  lastname<String>('lastname', 'Admin'),
  email<String>('email', 'Admin'),
  password<String>('password', 'Admin'),
  createdAt<DateTime>('created_at', 'Admin'),
  updatedAt<DateTime>('updated_at', 'Admin');

  const AdminScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class AdminCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminCreateInput({
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? lastname;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AdminUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminUncheckedCreateInput({
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? lastname;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AdminCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminCreateManyInput({
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? lastname;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AdminUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminUpdateInput({
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AdminUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminUncheckedUpdateInput({
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AdminUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminUpdateManyMutationInput({
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AdminUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminUncheckedUpdateManyInput({
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AdminCountAggregateOutputType {
  const AdminCountAggregateOutputType({
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory AdminCountAggregateOutputType.fromJson(Map json) =>
      AdminCountAggregateOutputType(
        id: json['id'],
        name: json['name'],
        lastname: json['lastname'],
        email: json['email'],
        password: json['password'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? name;

  final int? lastname;

  final int? email;

  final int? password;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class AdminAvgAggregateOutputType {
  const AdminAvgAggregateOutputType({this.id});

  factory AdminAvgAggregateOutputType.fromJson(Map json) =>
      AdminAvgAggregateOutputType(id: json['id']);

  final double? id;

  Map<String, dynamic> toJson() => {'id': id};
}

class AdminSumAggregateOutputType {
  const AdminSumAggregateOutputType({this.id});

  factory AdminSumAggregateOutputType.fromJson(Map json) =>
      AdminSumAggregateOutputType(id: json['id']);

  final int? id;

  Map<String, dynamic> toJson() => {'id': id};
}

class AdminMinAggregateOutputType {
  const AdminMinAggregateOutputType({
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  factory AdminMinAggregateOutputType.fromJson(Map json) =>
      AdminMinAggregateOutputType(
        id: json['id'],
        name: json['name'],
        lastname: json['lastname'],
        email: json['email'],
        password: json['password'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final String? name;

  final String? lastname;

  final String? email;

  final String? password;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class AdminMaxAggregateOutputType {
  const AdminMaxAggregateOutputType({
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  factory AdminMaxAggregateOutputType.fromJson(Map json) =>
      AdminMaxAggregateOutputType(
        id: json['id'],
        name: json['name'],
        lastname: json['lastname'],
        email: json['email'],
        password: json['password'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final String? name;

  final String? lastname;

  final String? email;

  final String? password;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class AdminGroupByOutputType {
  const AdminGroupByOutputType({
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AdminGroupByOutputType.fromJson(Map json) => AdminGroupByOutputType(
        id: json['id'],
        name: json['name'],
        lastname: json['lastname'],
        email: json['email'],
        password: json['password'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        $count: json['_count'] is Map
            ? _i2.AdminCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.AdminAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.AdminSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.AdminMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.AdminMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? name;

  final String? lastname;

  final String? email;

  final String? password;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AdminCountAggregateOutputType? $count;

  final _i2.AdminAvgAggregateOutputType? $avg;

  final _i2.AdminSumAggregateOutputType? $sum;

  final _i2.AdminMinAggregateOutputType? $min;

  final _i2.AdminMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AdminCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminCountOrderByAggregateInput({
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? lastname;

  final _i2.SortOrder? email;

  final _i2.SortOrder? password;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AdminAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminAvgOrderByAggregateInput({this.id});

  final _i2.SortOrder? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class AdminMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminMaxOrderByAggregateInput({
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? lastname;

  final _i2.SortOrder? email;

  final _i2.SortOrder? password;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AdminMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminMinOrderByAggregateInput({
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? lastname;

  final _i2.SortOrder? email;

  final _i2.SortOrder? password;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AdminSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminSumOrderByAggregateInput({this.id});

  final _i2.SortOrder? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class AdminOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminOrderByWithAggregationInput({
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? lastname;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? email;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? password;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i2.AdminCountOrderByAggregateInput? $count;

  final _i2.AdminAvgOrderByAggregateInput? $avg;

  final _i2.AdminMaxOrderByAggregateInput? $max;

  final _i2.AdminMinOrderByAggregateInput? $min;

  final _i2.AdminSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class AdminScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.AdminScalarWhereWithAggregatesInput,
      Iterable<_i2.AdminScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.AdminScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.AdminScalarWhereWithAggregatesInput,
      Iterable<_i2.AdminScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AdminCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminCountAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? name;

  final bool? lastname;

  final bool? email;

  final bool? password;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class AdminGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminGroupByOutputTypeCountArgs({this.select});

  final _i2.AdminCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AdminAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminAvgAggregateOutputTypeSelect({this.id});

  final bool? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class AdminGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminGroupByOutputTypeAvgArgs({this.select});

  final _i2.AdminAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AdminSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminSumAggregateOutputTypeSelect({this.id});

  final bool? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class AdminGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminGroupByOutputTypeSumArgs({this.select});

  final _i2.AdminSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AdminMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminMinAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? lastname;

  final bool? email;

  final bool? password;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AdminGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminGroupByOutputTypeMinArgs({this.select});

  final _i2.AdminMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AdminMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminMaxAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? lastname;

  final bool? email;

  final bool? password;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AdminGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminGroupByOutputTypeMaxArgs({this.select});

  final _i2.AdminMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AdminGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AdminGroupByOutputTypeSelect({
    this.id,
    this.name,
    this.lastname,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? name;

  final bool? lastname;

  final bool? email;

  final bool? password;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.AdminGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AdminGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AdminGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AdminGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AdminGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'email': email,
        'password': password,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateAdmin {
  const AggregateAdmin({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateAdmin.fromJson(Map json) => AggregateAdmin(
        $count: json['_count'] is Map
            ? _i2.AdminCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.AdminAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.AdminSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.AdminMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.AdminMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.AdminCountAggregateOutputType? $count;

  final _i2.AdminAvgAggregateOutputType? $avg;

  final _i2.AdminSumAggregateOutputType? $sum;

  final _i2.AdminMinAggregateOutputType? $min;

  final _i2.AdminMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateAdminCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAdminCountArgs({this.select});

  final _i2.AdminCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAdminAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAdminAvgArgs({this.select});

  final _i2.AdminAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAdminSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAdminSumArgs({this.select});

  final _i2.AdminSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAdminMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAdminMinArgs({this.select});

  final _i2.AdminMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAdminMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAdminMaxArgs({this.select});

  final _i2.AdminMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAdminSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAdminSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateAdminCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateAdminAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateAdminSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateAdminMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateAdminMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class UserWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.UserWhereInput, Iterable<_i2.UserWhereInput>>? AND;

  final Iterable<_i2.UserWhereInput>? OR;

  final _i1.PrismaUnion<_i2.UserWhereInput, Iterable<_i2.UserWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? birthday;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? gender;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      district;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? signInMethod;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? emailVerifyAt;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? phoneVerifyAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? imgProfile;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? otpCode;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? verifyCode;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? myReferral;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? referral;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserWhereUniqueInput({
    this.id,
    this.uuid,
    this.email,
    this.phone,
    this.verifyCode,
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.lastname,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final String? uuid;

  final String? email;

  final String? phone;

  final String? verifyCode;

  final _i1.PrismaUnion<_i2.UserWhereInput, Iterable<_i2.UserWhereInput>>? AND;

  final Iterable<_i2.UserWhereInput>? OR;

  final _i1.PrismaUnion<_i2.UserWhereInput, Iterable<_i2.UserWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? birthday;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? gender;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      district;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? signInMethod;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? emailVerifyAt;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? phoneVerifyAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? imgProfile;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? otpCode;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? myReferral;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? referral;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'email': email,
        'phone': phone,
        'verify_code': verifyCode,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'name': name,
        'lastname': lastname,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserSelect({
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? uuid;

  final bool? name;

  final bool? lastname;

  final bool? email;

  final bool? phone;

  final bool? password;

  final bool? birthday;

  final bool? gender;

  final bool? district;

  final bool? signInMethod;

  final bool? emailVerifyAt;

  final bool? phoneVerifyAt;

  final bool? imgProfile;

  final bool? fcmToken;

  final bool? otpCode;

  final bool? verifyCode;

  final bool? myReferral;

  final bool? referral;

  final bool? location;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserOrderByWithRelationInput({
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? lastname;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? email;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? phone;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? password;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? birthday;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? gender;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? district;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? signInMethod;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? emailVerifyAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? phoneVerifyAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? imgProfile;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? fcmToken;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? otpCode;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? verifyCode;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? myReferral;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? referral;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? location;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

enum UserScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'User'),
  uuid<String>('uuid', 'User'),
  name$<String>('name', 'User'),
  lastname<String>('lastname', 'User'),
  email<String>('email', 'User'),
  phone<String>('phone', 'User'),
  password<String>('password', 'User'),
  birthday<DateTime>('birthday', 'User'),
  gender<String>('gender', 'User'),
  district<int>('district', 'User'),
  signInMethod<String>('sign_in_method', 'User'),
  emailVerifyAt<bool>('email_verify_at', 'User'),
  phoneVerifyAt<bool>('phone_verify_at', 'User'),
  imgProfile<String>('img_profile', 'User'),
  fcmToken<String>('fcm_token', 'User'),
  otpCode<String>('otp_code', 'User'),
  verifyCode<String>('verify_code', 'User'),
  myReferral<String>('my_referral', 'User'),
  referral<String>('referral', 'User'),
  location<String>('location', 'User'),
  createdAt<DateTime>('created_at', 'User'),
  updatedAt<DateTime>('updated_at', 'User');

  const UserScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class UserCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateInput({
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? lastname;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? birthday;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? gender;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? district;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? signInMethod;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? emailVerifyAt;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? phoneVerifyAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? imgProfile;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? fcmToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? otpCode;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? verifyCode;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? myReferral;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? referral;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? location;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedCreateInput({
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? lastname;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? birthday;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? gender;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? district;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? signInMethod;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? emailVerifyAt;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? phoneVerifyAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? imgProfile;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? fcmToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? otpCode;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? verifyCode;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? myReferral;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? referral;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? location;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserCreateManyInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCreateManyInput({
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? lastname;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? birthday;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? gender;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? district;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? signInMethod;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? emailVerifyAt;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? phoneVerifyAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? imgProfile;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? fcmToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? otpCode;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? verifyCode;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? myReferral;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? referral;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? location;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateInput({
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? birthday;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? gender;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? district;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? signInMethod;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? emailVerifyAt;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phoneVerifyAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? imgProfile;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? otpCode;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? verifyCode;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? myReferral;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? referral;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateInput({
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? birthday;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? gender;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? district;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? signInMethod;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? emailVerifyAt;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phoneVerifyAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? imgProfile;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? otpCode;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? verifyCode;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? myReferral;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? referral;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUpdateManyMutationInput({
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? birthday;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? gender;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? district;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? signInMethod;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? emailVerifyAt;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phoneVerifyAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? imgProfile;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? otpCode;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? verifyCode;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? myReferral;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? referral;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserUncheckedUpdateManyInput({
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? birthday;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? gender;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? district;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? signInMethod;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? emailVerifyAt;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phoneVerifyAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? imgProfile;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? otpCode;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? verifyCode;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? myReferral;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? referral;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserCountAggregateOutputType {
  const UserCountAggregateOutputType({
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory UserCountAggregateOutputType.fromJson(Map json) =>
      UserCountAggregateOutputType(
        id: json['id'],
        uuid: json['uuid'],
        name: json['name'],
        lastname: json['lastname'],
        email: json['email'],
        phone: json['phone'],
        password: json['password'],
        birthday: json['birthday'],
        gender: json['gender'],
        district: json['district'],
        signInMethod: json['sign_in_method'],
        emailVerifyAt: json['email_verify_at'],
        phoneVerifyAt: json['phone_verify_at'],
        imgProfile: json['img_profile'],
        fcmToken: json['fcm_token'],
        otpCode: json['otp_code'],
        verifyCode: json['verify_code'],
        myReferral: json['my_referral'],
        referral: json['referral'],
        location: json['location'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? uuid;

  final int? name;

  final int? lastname;

  final int? email;

  final int? phone;

  final int? password;

  final int? birthday;

  final int? gender;

  final int? district;

  final int? signInMethod;

  final int? emailVerifyAt;

  final int? phoneVerifyAt;

  final int? imgProfile;

  final int? fcmToken;

  final int? otpCode;

  final int? verifyCode;

  final int? myReferral;

  final int? referral;

  final int? location;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class UserAvgAggregateOutputType {
  const UserAvgAggregateOutputType({
    this.id,
    this.district,
  });

  factory UserAvgAggregateOutputType.fromJson(Map json) =>
      UserAvgAggregateOutputType(
        id: json['id'],
        district: json['district'],
      );

  final double? id;

  final double? district;

  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
      };
}

class UserSumAggregateOutputType {
  const UserSumAggregateOutputType({
    this.id,
    this.district,
  });

  factory UserSumAggregateOutputType.fromJson(Map json) =>
      UserSumAggregateOutputType(
        id: json['id'],
        district: json['district'],
      );

  final int? id;

  final int? district;

  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
      };
}

class UserMinAggregateOutputType {
  const UserMinAggregateOutputType({
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  factory UserMinAggregateOutputType.fromJson(Map json) =>
      UserMinAggregateOutputType(
        id: json['id'],
        uuid: json['uuid'],
        name: json['name'],
        lastname: json['lastname'],
        email: json['email'],
        phone: json['phone'],
        password: json['password'],
        birthday: switch (json['birthday']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['birthday']
        },
        gender: json['gender'],
        district: json['district'],
        signInMethod: json['sign_in_method'],
        emailVerifyAt: json['email_verify_at'],
        phoneVerifyAt: json['phone_verify_at'],
        imgProfile: json['img_profile'],
        fcmToken: json['fcm_token'],
        otpCode: json['otp_code'],
        verifyCode: json['verify_code'],
        myReferral: json['my_referral'],
        referral: json['referral'],
        location: json['location'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final String? uuid;

  final String? name;

  final String? lastname;

  final String? email;

  final String? phone;

  final String? password;

  final DateTime? birthday;

  final String? gender;

  final int? district;

  final String? signInMethod;

  final bool? emailVerifyAt;

  final bool? phoneVerifyAt;

  final String? imgProfile;

  final String? fcmToken;

  final String? otpCode;

  final String? verifyCode;

  final String? myReferral;

  final String? referral;

  final String? location;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday?.toIso8601String(),
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class UserMaxAggregateOutputType {
  const UserMaxAggregateOutputType({
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  factory UserMaxAggregateOutputType.fromJson(Map json) =>
      UserMaxAggregateOutputType(
        id: json['id'],
        uuid: json['uuid'],
        name: json['name'],
        lastname: json['lastname'],
        email: json['email'],
        phone: json['phone'],
        password: json['password'],
        birthday: switch (json['birthday']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['birthday']
        },
        gender: json['gender'],
        district: json['district'],
        signInMethod: json['sign_in_method'],
        emailVerifyAt: json['email_verify_at'],
        phoneVerifyAt: json['phone_verify_at'],
        imgProfile: json['img_profile'],
        fcmToken: json['fcm_token'],
        otpCode: json['otp_code'],
        verifyCode: json['verify_code'],
        myReferral: json['my_referral'],
        referral: json['referral'],
        location: json['location'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final String? uuid;

  final String? name;

  final String? lastname;

  final String? email;

  final String? phone;

  final String? password;

  final DateTime? birthday;

  final String? gender;

  final int? district;

  final String? signInMethod;

  final bool? emailVerifyAt;

  final bool? phoneVerifyAt;

  final String? imgProfile;

  final String? fcmToken;

  final String? otpCode;

  final String? verifyCode;

  final String? myReferral;

  final String? referral;

  final String? location;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday?.toIso8601String(),
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class UserGroupByOutputType {
  const UserGroupByOutputType({
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory UserGroupByOutputType.fromJson(Map json) => UserGroupByOutputType(
        id: json['id'],
        uuid: json['uuid'],
        name: json['name'],
        lastname: json['lastname'],
        email: json['email'],
        phone: json['phone'],
        password: json['password'],
        birthday: switch (json['birthday']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['birthday']
        },
        gender: json['gender'],
        district: json['district'],
        signInMethod: json['sign_in_method'],
        emailVerifyAt: json['email_verify_at'],
        phoneVerifyAt: json['phone_verify_at'],
        imgProfile: json['img_profile'],
        fcmToken: json['fcm_token'],
        otpCode: json['otp_code'],
        verifyCode: json['verify_code'],
        myReferral: json['my_referral'],
        referral: json['referral'],
        location: json['location'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        $count: json['_count'] is Map
            ? _i2.UserCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.UserAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.UserSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.UserMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.UserMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? uuid;

  final String? name;

  final String? lastname;

  final String? email;

  final String? phone;

  final String? password;

  final DateTime? birthday;

  final String? gender;

  final int? district;

  final String? signInMethod;

  final bool? emailVerifyAt;

  final bool? phoneVerifyAt;

  final String? imgProfile;

  final String? fcmToken;

  final String? otpCode;

  final String? verifyCode;

  final String? myReferral;

  final String? referral;

  final String? location;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserCountAggregateOutputType? $count;

  final _i2.UserAvgAggregateOutputType? $avg;

  final _i2.UserSumAggregateOutputType? $sum;

  final _i2.UserMinAggregateOutputType? $min;

  final _i2.UserMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday?.toIso8601String(),
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class UserCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCountOrderByAggregateInput({
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? name;

  final _i2.SortOrder? lastname;

  final _i2.SortOrder? email;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? password;

  final _i2.SortOrder? birthday;

  final _i2.SortOrder? gender;

  final _i2.SortOrder? district;

  final _i2.SortOrder? signInMethod;

  final _i2.SortOrder? emailVerifyAt;

  final _i2.SortOrder? phoneVerifyAt;

  final _i2.SortOrder? imgProfile;

  final _i2.SortOrder? fcmToken;

  final _i2.SortOrder? otpCode;

  final _i2.SortOrder? verifyCode;

  final _i2.SortOrder? myReferral;

  final _i2.SortOrder? referral;

  final _i2.SortOrder? location;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserAvgOrderByAggregateInput({
    this.id,
    this.district,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? district;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
      };
}

class UserMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserMaxOrderByAggregateInput({
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? name;

  final _i2.SortOrder? lastname;

  final _i2.SortOrder? email;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? password;

  final _i2.SortOrder? birthday;

  final _i2.SortOrder? gender;

  final _i2.SortOrder? district;

  final _i2.SortOrder? signInMethod;

  final _i2.SortOrder? emailVerifyAt;

  final _i2.SortOrder? phoneVerifyAt;

  final _i2.SortOrder? imgProfile;

  final _i2.SortOrder? fcmToken;

  final _i2.SortOrder? otpCode;

  final _i2.SortOrder? verifyCode;

  final _i2.SortOrder? myReferral;

  final _i2.SortOrder? referral;

  final _i2.SortOrder? location;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserMinOrderByAggregateInput({
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? name;

  final _i2.SortOrder? lastname;

  final _i2.SortOrder? email;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? password;

  final _i2.SortOrder? birthday;

  final _i2.SortOrder? gender;

  final _i2.SortOrder? district;

  final _i2.SortOrder? signInMethod;

  final _i2.SortOrder? emailVerifyAt;

  final _i2.SortOrder? phoneVerifyAt;

  final _i2.SortOrder? imgProfile;

  final _i2.SortOrder? fcmToken;

  final _i2.SortOrder? otpCode;

  final _i2.SortOrder? verifyCode;

  final _i2.SortOrder? myReferral;

  final _i2.SortOrder? referral;

  final _i2.SortOrder? location;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserSumOrderByAggregateInput({
    this.id,
    this.district,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? district;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
      };
}

class UserOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserOrderByWithAggregationInput({
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? lastname;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? email;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? phone;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? password;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? birthday;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? gender;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? district;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? signInMethod;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? emailVerifyAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? phoneVerifyAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? imgProfile;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? fcmToken;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? otpCode;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? verifyCode;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? myReferral;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? referral;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? location;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i2.UserCountOrderByAggregateInput? $count;

  final _i2.UserAvgOrderByAggregateInput? $avg;

  final _i2.UserMaxOrderByAggregateInput? $max;

  final _i2.UserMinOrderByAggregateInput? $min;

  final _i2.UserSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class UserScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.UserScalarWhereWithAggregatesInput,
      Iterable<_i2.UserScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.UserScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.UserScalarWhereWithAggregatesInput,
      Iterable<_i2.UserScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? birthday;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? gender;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? district;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? signInMethod;

  final _i1.PrismaUnion<_i2.BoolNullableWithAggregatesFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? emailVerifyAt;

  final _i1.PrismaUnion<_i2.BoolNullableWithAggregatesFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? phoneVerifyAt;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? imgProfile;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? otpCode;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? verifyCode;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? myReferral;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? referral;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserCountAggregateOutputTypeSelect({
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? uuid;

  final bool? name;

  final bool? lastname;

  final bool? email;

  final bool? phone;

  final bool? password;

  final bool? birthday;

  final bool? gender;

  final bool? district;

  final bool? signInMethod;

  final bool? emailVerifyAt;

  final bool? phoneVerifyAt;

  final bool? imgProfile;

  final bool? fcmToken;

  final bool? otpCode;

  final bool? verifyCode;

  final bool? myReferral;

  final bool? referral;

  final bool? location;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class UserGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserGroupByOutputTypeCountArgs({this.select});

  final _i2.UserCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserAvgAggregateOutputTypeSelect({
    this.id,
    this.district,
  });

  final bool? id;

  final bool? district;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
      };
}

class UserGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserGroupByOutputTypeAvgArgs({this.select});

  final _i2.UserAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserSumAggregateOutputTypeSelect({
    this.id,
    this.district,
  });

  final bool? id;

  final bool? district;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
      };
}

class UserGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserGroupByOutputTypeSumArgs({this.select});

  final _i2.UserSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserMinAggregateOutputTypeSelect({
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? uuid;

  final bool? name;

  final bool? lastname;

  final bool? email;

  final bool? phone;

  final bool? password;

  final bool? birthday;

  final bool? gender;

  final bool? district;

  final bool? signInMethod;

  final bool? emailVerifyAt;

  final bool? phoneVerifyAt;

  final bool? imgProfile;

  final bool? fcmToken;

  final bool? otpCode;

  final bool? verifyCode;

  final bool? myReferral;

  final bool? referral;

  final bool? location;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserGroupByOutputTypeMinArgs({this.select});

  final _i2.UserMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserMaxAggregateOutputTypeSelect({
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? uuid;

  final bool? name;

  final bool? lastname;

  final bool? email;

  final bool? phone;

  final bool? password;

  final bool? birthday;

  final bool? gender;

  final bool? district;

  final bool? signInMethod;

  final bool? emailVerifyAt;

  final bool? phoneVerifyAt;

  final bool? imgProfile;

  final bool? fcmToken;

  final bool? otpCode;

  final bool? verifyCode;

  final bool? myReferral;

  final bool? referral;

  final bool? location;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserGroupByOutputTypeMaxArgs({this.select});

  final _i2.UserMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserGroupByOutputTypeSelect({
    this.id,
    this.uuid,
    this.name,
    this.lastname,
    this.email,
    this.phone,
    this.password,
    this.birthday,
    this.gender,
    this.district,
    this.signInMethod,
    this.emailVerifyAt,
    this.phoneVerifyAt,
    this.imgProfile,
    this.fcmToken,
    this.otpCode,
    this.verifyCode,
    this.myReferral,
    this.referral,
    this.location,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? uuid;

  final bool? name;

  final bool? lastname;

  final bool? email;

  final bool? phone;

  final bool? password;

  final bool? birthday;

  final bool? gender;

  final bool? district;

  final bool? signInMethod;

  final bool? emailVerifyAt;

  final bool? phoneVerifyAt;

  final bool? imgProfile;

  final bool? fcmToken;

  final bool? otpCode;

  final bool? verifyCode;

  final bool? myReferral;

  final bool? referral;

  final bool? location;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.UserGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.UserGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.UserGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.UserGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.UserGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'name': name,
        'lastname': lastname,
        'email': email,
        'phone': phone,
        'password': password,
        'birthday': birthday,
        'gender': gender,
        'district': district,
        'sign_in_method': signInMethod,
        'email_verify_at': emailVerifyAt,
        'phone_verify_at': phoneVerifyAt,
        'img_profile': imgProfile,
        'fcm_token': fcmToken,
        'otp_code': otpCode,
        'verify_code': verifyCode,
        'my_referral': myReferral,
        'referral': referral,
        'location': location,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateUser {
  const AggregateUser({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateUser.fromJson(Map json) => AggregateUser(
        $count: json['_count'] is Map
            ? _i2.UserCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.UserAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.UserSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.UserMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.UserMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.UserCountAggregateOutputType? $count;

  final _i2.UserAvgAggregateOutputType? $avg;

  final _i2.UserSumAggregateOutputType? $sum;

  final _i2.UserMinAggregateOutputType? $min;

  final _i2.UserMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateUserCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserCountArgs({this.select});

  final _i2.UserCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserAvgArgs({this.select});

  final _i2.UserAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserSumArgs({this.select});

  final _i2.UserSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserMinArgs({this.select});

  final _i2.UserMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserMaxArgs({this.select});

  final _i2.UserMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateUserCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateUserAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateUserSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateUserMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateUserMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class VendorWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.VendorWhereInput, Iterable<_i2.VendorWhereInput>>?
      AND;

  final Iterable<_i2.VendorWhereInput>? OR;

  final _i1.PrismaUnion<_i2.VendorWhereInput, Iterable<_i2.VendorWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? verifyEmail;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? verifyPhone;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? imagen;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? authToken;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class VendorWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorWhereUniqueInput({
    this.id,
    this.email,
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.lastname,
    this.phone,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final String? email;

  final _i1.PrismaUnion<_i2.VendorWhereInput, Iterable<_i2.VendorWhereInput>>?
      AND;

  final Iterable<_i2.VendorWhereInput>? OR;

  final _i1.PrismaUnion<_i2.VendorWhereInput, Iterable<_i2.VendorWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? verifyEmail;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? verifyPhone;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? imagen;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? authToken;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class VendorSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorSelect({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? lastname;

  final bool? phone;

  final bool? email;

  final bool? verifyEmail;

  final bool? verifyPhone;

  final bool? password;

  final bool? imagen;

  final bool? authToken;

  final bool? fcmToken;

  final bool? status;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class VendorOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorOrderByWithRelationInput({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? lastname;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? phone;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? email;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? verifyEmail;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? verifyPhone;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? password;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? imagen;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? authToken;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? fcmToken;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

enum VendorScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Vendor'),
  name$<String>('name', 'Vendor'),
  lastname<String>('lastname', 'Vendor'),
  phone<String>('phone', 'Vendor'),
  email<String>('email', 'Vendor'),
  verifyEmail<bool>('verify_email', 'Vendor'),
  verifyPhone<bool>('verify_phone', 'Vendor'),
  password<String>('password', 'Vendor'),
  imagen<String>('imagen', 'Vendor'),
  authToken<String>('auth_token', 'Vendor'),
  fcmToken<String>('fcm_token', 'Vendor'),
  status<bool>('status', 'Vendor'),
  createdAt<DateTime>('created_at', 'Vendor'),
  updatedAt<DateTime>('updated_at', 'Vendor');

  const VendorScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class VendorCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorCreateInput({
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? lastname;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? verifyEmail;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? verifyPhone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? imagen;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? authToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? fcmToken;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class VendorUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorUncheckedCreateInput({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? lastname;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? verifyEmail;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? verifyPhone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? imagen;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? authToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? fcmToken;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class VendorCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorCreateManyInput({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? lastname;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? verifyEmail;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? verifyPhone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? imagen;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? authToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? fcmToken;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class VendorUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorUpdateInput({
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? verifyEmail;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? verifyPhone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? imagen;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? authToken;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class VendorUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorUncheckedUpdateInput({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? verifyEmail;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? verifyPhone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? imagen;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? authToken;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class VendorUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorUpdateManyMutationInput({
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? verifyEmail;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? verifyPhone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? imagen;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? authToken;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class VendorUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorUncheckedUpdateManyInput({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? verifyEmail;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? verifyPhone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? imagen;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? authToken;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class VendorCountAggregateOutputType {
  const VendorCountAggregateOutputType({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory VendorCountAggregateOutputType.fromJson(Map json) =>
      VendorCountAggregateOutputType(
        id: json['id'],
        name: json['name'],
        lastname: json['lastname'],
        phone: json['phone'],
        email: json['email'],
        verifyEmail: json['verify_email'],
        verifyPhone: json['verify_phone'],
        password: json['password'],
        imagen: json['imagen'],
        authToken: json['auth_token'],
        fcmToken: json['fcm_token'],
        status: json['status'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? name;

  final int? lastname;

  final int? phone;

  final int? email;

  final int? verifyEmail;

  final int? verifyPhone;

  final int? password;

  final int? imagen;

  final int? authToken;

  final int? fcmToken;

  final int? status;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class VendorAvgAggregateOutputType {
  const VendorAvgAggregateOutputType({this.id});

  factory VendorAvgAggregateOutputType.fromJson(Map json) =>
      VendorAvgAggregateOutputType(id: json['id']);

  final double? id;

  Map<String, dynamic> toJson() => {'id': id};
}

class VendorSumAggregateOutputType {
  const VendorSumAggregateOutputType({this.id});

  factory VendorSumAggregateOutputType.fromJson(Map json) =>
      VendorSumAggregateOutputType(id: json['id']);

  final int? id;

  Map<String, dynamic> toJson() => {'id': id};
}

class VendorMinAggregateOutputType {
  const VendorMinAggregateOutputType({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  factory VendorMinAggregateOutputType.fromJson(Map json) =>
      VendorMinAggregateOutputType(
        id: json['id'],
        name: json['name'],
        lastname: json['lastname'],
        phone: json['phone'],
        email: json['email'],
        verifyEmail: json['verify_email'],
        verifyPhone: json['verify_phone'],
        password: json['password'],
        imagen: json['imagen'],
        authToken: json['auth_token'],
        fcmToken: json['fcm_token'],
        status: json['status'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final String? name;

  final String? lastname;

  final String? phone;

  final String? email;

  final bool? verifyEmail;

  final bool? verifyPhone;

  final String? password;

  final String? imagen;

  final String? authToken;

  final String? fcmToken;

  final bool? status;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class VendorMaxAggregateOutputType {
  const VendorMaxAggregateOutputType({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  factory VendorMaxAggregateOutputType.fromJson(Map json) =>
      VendorMaxAggregateOutputType(
        id: json['id'],
        name: json['name'],
        lastname: json['lastname'],
        phone: json['phone'],
        email: json['email'],
        verifyEmail: json['verify_email'],
        verifyPhone: json['verify_phone'],
        password: json['password'],
        imagen: json['imagen'],
        authToken: json['auth_token'],
        fcmToken: json['fcm_token'],
        status: json['status'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final String? name;

  final String? lastname;

  final String? phone;

  final String? email;

  final bool? verifyEmail;

  final bool? verifyPhone;

  final String? password;

  final String? imagen;

  final String? authToken;

  final String? fcmToken;

  final bool? status;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class VendorGroupByOutputType {
  const VendorGroupByOutputType({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory VendorGroupByOutputType.fromJson(Map json) => VendorGroupByOutputType(
        id: json['id'],
        name: json['name'],
        lastname: json['lastname'],
        phone: json['phone'],
        email: json['email'],
        verifyEmail: json['verify_email'],
        verifyPhone: json['verify_phone'],
        password: json['password'],
        imagen: json['imagen'],
        authToken: json['auth_token'],
        fcmToken: json['fcm_token'],
        status: json['status'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        $count: json['_count'] is Map
            ? _i2.VendorCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.VendorAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.VendorSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.VendorMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.VendorMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? name;

  final String? lastname;

  final String? phone;

  final String? email;

  final bool? verifyEmail;

  final bool? verifyPhone;

  final String? password;

  final String? imagen;

  final String? authToken;

  final String? fcmToken;

  final bool? status;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.VendorCountAggregateOutputType? $count;

  final _i2.VendorAvgAggregateOutputType? $avg;

  final _i2.VendorSumAggregateOutputType? $sum;

  final _i2.VendorMinAggregateOutputType? $min;

  final _i2.VendorMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class VendorCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorCountOrderByAggregateInput({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? lastname;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? email;

  final _i2.SortOrder? verifyEmail;

  final _i2.SortOrder? verifyPhone;

  final _i2.SortOrder? password;

  final _i2.SortOrder? imagen;

  final _i2.SortOrder? authToken;

  final _i2.SortOrder? fcmToken;

  final _i2.SortOrder? status;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class VendorAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorAvgOrderByAggregateInput({this.id});

  final _i2.SortOrder? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class VendorMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorMaxOrderByAggregateInput({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? lastname;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? email;

  final _i2.SortOrder? verifyEmail;

  final _i2.SortOrder? verifyPhone;

  final _i2.SortOrder? password;

  final _i2.SortOrder? imagen;

  final _i2.SortOrder? authToken;

  final _i2.SortOrder? fcmToken;

  final _i2.SortOrder? status;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class VendorMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorMinOrderByAggregateInput({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? lastname;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? email;

  final _i2.SortOrder? verifyEmail;

  final _i2.SortOrder? verifyPhone;

  final _i2.SortOrder? password;

  final _i2.SortOrder? imagen;

  final _i2.SortOrder? authToken;

  final _i2.SortOrder? fcmToken;

  final _i2.SortOrder? status;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class VendorSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorSumOrderByAggregateInput({this.id});

  final _i2.SortOrder? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class VendorOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorOrderByWithAggregationInput({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? lastname;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? phone;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? email;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? verifyEmail;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? verifyPhone;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? password;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? imagen;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? authToken;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? fcmToken;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i2.VendorCountOrderByAggregateInput? $count;

  final _i2.VendorAvgOrderByAggregateInput? $avg;

  final _i2.VendorMaxOrderByAggregateInput? $max;

  final _i2.VendorMinOrderByAggregateInput? $min;

  final _i2.VendorSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class VendorScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.VendorScalarWhereWithAggregatesInput,
      Iterable<_i2.VendorScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.VendorScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.VendorScalarWhereWithAggregatesInput,
      Iterable<_i2.VendorScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<_i2.BoolNullableWithAggregatesFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? verifyEmail;

  final _i1.PrismaUnion<_i2.BoolNullableWithAggregatesFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? verifyPhone;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? imagen;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? authToken;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<_i2.BoolNullableWithAggregatesFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class VendorCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorCountAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? name;

  final bool? lastname;

  final bool? phone;

  final bool? email;

  final bool? verifyEmail;

  final bool? verifyPhone;

  final bool? password;

  final bool? imagen;

  final bool? authToken;

  final bool? fcmToken;

  final bool? status;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class VendorGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorGroupByOutputTypeCountArgs({this.select});

  final _i2.VendorCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class VendorAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorAvgAggregateOutputTypeSelect({this.id});

  final bool? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class VendorGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorGroupByOutputTypeAvgArgs({this.select});

  final _i2.VendorAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class VendorSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorSumAggregateOutputTypeSelect({this.id});

  final bool? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class VendorGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorGroupByOutputTypeSumArgs({this.select});

  final _i2.VendorSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class VendorMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorMinAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? lastname;

  final bool? phone;

  final bool? email;

  final bool? verifyEmail;

  final bool? verifyPhone;

  final bool? password;

  final bool? imagen;

  final bool? authToken;

  final bool? fcmToken;

  final bool? status;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class VendorGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorGroupByOutputTypeMinArgs({this.select});

  final _i2.VendorMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class VendorMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorMaxAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? lastname;

  final bool? phone;

  final bool? email;

  final bool? verifyEmail;

  final bool? verifyPhone;

  final bool? password;

  final bool? imagen;

  final bool? authToken;

  final bool? fcmToken;

  final bool? status;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class VendorGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorGroupByOutputTypeMaxArgs({this.select});

  final _i2.VendorMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class VendorGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const VendorGroupByOutputTypeSelect({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.verifyEmail,
    this.verifyPhone,
    this.password,
    this.imagen,
    this.authToken,
    this.fcmToken,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? name;

  final bool? lastname;

  final bool? phone;

  final bool? email;

  final bool? verifyEmail;

  final bool? verifyPhone;

  final bool? password;

  final bool? imagen;

  final bool? authToken;

  final bool? fcmToken;

  final bool? status;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.VendorGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.VendorGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.VendorGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.VendorGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.VendorGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'verify_email': verifyEmail,
        'verify_phone': verifyPhone,
        'password': password,
        'imagen': imagen,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateVendor {
  const AggregateVendor({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateVendor.fromJson(Map json) => AggregateVendor(
        $count: json['_count'] is Map
            ? _i2.VendorCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.VendorAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.VendorSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.VendorMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.VendorMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.VendorCountAggregateOutputType? $count;

  final _i2.VendorAvgAggregateOutputType? $avg;

  final _i2.VendorSumAggregateOutputType? $sum;

  final _i2.VendorMinAggregateOutputType? $min;

  final _i2.VendorMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateVendorCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateVendorCountArgs({this.select});

  final _i2.VendorCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateVendorAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateVendorAvgArgs({this.select});

  final _i2.VendorAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateVendorSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateVendorSumArgs({this.select});

  final _i2.VendorSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateVendorMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateVendorMinArgs({this.select});

  final _i2.VendorMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateVendorMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateVendorMaxArgs({this.select});

  final _i2.VendorMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateVendorSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateVendorSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateVendorCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateVendorAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateVendorSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateVendorMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateVendorMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class EmployeeWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  final _i1
      .PrismaUnion<_i2.EmployeeWhereInput, Iterable<_i2.EmployeeWhereInput>>?
      AND;

  final Iterable<_i2.EmployeeWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.EmployeeWhereInput, Iterable<_i2.EmployeeWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? image;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      vendorId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      storeId;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? authToken;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? isLoggedIn;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
      };
}

class EmployeeWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeWhereUniqueInput({
    this.id,
    this.email,
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.lastname,
    this.phone,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  final int? id;

  final String? email;

  final _i1
      .PrismaUnion<_i2.EmployeeWhereInput, Iterable<_i2.EmployeeWhereInput>>?
      AND;

  final Iterable<_i2.EmployeeWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.EmployeeWhereInput, Iterable<_i2.EmployeeWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? image;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      vendorId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      storeId;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? authToken;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? isLoggedIn;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
      };
}

class EmployeeSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeSelect({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  final bool? id;

  final bool? name;

  final bool? lastname;

  final bool? phone;

  final bool? email;

  final bool? password;

  final bool? image;

  final bool? vendorId;

  final bool? storeId;

  final bool? status;

  final bool? authToken;

  final bool? fcmToken;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? isLoggedIn;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
      };
}

class EmployeeOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeOrderByWithRelationInput({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? lastname;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? phone;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? email;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? password;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? image;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? vendorId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? storeId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? authToken;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? fcmToken;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? isLoggedIn;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
      };
}

enum EmployeeScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Employee'),
  name$<String>('name', 'Employee'),
  lastname<String>('lastname', 'Employee'),
  phone<String>('phone', 'Employee'),
  email<String>('email', 'Employee'),
  password<String>('password', 'Employee'),
  image<String>('image', 'Employee'),
  vendorId<int>('vendor_id', 'Employee'),
  storeId<int>('store_id', 'Employee'),
  status<bool>('status', 'Employee'),
  authToken<String>('auth_token', 'Employee'),
  fcmToken<String>('fcm_token', 'Employee'),
  createdAt<DateTime>('created_at', 'Employee'),
  updatedAt<DateTime>('updated_at', 'Employee'),
  isLoggedIn<bool>('is_logged_in', 'Employee');

  const EmployeeScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class EmployeeCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeCreateInput({
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? lastname;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? vendorId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? storeId;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? authToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? fcmToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? isLoggedIn;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
      };
}

class EmployeeUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeUncheckedCreateInput({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? lastname;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? vendorId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? storeId;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? authToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? fcmToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? isLoggedIn;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
      };
}

class EmployeeCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeCreateManyInput({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? lastname;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? phone;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? email;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? password;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? image;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? vendorId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? storeId;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? authToken;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? fcmToken;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? isLoggedIn;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
      };
}

class EmployeeUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeUpdateInput({
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? image;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? storeId;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? authToken;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? isLoggedIn;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
      };
}

class EmployeeUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeUncheckedUpdateInput({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? image;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? storeId;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? authToken;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? isLoggedIn;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
      };
}

class EmployeeUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeUpdateManyMutationInput({
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? image;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? storeId;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? authToken;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? isLoggedIn;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
      };
}

class EmployeeUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeUncheckedUpdateManyInput({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? image;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? storeId;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? authToken;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? isLoggedIn;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
      };
}

class EmployeeCountAggregateOutputType {
  const EmployeeCountAggregateOutputType({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
    this.$all,
  });

  factory EmployeeCountAggregateOutputType.fromJson(Map json) =>
      EmployeeCountAggregateOutputType(
        id: json['id'],
        name: json['name'],
        lastname: json['lastname'],
        phone: json['phone'],
        email: json['email'],
        password: json['password'],
        image: json['image'],
        vendorId: json['vendor_id'],
        storeId: json['store_id'],
        status: json['status'],
        authToken: json['auth_token'],
        fcmToken: json['fcm_token'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        isLoggedIn: json['is_logged_in'],
        $all: json['_all'],
      );

  final int? id;

  final int? name;

  final int? lastname;

  final int? phone;

  final int? email;

  final int? password;

  final int? image;

  final int? vendorId;

  final int? storeId;

  final int? status;

  final int? authToken;

  final int? fcmToken;

  final int? createdAt;

  final int? updatedAt;

  final int? isLoggedIn;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
        '_all': $all,
      };
}

class EmployeeAvgAggregateOutputType {
  const EmployeeAvgAggregateOutputType({
    this.id,
    this.vendorId,
    this.storeId,
  });

  factory EmployeeAvgAggregateOutputType.fromJson(Map json) =>
      EmployeeAvgAggregateOutputType(
        id: json['id'],
        vendorId: json['vendor_id'],
        storeId: json['store_id'],
      );

  final double? id;

  final double? vendorId;

  final double? storeId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
      };
}

class EmployeeSumAggregateOutputType {
  const EmployeeSumAggregateOutputType({
    this.id,
    this.vendorId,
    this.storeId,
  });

  factory EmployeeSumAggregateOutputType.fromJson(Map json) =>
      EmployeeSumAggregateOutputType(
        id: json['id'],
        vendorId: json['vendor_id'],
        storeId: json['store_id'],
      );

  final int? id;

  final int? vendorId;

  final int? storeId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
      };
}

class EmployeeMinAggregateOutputType {
  const EmployeeMinAggregateOutputType({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  factory EmployeeMinAggregateOutputType.fromJson(Map json) =>
      EmployeeMinAggregateOutputType(
        id: json['id'],
        name: json['name'],
        lastname: json['lastname'],
        phone: json['phone'],
        email: json['email'],
        password: json['password'],
        image: json['image'],
        vendorId: json['vendor_id'],
        storeId: json['store_id'],
        status: json['status'],
        authToken: json['auth_token'],
        fcmToken: json['fcm_token'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        isLoggedIn: json['is_logged_in'],
      );

  final int? id;

  final String? name;

  final String? lastname;

  final String? phone;

  final String? email;

  final String? password;

  final String? image;

  final int? vendorId;

  final int? storeId;

  final bool? status;

  final String? authToken;

  final String? fcmToken;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final bool? isLoggedIn;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        'is_logged_in': isLoggedIn,
      };
}

class EmployeeMaxAggregateOutputType {
  const EmployeeMaxAggregateOutputType({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  factory EmployeeMaxAggregateOutputType.fromJson(Map json) =>
      EmployeeMaxAggregateOutputType(
        id: json['id'],
        name: json['name'],
        lastname: json['lastname'],
        phone: json['phone'],
        email: json['email'],
        password: json['password'],
        image: json['image'],
        vendorId: json['vendor_id'],
        storeId: json['store_id'],
        status: json['status'],
        authToken: json['auth_token'],
        fcmToken: json['fcm_token'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        isLoggedIn: json['is_logged_in'],
      );

  final int? id;

  final String? name;

  final String? lastname;

  final String? phone;

  final String? email;

  final String? password;

  final String? image;

  final int? vendorId;

  final int? storeId;

  final bool? status;

  final String? authToken;

  final String? fcmToken;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final bool? isLoggedIn;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        'is_logged_in': isLoggedIn,
      };
}

class EmployeeGroupByOutputType {
  const EmployeeGroupByOutputType({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory EmployeeGroupByOutputType.fromJson(Map json) =>
      EmployeeGroupByOutputType(
        id: json['id'],
        name: json['name'],
        lastname: json['lastname'],
        phone: json['phone'],
        email: json['email'],
        password: json['password'],
        image: json['image'],
        vendorId: json['vendor_id'],
        storeId: json['store_id'],
        status: json['status'],
        authToken: json['auth_token'],
        fcmToken: json['fcm_token'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        isLoggedIn: json['is_logged_in'],
        $count: json['_count'] is Map
            ? _i2.EmployeeCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.EmployeeAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.EmployeeSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.EmployeeMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.EmployeeMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? name;

  final String? lastname;

  final String? phone;

  final String? email;

  final String? password;

  final String? image;

  final int? vendorId;

  final int? storeId;

  final bool? status;

  final String? authToken;

  final String? fcmToken;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final bool? isLoggedIn;

  final _i2.EmployeeCountAggregateOutputType? $count;

  final _i2.EmployeeAvgAggregateOutputType? $avg;

  final _i2.EmployeeSumAggregateOutputType? $sum;

  final _i2.EmployeeMinAggregateOutputType? $min;

  final _i2.EmployeeMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        'is_logged_in': isLoggedIn,
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class EmployeeCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeCountOrderByAggregateInput({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? lastname;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? email;

  final _i2.SortOrder? password;

  final _i2.SortOrder? image;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? storeId;

  final _i2.SortOrder? status;

  final _i2.SortOrder? authToken;

  final _i2.SortOrder? fcmToken;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SortOrder? isLoggedIn;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
      };
}

class EmployeeAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeAvgOrderByAggregateInput({
    this.id,
    this.vendorId,
    this.storeId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? storeId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
      };
}

class EmployeeMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeMaxOrderByAggregateInput({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? lastname;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? email;

  final _i2.SortOrder? password;

  final _i2.SortOrder? image;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? storeId;

  final _i2.SortOrder? status;

  final _i2.SortOrder? authToken;

  final _i2.SortOrder? fcmToken;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SortOrder? isLoggedIn;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
      };
}

class EmployeeMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeMinOrderByAggregateInput({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? lastname;

  final _i2.SortOrder? phone;

  final _i2.SortOrder? email;

  final _i2.SortOrder? password;

  final _i2.SortOrder? image;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? storeId;

  final _i2.SortOrder? status;

  final _i2.SortOrder? authToken;

  final _i2.SortOrder? fcmToken;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SortOrder? isLoggedIn;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
      };
}

class EmployeeSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeSumOrderByAggregateInput({
    this.id,
    this.vendorId,
    this.storeId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? storeId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
      };
}

class EmployeeOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeOrderByWithAggregationInput({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? lastname;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? phone;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? email;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? password;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? image;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? vendorId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? storeId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? authToken;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? fcmToken;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? isLoggedIn;

  final _i2.EmployeeCountOrderByAggregateInput? $count;

  final _i2.EmployeeAvgOrderByAggregateInput? $avg;

  final _i2.EmployeeMaxOrderByAggregateInput? $max;

  final _i2.EmployeeMinOrderByAggregateInput? $min;

  final _i2.EmployeeSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class EmployeeScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  final _i1.PrismaUnion<_i2.EmployeeScalarWhereWithAggregatesInput,
      Iterable<_i2.EmployeeScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.EmployeeScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.EmployeeScalarWhereWithAggregatesInput,
      Iterable<_i2.EmployeeScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? lastname;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? phone;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? email;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? password;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? image;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? storeId;

  final _i1.PrismaUnion<_i2.BoolNullableWithAggregatesFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? authToken;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? fcmToken;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<_i2.BoolNullableWithAggregatesFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? isLoggedIn;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
      };
}

class EmployeeCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeCountAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
    this.$all,
  });

  final bool? id;

  final bool? name;

  final bool? lastname;

  final bool? phone;

  final bool? email;

  final bool? password;

  final bool? image;

  final bool? vendorId;

  final bool? storeId;

  final bool? status;

  final bool? authToken;

  final bool? fcmToken;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? isLoggedIn;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
        '_all': $all,
      };
}

class EmployeeGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeGroupByOutputTypeCountArgs({this.select});

  final _i2.EmployeeCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class EmployeeAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeAvgAggregateOutputTypeSelect({
    this.id,
    this.vendorId,
    this.storeId,
  });

  final bool? id;

  final bool? vendorId;

  final bool? storeId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
      };
}

class EmployeeGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeGroupByOutputTypeAvgArgs({this.select});

  final _i2.EmployeeAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class EmployeeSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeSumAggregateOutputTypeSelect({
    this.id,
    this.vendorId,
    this.storeId,
  });

  final bool? id;

  final bool? vendorId;

  final bool? storeId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
      };
}

class EmployeeGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeGroupByOutputTypeSumArgs({this.select});

  final _i2.EmployeeSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class EmployeeMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeMinAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  final bool? id;

  final bool? name;

  final bool? lastname;

  final bool? phone;

  final bool? email;

  final bool? password;

  final bool? image;

  final bool? vendorId;

  final bool? storeId;

  final bool? status;

  final bool? authToken;

  final bool? fcmToken;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? isLoggedIn;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
      };
}

class EmployeeGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeGroupByOutputTypeMinArgs({this.select});

  final _i2.EmployeeMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class EmployeeMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeMaxAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
  });

  final bool? id;

  final bool? name;

  final bool? lastname;

  final bool? phone;

  final bool? email;

  final bool? password;

  final bool? image;

  final bool? vendorId;

  final bool? storeId;

  final bool? status;

  final bool? authToken;

  final bool? fcmToken;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? isLoggedIn;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
      };
}

class EmployeeGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeGroupByOutputTypeMaxArgs({this.select});

  final _i2.EmployeeMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class EmployeeGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const EmployeeGroupByOutputTypeSelect({
    this.id,
    this.name,
    this.lastname,
    this.phone,
    this.email,
    this.password,
    this.image,
    this.vendorId,
    this.storeId,
    this.status,
    this.authToken,
    this.fcmToken,
    this.createdAt,
    this.updatedAt,
    this.isLoggedIn,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? name;

  final bool? lastname;

  final bool? phone;

  final bool? email;

  final bool? password;

  final bool? image;

  final bool? vendorId;

  final bool? storeId;

  final bool? status;

  final bool? authToken;

  final bool? fcmToken;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? isLoggedIn;

  final _i1.PrismaUnion<bool, _i2.EmployeeGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.EmployeeGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.EmployeeGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.EmployeeGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.EmployeeGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'lastname': lastname,
        'phone': phone,
        'email': email,
        'password': password,
        'image': image,
        'vendor_id': vendorId,
        'store_id': storeId,
        'status': status,
        'auth_token': authToken,
        'fcm_token': fcmToken,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_logged_in': isLoggedIn,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateEmployee {
  const AggregateEmployee({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateEmployee.fromJson(Map json) => AggregateEmployee(
        $count: json['_count'] is Map
            ? _i2.EmployeeCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.EmployeeAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.EmployeeSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.EmployeeMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.EmployeeMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.EmployeeCountAggregateOutputType? $count;

  final _i2.EmployeeAvgAggregateOutputType? $avg;

  final _i2.EmployeeSumAggregateOutputType? $sum;

  final _i2.EmployeeMinAggregateOutputType? $min;

  final _i2.EmployeeMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateEmployeeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateEmployeeCountArgs({this.select});

  final _i2.EmployeeCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateEmployeeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateEmployeeAvgArgs({this.select});

  final _i2.EmployeeAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateEmployeeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateEmployeeSumArgs({this.select});

  final _i2.EmployeeSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateEmployeeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateEmployeeMinArgs({this.select});

  final _i2.EmployeeMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateEmployeeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateEmployeeMaxArgs({this.select});

  final _i2.EmployeeMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateEmployeeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateEmployeeSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateEmployeeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateEmployeeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateEmployeeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateEmployeeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateEmployeeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class UseraddressWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  final _i1.PrismaUnion<_i2.UseraddressWhereInput,
      Iterable<_i2.UseraddressWhereInput>>? AND;

  final Iterable<_i2.UseraddressWhereInput>? OR;

  final _i1.PrismaUnion<_i2.UseraddressWhereInput,
      Iterable<_i2.UseraddressWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? title;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      userId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? address;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? deleteAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? active;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

class UseraddressWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.UseraddressWhereInput,
      Iterable<_i2.UseraddressWhereInput>>? AND;

  final Iterable<_i2.UseraddressWhereInput>? OR;

  final _i1.PrismaUnion<_i2.UseraddressWhereInput,
      Iterable<_i2.UseraddressWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? title;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      userId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? address;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? deleteAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? active;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

class UseraddressSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressSelect({
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  final bool? id;

  final bool? title;

  final bool? userId;

  final bool? address;

  final bool? location;

  final bool? deleteAt;

  final bool? createAt;

  final bool? updateAt;

  final bool? active;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

class UseraddressOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressOrderByWithRelationInput({
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? title;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? userId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? address;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? location;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? deleteAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updateAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? active;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

enum UseraddressScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Useraddress'),
  title<String>('title', 'Useraddress'),
  userId<int>('user_id', 'Useraddress'),
  address<String>('address', 'Useraddress'),
  location<String>('location', 'Useraddress'),
  deleteAt<String>('delete_at', 'Useraddress'),
  createAt<String>('create_at', 'Useraddress'),
  updateAt<String>('update_at', 'Useraddress'),
  active<String>('active', 'Useraddress');

  const UseraddressScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class UseraddressCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressCreateInput({
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? title;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? location;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? deleteAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? createAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? updateAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? active;

  @override
  Map<String, dynamic> toJson() => {
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

class UseraddressUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressUncheckedCreateInput({
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? title;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? location;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? deleteAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? createAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? updateAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? active;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

class UseraddressCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressCreateManyInput({
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? title;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? address;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? location;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? deleteAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? createAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? updateAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? active;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

class UseraddressUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressUpdateInput({
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? address;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? active;

  @override
  Map<String, dynamic> toJson() => {
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

class UseraddressUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressUncheckedUpdateInput({
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? address;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? active;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

class UseraddressUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressUpdateManyMutationInput({
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? address;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? active;

  @override
  Map<String, dynamic> toJson() => {
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

class UseraddressUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressUncheckedUpdateManyInput({
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? address;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? active;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

class UseraddressCountAggregateOutputType {
  const UseraddressCountAggregateOutputType({
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
    this.$all,
  });

  factory UseraddressCountAggregateOutputType.fromJson(Map json) =>
      UseraddressCountAggregateOutputType(
        id: json['id'],
        title: json['title'],
        userId: json['user_id'],
        address: json['address'],
        location: json['location'],
        deleteAt: json['delete_at'],
        createAt: json['create_at'],
        updateAt: json['update_at'],
        active: json['active'],
        $all: json['_all'],
      );

  final int? id;

  final int? title;

  final int? userId;

  final int? address;

  final int? location;

  final int? deleteAt;

  final int? createAt;

  final int? updateAt;

  final int? active;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
        '_all': $all,
      };
}

class UseraddressAvgAggregateOutputType {
  const UseraddressAvgAggregateOutputType({
    this.id,
    this.userId,
  });

  factory UseraddressAvgAggregateOutputType.fromJson(Map json) =>
      UseraddressAvgAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
      );

  final double? id;

  final double? userId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
      };
}

class UseraddressSumAggregateOutputType {
  const UseraddressSumAggregateOutputType({
    this.id,
    this.userId,
  });

  factory UseraddressSumAggregateOutputType.fromJson(Map json) =>
      UseraddressSumAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
      );

  final int? id;

  final int? userId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
      };
}

class UseraddressMinAggregateOutputType {
  const UseraddressMinAggregateOutputType({
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  factory UseraddressMinAggregateOutputType.fromJson(Map json) =>
      UseraddressMinAggregateOutputType(
        id: json['id'],
        title: json['title'],
        userId: json['user_id'],
        address: json['address'],
        location: json['location'],
        deleteAt: json['delete_at'],
        createAt: json['create_at'],
        updateAt: json['update_at'],
        active: json['active'],
      );

  final int? id;

  final String? title;

  final int? userId;

  final String? address;

  final String? location;

  final String? deleteAt;

  final String? createAt;

  final String? updateAt;

  final String? active;

  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

class UseraddressMaxAggregateOutputType {
  const UseraddressMaxAggregateOutputType({
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  factory UseraddressMaxAggregateOutputType.fromJson(Map json) =>
      UseraddressMaxAggregateOutputType(
        id: json['id'],
        title: json['title'],
        userId: json['user_id'],
        address: json['address'],
        location: json['location'],
        deleteAt: json['delete_at'],
        createAt: json['create_at'],
        updateAt: json['update_at'],
        active: json['active'],
      );

  final int? id;

  final String? title;

  final int? userId;

  final String? address;

  final String? location;

  final String? deleteAt;

  final String? createAt;

  final String? updateAt;

  final String? active;

  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

class UseraddressGroupByOutputType {
  const UseraddressGroupByOutputType({
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory UseraddressGroupByOutputType.fromJson(Map json) =>
      UseraddressGroupByOutputType(
        id: json['id'],
        title: json['title'],
        userId: json['user_id'],
        address: json['address'],
        location: json['location'],
        deleteAt: json['delete_at'],
        createAt: json['create_at'],
        updateAt: json['update_at'],
        active: json['active'],
        $count: json['_count'] is Map
            ? _i2.UseraddressCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.UseraddressAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.UseraddressSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.UseraddressMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.UseraddressMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? title;

  final int? userId;

  final String? address;

  final String? location;

  final String? deleteAt;

  final String? createAt;

  final String? updateAt;

  final String? active;

  final _i2.UseraddressCountAggregateOutputType? $count;

  final _i2.UseraddressAvgAggregateOutputType? $avg;

  final _i2.UseraddressSumAggregateOutputType? $sum;

  final _i2.UseraddressMinAggregateOutputType? $min;

  final _i2.UseraddressMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class UseraddressCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressCountOrderByAggregateInput({
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? address;

  final _i2.SortOrder? location;

  final _i2.SortOrder? deleteAt;

  final _i2.SortOrder? createAt;

  final _i2.SortOrder? updateAt;

  final _i2.SortOrder? active;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

class UseraddressAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressAvgOrderByAggregateInput({
    this.id,
    this.userId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
      };
}

class UseraddressMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressMaxOrderByAggregateInput({
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? address;

  final _i2.SortOrder? location;

  final _i2.SortOrder? deleteAt;

  final _i2.SortOrder? createAt;

  final _i2.SortOrder? updateAt;

  final _i2.SortOrder? active;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

class UseraddressMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressMinOrderByAggregateInput({
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? title;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? address;

  final _i2.SortOrder? location;

  final _i2.SortOrder? deleteAt;

  final _i2.SortOrder? createAt;

  final _i2.SortOrder? updateAt;

  final _i2.SortOrder? active;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

class UseraddressSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressSumOrderByAggregateInput({
    this.id,
    this.userId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
      };
}

class UseraddressOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressOrderByWithAggregationInput({
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? title;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? userId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? address;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? location;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? deleteAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updateAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? active;

  final _i2.UseraddressCountOrderByAggregateInput? $count;

  final _i2.UseraddressAvgOrderByAggregateInput? $avg;

  final _i2.UseraddressMaxOrderByAggregateInput? $max;

  final _i2.UseraddressMinOrderByAggregateInput? $min;

  final _i2.UseraddressSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class UseraddressScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  final _i1.PrismaUnion<_i2.UseraddressScalarWhereWithAggregatesInput,
      Iterable<_i2.UseraddressScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.UseraddressScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.UseraddressScalarWhereWithAggregatesInput,
      Iterable<_i2.UseraddressScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? address;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? location;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? deleteAt;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? active;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

class UseraddressCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressCountAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
    this.$all,
  });

  final bool? id;

  final bool? title;

  final bool? userId;

  final bool? address;

  final bool? location;

  final bool? deleteAt;

  final bool? createAt;

  final bool? updateAt;

  final bool? active;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
        '_all': $all,
      };
}

class UseraddressGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressGroupByOutputTypeCountArgs({this.select});

  final _i2.UseraddressCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UseraddressAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressAvgAggregateOutputTypeSelect({
    this.id,
    this.userId,
  });

  final bool? id;

  final bool? userId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
      };
}

class UseraddressGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressGroupByOutputTypeAvgArgs({this.select});

  final _i2.UseraddressAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UseraddressSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressSumAggregateOutputTypeSelect({
    this.id,
    this.userId,
  });

  final bool? id;

  final bool? userId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
      };
}

class UseraddressGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressGroupByOutputTypeSumArgs({this.select});

  final _i2.UseraddressSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UseraddressMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressMinAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  final bool? id;

  final bool? title;

  final bool? userId;

  final bool? address;

  final bool? location;

  final bool? deleteAt;

  final bool? createAt;

  final bool? updateAt;

  final bool? active;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

class UseraddressGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressGroupByOutputTypeMinArgs({this.select});

  final _i2.UseraddressMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UseraddressMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressMaxAggregateOutputTypeSelect({
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
  });

  final bool? id;

  final bool? title;

  final bool? userId;

  final bool? address;

  final bool? location;

  final bool? deleteAt;

  final bool? createAt;

  final bool? updateAt;

  final bool? active;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
      };
}

class UseraddressGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressGroupByOutputTypeMaxArgs({this.select});

  final _i2.UseraddressMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UseraddressGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UseraddressGroupByOutputTypeSelect({
    this.id,
    this.title,
    this.userId,
    this.address,
    this.location,
    this.deleteAt,
    this.createAt,
    this.updateAt,
    this.active,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? title;

  final bool? userId;

  final bool? address;

  final bool? location;

  final bool? deleteAt;

  final bool? createAt;

  final bool? updateAt;

  final bool? active;

  final _i1.PrismaUnion<bool, _i2.UseraddressGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.UseraddressGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.UseraddressGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.UseraddressGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.UseraddressGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'title': title,
        'user_id': userId,
        'address': address,
        'location': location,
        'delete_at': deleteAt,
        'create_at': createAt,
        'update_at': updateAt,
        'active': active,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateUseraddress {
  const AggregateUseraddress({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateUseraddress.fromJson(Map json) => AggregateUseraddress(
        $count: json['_count'] is Map
            ? _i2.UseraddressCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.UseraddressAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.UseraddressSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.UseraddressMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.UseraddressMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.UseraddressCountAggregateOutputType? $count;

  final _i2.UseraddressAvgAggregateOutputType? $avg;

  final _i2.UseraddressSumAggregateOutputType? $sum;

  final _i2.UseraddressMinAggregateOutputType? $min;

  final _i2.UseraddressMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateUseraddressCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUseraddressCountArgs({this.select});

  final _i2.UseraddressCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUseraddressAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUseraddressAvgArgs({this.select});

  final _i2.UseraddressAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUseraddressSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUseraddressSumArgs({this.select});

  final _i2.UseraddressSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUseraddressMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUseraddressMinArgs({this.select});

  final _i2.UseraddressMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUseraddressMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUseraddressMaxArgs({this.select});

  final _i2.UseraddressMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUseraddressSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUseraddressSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateUseraddressCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateUseraddressAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateUseraddressSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateUseraddressMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateUseraddressMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class UserpointWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
  });

  final _i1
      .PrismaUnion<_i2.UserpointWhereInput, Iterable<_i2.UserpointWhereInput>>?
      AND;

  final Iterable<_i2.UserpointWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.UserpointWhereInput, Iterable<_i2.UserpointWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      userId;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

class UserpointWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.userId,
    this.price,
    this.deleteAt,
  });

  final int? id;

  final _i1
      .PrismaUnion<_i2.UserpointWhereInput, Iterable<_i2.UserpointWhereInput>>?
      AND;

  final Iterable<_i2.UserpointWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.UserpointWhereInput, Iterable<_i2.UserpointWhereInput>>?
      NOT;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      userId;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

class UserpointSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointSelect({
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
  });

  final bool? id;

  final bool? userId;

  final bool? price;

  final bool? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

class UserpointOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointOrderByWithRelationInput({
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? userId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? price;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

enum UserpointScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Userpoint'),
  userId<int>('user_id', 'Userpoint'),
  price<_i1.Decimal>('price', 'Userpoint'),
  deleteAt<String>('delete_at', 'Userpoint');

  const UserpointScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class UserpointCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointCreateInput({
    this.userId,
    this.price,
    this.deleteAt,
  });

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userId;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? price;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

class UserpointUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointUncheckedCreateInput({
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
  });

  final int? id;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userId;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? price;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

class UserpointCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointCreateManyInput({
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
  });

  final int? id;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userId;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? price;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

class UserpointUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointUpdateInput({
    this.userId,
    this.price,
    this.deleteAt,
  });

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

class UserpointUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointUncheckedUpdateInput({
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

class UserpointUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointUpdateManyMutationInput({
    this.userId,
    this.price,
    this.deleteAt,
  });

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

class UserpointUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointUncheckedUpdateManyInput({
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

class UserpointCountAggregateOutputType {
  const UserpointCountAggregateOutputType({
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
    this.$all,
  });

  factory UserpointCountAggregateOutputType.fromJson(Map json) =>
      UserpointCountAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        price: json['price'],
        deleteAt: json['delete_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? userId;

  final int? price;

  final int? deleteAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
        '_all': $all,
      };
}

class UserpointAvgAggregateOutputType {
  const UserpointAvgAggregateOutputType({
    this.id,
    this.userId,
    this.price,
  });

  factory UserpointAvgAggregateOutputType.fromJson(Map json) =>
      UserpointAvgAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        price: json['price'],
      );

  final double? id;

  final double? userId;

  final _i1.Decimal? price;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
      };
}

class UserpointSumAggregateOutputType {
  const UserpointSumAggregateOutputType({
    this.id,
    this.userId,
    this.price,
  });

  factory UserpointSumAggregateOutputType.fromJson(Map json) =>
      UserpointSumAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        price: json['price'],
      );

  final int? id;

  final int? userId;

  final _i1.Decimal? price;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
      };
}

class UserpointMinAggregateOutputType {
  const UserpointMinAggregateOutputType({
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
  });

  factory UserpointMinAggregateOutputType.fromJson(Map json) =>
      UserpointMinAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        price: json['price'],
        deleteAt: json['delete_at'],
      );

  final int? id;

  final int? userId;

  final _i1.Decimal? price;

  final String? deleteAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

class UserpointMaxAggregateOutputType {
  const UserpointMaxAggregateOutputType({
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
  });

  factory UserpointMaxAggregateOutputType.fromJson(Map json) =>
      UserpointMaxAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        price: json['price'],
        deleteAt: json['delete_at'],
      );

  final int? id;

  final int? userId;

  final _i1.Decimal? price;

  final String? deleteAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

class UserpointGroupByOutputType {
  const UserpointGroupByOutputType({
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory UserpointGroupByOutputType.fromJson(Map json) =>
      UserpointGroupByOutputType(
        id: json['id'],
        userId: json['user_id'],
        price: json['price'],
        deleteAt: json['delete_at'],
        $count: json['_count'] is Map
            ? _i2.UserpointCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.UserpointAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.UserpointSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.UserpointMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.UserpointMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final int? userId;

  final _i1.Decimal? price;

  final String? deleteAt;

  final _i2.UserpointCountAggregateOutputType? $count;

  final _i2.UserpointAvgAggregateOutputType? $avg;

  final _i2.UserpointSumAggregateOutputType? $sum;

  final _i2.UserpointMinAggregateOutputType? $min;

  final _i2.UserpointMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class UserpointCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointCountOrderByAggregateInput({
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? price;

  final _i2.SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

class UserpointAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointAvgOrderByAggregateInput({
    this.id,
    this.userId,
    this.price,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? price;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
      };
}

class UserpointMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointMaxOrderByAggregateInput({
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? price;

  final _i2.SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

class UserpointMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointMinOrderByAggregateInput({
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? price;

  final _i2.SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

class UserpointSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointSumOrderByAggregateInput({
    this.id,
    this.userId,
    this.price,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? price;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
      };
}

class UserpointOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointOrderByWithAggregationInput({
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? userId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? price;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? deleteAt;

  final _i2.UserpointCountOrderByAggregateInput? $count;

  final _i2.UserpointAvgOrderByAggregateInput? $avg;

  final _i2.UserpointMaxOrderByAggregateInput? $max;

  final _i2.UserpointMinOrderByAggregateInput? $min;

  final _i2.UserpointSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class UserpointScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
  });

  final _i1.PrismaUnion<_i2.UserpointScalarWhereWithAggregatesInput,
      Iterable<_i2.UserpointScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.UserpointScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.UserpointScalarWhereWithAggregatesInput,
      Iterable<_i2.UserpointScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<_i2.DecimalNullableWithAggregatesFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

class UserpointCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointCountAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
    this.$all,
  });

  final bool? id;

  final bool? userId;

  final bool? price;

  final bool? deleteAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
        '_all': $all,
      };
}

class UserpointGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointGroupByOutputTypeCountArgs({this.select});

  final _i2.UserpointCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserpointAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointAvgAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.price,
  });

  final bool? id;

  final bool? userId;

  final bool? price;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
      };
}

class UserpointGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointGroupByOutputTypeAvgArgs({this.select});

  final _i2.UserpointAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserpointSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointSumAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.price,
  });

  final bool? id;

  final bool? userId;

  final bool? price;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
      };
}

class UserpointGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointGroupByOutputTypeSumArgs({this.select});

  final _i2.UserpointSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserpointMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointMinAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
  });

  final bool? id;

  final bool? userId;

  final bool? price;

  final bool? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

class UserpointGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointGroupByOutputTypeMinArgs({this.select});

  final _i2.UserpointMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserpointMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointMaxAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
  });

  final bool? id;

  final bool? userId;

  final bool? price;

  final bool? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
      };
}

class UserpointGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointGroupByOutputTypeMaxArgs({this.select});

  final _i2.UserpointMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserpointGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserpointGroupByOutputTypeSelect({
    this.id,
    this.userId,
    this.price,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? userId;

  final bool? price;

  final bool? deleteAt;

  final _i1.PrismaUnion<bool, _i2.UserpointGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.UserpointGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.UserpointGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.UserpointGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.UserpointGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
        'delete_at': deleteAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateUserpoint {
  const AggregateUserpoint({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateUserpoint.fromJson(Map json) => AggregateUserpoint(
        $count: json['_count'] is Map
            ? _i2.UserpointCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.UserpointAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.UserpointSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.UserpointMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.UserpointMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.UserpointCountAggregateOutputType? $count;

  final _i2.UserpointAvgAggregateOutputType? $avg;

  final _i2.UserpointSumAggregateOutputType? $sum;

  final _i2.UserpointMinAggregateOutputType? $min;

  final _i2.UserpointMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateUserpointCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserpointCountArgs({this.select});

  final _i2.UserpointCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserpointAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserpointAvgArgs({this.select});

  final _i2.UserpointAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserpointSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserpointSumArgs({this.select});

  final _i2.UserpointSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserpointMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserpointMinArgs({this.select});

  final _i2.UserpointMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserpointMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserpointMaxArgs({this.select});

  final _i2.UserpointMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserpointSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserpointSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateUserpointCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateUserpointAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateUserpointSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateUserpointMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateUserpointMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class WalletWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<_i2.WalletWhereInput, Iterable<_i2.WalletWhereInput>>?
      AND;

  final Iterable<_i2.WalletWhereInput>? OR;

  final _i1.PrismaUnion<_i2.WalletWhereInput, Iterable<_i2.WalletWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? uuid;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      userId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? currencyId;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WalletWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.WalletWhereInput, Iterable<_i2.WalletWhereInput>>?
      AND;

  final Iterable<_i2.WalletWhereInput>? OR;

  final _i1.PrismaUnion<_i2.WalletWhereInput, Iterable<_i2.WalletWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? uuid;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      userId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? currencyId;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WalletSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletSelect({
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final bool? id;

  final bool? uuid;

  final bool? userId;

  final bool? currencyId;

  final bool? price;

  final bool? createAt;

  final bool? updateAt;

  final bool? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WalletOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletOrderByWithRelationInput({
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? userId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? currencyId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? price;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updateAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

enum WalletScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Wallet'),
  uuid<String>('uuid', 'Wallet'),
  userId<int>('user_id', 'Wallet'),
  currencyId<String>('currency_id', 'Wallet'),
  price<_i1.Decimal>('price', 'Wallet'),
  createAt<String>('create_at', 'Wallet'),
  updateAt<String>('update_at', 'Wallet'),
  deleteAt<String>('delete_at', 'Wallet');

  const WalletScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class WalletCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletCreateInput({
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? uuid;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currencyId;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? price;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? createAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? updateAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WalletUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletUncheckedCreateInput({
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? uuid;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currencyId;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? price;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? createAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? updateAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WalletCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletCreateManyInput({
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? uuid;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currencyId;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? price;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? createAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? updateAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WalletUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletUpdateInput({
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? currencyId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WalletUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletUncheckedUpdateInput({
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? currencyId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WalletUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletUpdateManyMutationInput({
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? currencyId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WalletUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletUncheckedUpdateManyInput({
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? currencyId;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WalletCountAggregateOutputType {
  const WalletCountAggregateOutputType({
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
    this.$all,
  });

  factory WalletCountAggregateOutputType.fromJson(Map json) =>
      WalletCountAggregateOutputType(
        id: json['id'],
        uuid: json['uuid'],
        userId: json['user_id'],
        currencyId: json['currency_id'],
        price: json['price'],
        createAt: json['create_at'],
        updateAt: json['update_at'],
        deleteAt: json['delete_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? uuid;

  final int? userId;

  final int? currencyId;

  final int? price;

  final int? createAt;

  final int? updateAt;

  final int? deleteAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
        '_all': $all,
      };
}

class WalletAvgAggregateOutputType {
  const WalletAvgAggregateOutputType({
    this.id,
    this.userId,
    this.price,
  });

  factory WalletAvgAggregateOutputType.fromJson(Map json) =>
      WalletAvgAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        price: json['price'],
      );

  final double? id;

  final double? userId;

  final _i1.Decimal? price;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
      };
}

class WalletSumAggregateOutputType {
  const WalletSumAggregateOutputType({
    this.id,
    this.userId,
    this.price,
  });

  factory WalletSumAggregateOutputType.fromJson(Map json) =>
      WalletSumAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        price: json['price'],
      );

  final int? id;

  final int? userId;

  final _i1.Decimal? price;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
      };
}

class WalletMinAggregateOutputType {
  const WalletMinAggregateOutputType({
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  factory WalletMinAggregateOutputType.fromJson(Map json) =>
      WalletMinAggregateOutputType(
        id: json['id'],
        uuid: json['uuid'],
        userId: json['user_id'],
        currencyId: json['currency_id'],
        price: json['price'],
        createAt: json['create_at'],
        updateAt: json['update_at'],
        deleteAt: json['delete_at'],
      );

  final int? id;

  final String? uuid;

  final int? userId;

  final String? currencyId;

  final _i1.Decimal? price;

  final String? createAt;

  final String? updateAt;

  final String? deleteAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WalletMaxAggregateOutputType {
  const WalletMaxAggregateOutputType({
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  factory WalletMaxAggregateOutputType.fromJson(Map json) =>
      WalletMaxAggregateOutputType(
        id: json['id'],
        uuid: json['uuid'],
        userId: json['user_id'],
        currencyId: json['currency_id'],
        price: json['price'],
        createAt: json['create_at'],
        updateAt: json['update_at'],
        deleteAt: json['delete_at'],
      );

  final int? id;

  final String? uuid;

  final int? userId;

  final String? currencyId;

  final _i1.Decimal? price;

  final String? createAt;

  final String? updateAt;

  final String? deleteAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WalletGroupByOutputType {
  const WalletGroupByOutputType({
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory WalletGroupByOutputType.fromJson(Map json) => WalletGroupByOutputType(
        id: json['id'],
        uuid: json['uuid'],
        userId: json['user_id'],
        currencyId: json['currency_id'],
        price: json['price'],
        createAt: json['create_at'],
        updateAt: json['update_at'],
        deleteAt: json['delete_at'],
        $count: json['_count'] is Map
            ? _i2.WalletCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.WalletAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.WalletSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.WalletMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.WalletMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? uuid;

  final int? userId;

  final String? currencyId;

  final _i1.Decimal? price;

  final String? createAt;

  final String? updateAt;

  final String? deleteAt;

  final _i2.WalletCountAggregateOutputType? $count;

  final _i2.WalletAvgAggregateOutputType? $avg;

  final _i2.WalletSumAggregateOutputType? $sum;

  final _i2.WalletMinAggregateOutputType? $min;

  final _i2.WalletMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class WalletCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletCountOrderByAggregateInput({
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? currencyId;

  final _i2.SortOrder? price;

  final _i2.SortOrder? createAt;

  final _i2.SortOrder? updateAt;

  final _i2.SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WalletAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletAvgOrderByAggregateInput({
    this.id,
    this.userId,
    this.price,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? price;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
      };
}

class WalletMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletMaxOrderByAggregateInput({
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? currencyId;

  final _i2.SortOrder? price;

  final _i2.SortOrder? createAt;

  final _i2.SortOrder? updateAt;

  final _i2.SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WalletMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletMinOrderByAggregateInput({
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? currencyId;

  final _i2.SortOrder? price;

  final _i2.SortOrder? createAt;

  final _i2.SortOrder? updateAt;

  final _i2.SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WalletSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletSumOrderByAggregateInput({
    this.id,
    this.userId,
    this.price,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? price;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
      };
}

class WalletOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletOrderByWithAggregationInput({
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? userId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? currencyId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? price;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updateAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? deleteAt;

  final _i2.WalletCountOrderByAggregateInput? $count;

  final _i2.WalletAvgOrderByAggregateInput? $avg;

  final _i2.WalletMaxOrderByAggregateInput? $max;

  final _i2.WalletMinOrderByAggregateInput? $min;

  final _i2.WalletSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class WalletScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<_i2.WalletScalarWhereWithAggregatesInput,
      Iterable<_i2.WalletScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.WalletScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.WalletScalarWhereWithAggregatesInput,
      Iterable<_i2.WalletScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? currencyId;

  final _i1.PrismaUnion<_i2.DecimalNullableWithAggregatesFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WalletCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletCountAggregateOutputTypeSelect({
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
    this.$all,
  });

  final bool? id;

  final bool? uuid;

  final bool? userId;

  final bool? currencyId;

  final bool? price;

  final bool? createAt;

  final bool? updateAt;

  final bool? deleteAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
        '_all': $all,
      };
}

class WalletGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletGroupByOutputTypeCountArgs({this.select});

  final _i2.WalletCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WalletAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletAvgAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.price,
  });

  final bool? id;

  final bool? userId;

  final bool? price;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
      };
}

class WalletGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletGroupByOutputTypeAvgArgs({this.select});

  final _i2.WalletAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WalletSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletSumAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.price,
  });

  final bool? id;

  final bool? userId;

  final bool? price;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'price': price,
      };
}

class WalletGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletGroupByOutputTypeSumArgs({this.select});

  final _i2.WalletSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WalletMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletMinAggregateOutputTypeSelect({
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final bool? id;

  final bool? uuid;

  final bool? userId;

  final bool? currencyId;

  final bool? price;

  final bool? createAt;

  final bool? updateAt;

  final bool? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WalletGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletGroupByOutputTypeMinArgs({this.select});

  final _i2.WalletMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WalletMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletMaxAggregateOutputTypeSelect({
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final bool? id;

  final bool? uuid;

  final bool? userId;

  final bool? currencyId;

  final bool? price;

  final bool? createAt;

  final bool? updateAt;

  final bool? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WalletGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletGroupByOutputTypeMaxArgs({this.select});

  final _i2.WalletMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WalletGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletGroupByOutputTypeSelect({
    this.id,
    this.uuid,
    this.userId,
    this.currencyId,
    this.price,
    this.createAt,
    this.updateAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? uuid;

  final bool? userId;

  final bool? currencyId;

  final bool? price;

  final bool? createAt;

  final bool? updateAt;

  final bool? deleteAt;

  final _i1.PrismaUnion<bool, _i2.WalletGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.WalletGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.WalletGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.WalletGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.WalletGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'user_id': userId,
        'currency_id': currencyId,
        'price': price,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateWallet {
  const AggregateWallet({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateWallet.fromJson(Map json) => AggregateWallet(
        $count: json['_count'] is Map
            ? _i2.WalletCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.WalletAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.WalletSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.WalletMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.WalletMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.WalletCountAggregateOutputType? $count;

  final _i2.WalletAvgAggregateOutputType? $avg;

  final _i2.WalletSumAggregateOutputType? $sum;

  final _i2.WalletMinAggregateOutputType? $min;

  final _i2.WalletMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateWalletCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWalletCountArgs({this.select});

  final _i2.WalletCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWalletAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWalletAvgArgs({this.select});

  final _i2.WalletAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWalletSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWalletSumArgs({this.select});

  final _i2.WalletSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWalletMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWalletMinArgs({this.select});

  final _i2.WalletMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWalletMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWalletMaxArgs({this.select});

  final _i2.WalletMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWalletSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWalletSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateWalletCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateWalletAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateWalletSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateWalletMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateWalletMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class NestedDateTimeFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDateTimeFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? equals;

  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<DateTime, _i2.NestedDateTimeFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class DateTimeFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DateTimeFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? equals;

  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<DateTime, _i2.NestedDateTimeFilter>? not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class WalletVendorWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  final _i1.PrismaUnion<_i2.WalletVendorWhereInput,
      Iterable<_i2.WalletVendorWhereInput>>? AND;

  final Iterable<_i2.WalletVendorWhereInput>? OR;

  final _i1.PrismaUnion<_i2.WalletVendorWhereInput,
      Iterable<_i2.WalletVendorWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? uuid;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      vendorId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? currentId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updateAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
      };
}

class WalletVendorWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.WalletVendorWhereInput,
      Iterable<_i2.WalletVendorWhereInput>>? AND;

  final Iterable<_i2.WalletVendorWhereInput>? OR;

  final _i1.PrismaUnion<_i2.WalletVendorWhereInput,
      Iterable<_i2.WalletVendorWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? uuid;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      vendorId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? currentId;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updateAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
      };
}

class WalletVendorSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorSelect({
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  final bool? id;

  final bool? uuid;

  final bool? vendorId;

  final bool? currentId;

  final bool? createAt;

  final bool? updateAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
      };
}

class WalletVendorOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorOrderByWithRelationInput({
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? vendorId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? currentId;

  final _i2.SortOrder? createAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updateAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
      };
}

enum WalletVendorScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'WalletVendor'),
  uuid<String>('uuid', 'WalletVendor'),
  vendorId<int>('vendor_id', 'WalletVendor'),
  currentId<String>('current_id', 'WalletVendor'),
  createAt<DateTime>('create_at', 'WalletVendor'),
  updateAt<DateTime>('update_at', 'WalletVendor');

  const WalletVendorScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class WalletVendorCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorCreateInput({
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? uuid;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? vendorId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentId;

  final DateTime? createAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updateAt;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
      };
}

class WalletVendorUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorUncheckedCreateInput({
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? uuid;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? vendorId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentId;

  final DateTime? createAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updateAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
      };
}

class WalletVendorCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorCreateManyInput({
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? uuid;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? vendorId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? currentId;

  final DateTime? createAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updateAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
      };
}

class DateTimeFieldUpdateOperationsInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DateTimeFieldUpdateOperationsInput({this.set});

  final DateTime? set;

  @override
  Map<String, dynamic> toJson() => {'set': set};
}

class WalletVendorUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorUpdateInput({
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? currentId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
      };
}

class WalletVendorUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorUncheckedUpdateInput({
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? currentId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
      };
}

class WalletVendorUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorUpdateManyMutationInput({
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? currentId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
      };
}

class WalletVendorUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorUncheckedUpdateManyInput({
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? currentId;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
      };
}

class WalletVendorCountAggregateOutputType {
  const WalletVendorCountAggregateOutputType({
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
    this.$all,
  });

  factory WalletVendorCountAggregateOutputType.fromJson(Map json) =>
      WalletVendorCountAggregateOutputType(
        id: json['id'],
        uuid: json['uuid'],
        vendorId: json['vendor_id'],
        currentId: json['current_id'],
        createAt: json['create_at'],
        updateAt: json['update_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? uuid;

  final int? vendorId;

  final int? currentId;

  final int? createAt;

  final int? updateAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
        '_all': $all,
      };
}

class WalletVendorAvgAggregateOutputType {
  const WalletVendorAvgAggregateOutputType({
    this.id,
    this.vendorId,
  });

  factory WalletVendorAvgAggregateOutputType.fromJson(Map json) =>
      WalletVendorAvgAggregateOutputType(
        id: json['id'],
        vendorId: json['vendor_id'],
      );

  final double? id;

  final double? vendorId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
      };
}

class WalletVendorSumAggregateOutputType {
  const WalletVendorSumAggregateOutputType({
    this.id,
    this.vendorId,
  });

  factory WalletVendorSumAggregateOutputType.fromJson(Map json) =>
      WalletVendorSumAggregateOutputType(
        id: json['id'],
        vendorId: json['vendor_id'],
      );

  final int? id;

  final int? vendorId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
      };
}

class WalletVendorMinAggregateOutputType {
  const WalletVendorMinAggregateOutputType({
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  factory WalletVendorMinAggregateOutputType.fromJson(Map json) =>
      WalletVendorMinAggregateOutputType(
        id: json['id'],
        uuid: json['uuid'],
        vendorId: json['vendor_id'],
        currentId: json['current_id'],
        createAt: switch (json['create_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['create_at']
        },
        updateAt: switch (json['update_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['update_at']
        },
      );

  final int? id;

  final String? uuid;

  final int? vendorId;

  final String? currentId;

  final DateTime? createAt;

  final DateTime? updateAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt?.toIso8601String(),
        'update_at': updateAt?.toIso8601String(),
      };
}

class WalletVendorMaxAggregateOutputType {
  const WalletVendorMaxAggregateOutputType({
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  factory WalletVendorMaxAggregateOutputType.fromJson(Map json) =>
      WalletVendorMaxAggregateOutputType(
        id: json['id'],
        uuid: json['uuid'],
        vendorId: json['vendor_id'],
        currentId: json['current_id'],
        createAt: switch (json['create_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['create_at']
        },
        updateAt: switch (json['update_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['update_at']
        },
      );

  final int? id;

  final String? uuid;

  final int? vendorId;

  final String? currentId;

  final DateTime? createAt;

  final DateTime? updateAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt?.toIso8601String(),
        'update_at': updateAt?.toIso8601String(),
      };
}

class WalletVendorGroupByOutputType {
  const WalletVendorGroupByOutputType({
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory WalletVendorGroupByOutputType.fromJson(Map json) =>
      WalletVendorGroupByOutputType(
        id: json['id'],
        uuid: json['uuid'],
        vendorId: json['vendor_id'],
        currentId: json['current_id'],
        createAt: switch (json['create_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['create_at']
        },
        updateAt: switch (json['update_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['update_at']
        },
        $count: json['_count'] is Map
            ? _i2.WalletVendorCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.WalletVendorAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.WalletVendorSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.WalletVendorMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.WalletVendorMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? uuid;

  final int? vendorId;

  final String? currentId;

  final DateTime? createAt;

  final DateTime? updateAt;

  final _i2.WalletVendorCountAggregateOutputType? $count;

  final _i2.WalletVendorAvgAggregateOutputType? $avg;

  final _i2.WalletVendorSumAggregateOutputType? $sum;

  final _i2.WalletVendorMinAggregateOutputType? $min;

  final _i2.WalletVendorMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt?.toIso8601String(),
        'update_at': updateAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class WalletVendorCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorCountOrderByAggregateInput({
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? currentId;

  final _i2.SortOrder? createAt;

  final _i2.SortOrder? updateAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
      };
}

class WalletVendorAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorAvgOrderByAggregateInput({
    this.id,
    this.vendorId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? vendorId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
      };
}

class WalletVendorMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorMaxOrderByAggregateInput({
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? currentId;

  final _i2.SortOrder? createAt;

  final _i2.SortOrder? updateAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
      };
}

class WalletVendorMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorMinOrderByAggregateInput({
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? currentId;

  final _i2.SortOrder? createAt;

  final _i2.SortOrder? updateAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
      };
}

class WalletVendorSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorSumOrderByAggregateInput({
    this.id,
    this.vendorId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? vendorId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
      };
}

class WalletVendorOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorOrderByWithAggregationInput({
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? vendorId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? currentId;

  final _i2.SortOrder? createAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updateAt;

  final _i2.WalletVendorCountOrderByAggregateInput? $count;

  final _i2.WalletVendorAvgOrderByAggregateInput? $avg;

  final _i2.WalletVendorMaxOrderByAggregateInput? $max;

  final _i2.WalletVendorMinOrderByAggregateInput? $min;

  final _i2.WalletVendorSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class NestedDateTimeWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedDateTimeWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? equals;

  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<DateTime, _i2.NestedDateTimeWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedDateTimeFilter? $min;

  final _i2.NestedDateTimeFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class DateTimeWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DateTimeWithAggregatesFilter({
    this.equals,
    this.$in,
    this.notIn,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? equals;

  final Iterable<DateTime>? $in;

  final Iterable<DateTime>? notIn;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? lte;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gt;

  final _i1.PrismaUnion<DateTime, _i1.Reference<DateTime>>? gte;

  final _i1.PrismaUnion<DateTime, _i2.NestedDateTimeWithAggregatesFilter>? not;

  final _i2.NestedIntFilter? $count;

  final _i2.NestedDateTimeFilter? $min;

  final _i2.NestedDateTimeFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'in': $in,
        'notIn': notIn,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class WalletVendorScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  final _i1.PrismaUnion<_i2.WalletVendorScalarWhereWithAggregatesInput,
      Iterable<_i2.WalletVendorScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.WalletVendorScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.WalletVendorScalarWhereWithAggregatesInput,
      Iterable<_i2.WalletVendorScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? currentId;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updateAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
      };
}

class WalletVendorCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorCountAggregateOutputTypeSelect({
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
    this.$all,
  });

  final bool? id;

  final bool? uuid;

  final bool? vendorId;

  final bool? currentId;

  final bool? createAt;

  final bool? updateAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
        '_all': $all,
      };
}

class WalletVendorGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorGroupByOutputTypeCountArgs({this.select});

  final _i2.WalletVendorCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WalletVendorAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorAvgAggregateOutputTypeSelect({
    this.id,
    this.vendorId,
  });

  final bool? id;

  final bool? vendorId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
      };
}

class WalletVendorGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorGroupByOutputTypeAvgArgs({this.select});

  final _i2.WalletVendorAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WalletVendorSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorSumAggregateOutputTypeSelect({
    this.id,
    this.vendorId,
  });

  final bool? id;

  final bool? vendorId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
      };
}

class WalletVendorGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorGroupByOutputTypeSumArgs({this.select});

  final _i2.WalletVendorSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WalletVendorMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorMinAggregateOutputTypeSelect({
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  final bool? id;

  final bool? uuid;

  final bool? vendorId;

  final bool? currentId;

  final bool? createAt;

  final bool? updateAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
      };
}

class WalletVendorGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorGroupByOutputTypeMinArgs({this.select});

  final _i2.WalletVendorMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WalletVendorMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorMaxAggregateOutputTypeSelect({
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
  });

  final bool? id;

  final bool? uuid;

  final bool? vendorId;

  final bool? currentId;

  final bool? createAt;

  final bool? updateAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
      };
}

class WalletVendorGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorGroupByOutputTypeMaxArgs({this.select});

  final _i2.WalletVendorMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WalletVendorGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WalletVendorGroupByOutputTypeSelect({
    this.id,
    this.uuid,
    this.vendorId,
    this.currentId,
    this.createAt,
    this.updateAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? uuid;

  final bool? vendorId;

  final bool? currentId;

  final bool? createAt;

  final bool? updateAt;

  final _i1.PrismaUnion<bool, _i2.WalletVendorGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.WalletVendorGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.WalletVendorGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.WalletVendorGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.WalletVendorGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'vendor_id': vendorId,
        'current_id': currentId,
        'create_at': createAt,
        'update_at': updateAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateWalletVendor {
  const AggregateWalletVendor({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateWalletVendor.fromJson(Map json) => AggregateWalletVendor(
        $count: json['_count'] is Map
            ? _i2.WalletVendorCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.WalletVendorAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.WalletVendorSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.WalletVendorMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.WalletVendorMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.WalletVendorCountAggregateOutputType? $count;

  final _i2.WalletVendorAvgAggregateOutputType? $avg;

  final _i2.WalletVendorSumAggregateOutputType? $sum;

  final _i2.WalletVendorMinAggregateOutputType? $min;

  final _i2.WalletVendorMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateWalletVendorCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWalletVendorCountArgs({this.select});

  final _i2.WalletVendorCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWalletVendorAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWalletVendorAvgArgs({this.select});

  final _i2.WalletVendorAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWalletVendorSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWalletVendorSumArgs({this.select});

  final _i2.WalletVendorSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWalletVendorMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWalletVendorMinArgs({this.select});

  final _i2.WalletVendorMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWalletVendorMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWalletVendorMaxArgs({this.select});

  final _i2.WalletVendorMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWalletVendorSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWalletVendorSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateWalletVendorCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateWalletVendorAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateWalletVendorSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateWalletVendorMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateWalletVendorMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class WallethistoriesWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<_i2.WallethistoriesWhereInput,
      Iterable<_i2.WallethistoriesWhereInput>>? AND;

  final Iterable<_i2.WallethistoriesWhereInput>? OR;

  final _i1.PrismaUnion<_i2.WallethistoriesWhereInput,
      Iterable<_i2.WallethistoriesWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? walletUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? type;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      price;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? note;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WallethistoriesWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.WallethistoriesWhereInput,
      Iterable<_i2.WallethistoriesWhereInput>>? AND;

  final Iterable<_i2.WallethistoriesWhereInput>? OR;

  final _i1.PrismaUnion<_i2.WallethistoriesWhereInput,
      Iterable<_i2.WallethistoriesWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? walletUuid;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? type;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      price;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? note;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WallethistoriesSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesSelect({
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final bool? id;

  final bool? uuid;

  final bool? walletUuid;

  final bool? type;

  final bool? price;

  final bool? note;

  final bool? status;

  final bool? createAt;

  final bool? updateAt;

  final bool? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WallethistoriesOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesOrderByWithRelationInput({
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? walletUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? type;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? price;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? note;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updateAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

enum WallethistoriesScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Wallethistories'),
  uuid<String>('uuid', 'Wallethistories'),
  walletUuid<String>('wallet_uuid', 'Wallethistories'),
  type<String>('type', 'Wallethistories'),
  price<int>('price', 'Wallethistories'),
  note<String>('note', 'Wallethistories'),
  status<String>('status', 'Wallethistories'),
  createAt<String>('create_at', 'Wallethistories'),
  updateAt<String>('update_at', 'Wallethistories'),
  deleteAt<String>('delete_at', 'Wallethistories');

  const WallethistoriesScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class WallethistoriesCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesCreateInput({
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? walletUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? type;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? price;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? createAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? updateAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WallethistoriesUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesUncheckedCreateInput({
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? walletUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? type;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? price;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? createAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? updateAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WallethistoriesCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesCreateManyInput({
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? uuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? walletUuid;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? type;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? price;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? note;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? createAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? updateAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WallethistoriesUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesUpdateInput({
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? walletUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? type;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WallethistoriesUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesUncheckedUpdateInput({
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? walletUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? type;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WallethistoriesUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesUpdateManyMutationInput({
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? walletUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? type;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WallethistoriesUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesUncheckedUpdateManyInput({
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? walletUuid;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? type;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? note;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WallethistoriesCountAggregateOutputType {
  const WallethistoriesCountAggregateOutputType({
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
    this.$all,
  });

  factory WallethistoriesCountAggregateOutputType.fromJson(Map json) =>
      WallethistoriesCountAggregateOutputType(
        id: json['id'],
        uuid: json['uuid'],
        walletUuid: json['wallet_uuid'],
        type: json['type'],
        price: json['price'],
        note: json['note'],
        status: json['status'],
        createAt: json['create_at'],
        updateAt: json['update_at'],
        deleteAt: json['delete_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? uuid;

  final int? walletUuid;

  final int? type;

  final int? price;

  final int? note;

  final int? status;

  final int? createAt;

  final int? updateAt;

  final int? deleteAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
        '_all': $all,
      };
}

class WallethistoriesAvgAggregateOutputType {
  const WallethistoriesAvgAggregateOutputType({
    this.id,
    this.price,
  });

  factory WallethistoriesAvgAggregateOutputType.fromJson(Map json) =>
      WallethistoriesAvgAggregateOutputType(
        id: json['id'],
        price: json['price'],
      );

  final double? id;

  final double? price;

  Map<String, dynamic> toJson() => {
        'id': id,
        'price': price,
      };
}

class WallethistoriesSumAggregateOutputType {
  const WallethistoriesSumAggregateOutputType({
    this.id,
    this.price,
  });

  factory WallethistoriesSumAggregateOutputType.fromJson(Map json) =>
      WallethistoriesSumAggregateOutputType(
        id: json['id'],
        price: json['price'],
      );

  final int? id;

  final int? price;

  Map<String, dynamic> toJson() => {
        'id': id,
        'price': price,
      };
}

class WallethistoriesMinAggregateOutputType {
  const WallethistoriesMinAggregateOutputType({
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  factory WallethistoriesMinAggregateOutputType.fromJson(Map json) =>
      WallethistoriesMinAggregateOutputType(
        id: json['id'],
        uuid: json['uuid'],
        walletUuid: json['wallet_uuid'],
        type: json['type'],
        price: json['price'],
        note: json['note'],
        status: json['status'],
        createAt: json['create_at'],
        updateAt: json['update_at'],
        deleteAt: json['delete_at'],
      );

  final int? id;

  final String? uuid;

  final String? walletUuid;

  final String? type;

  final int? price;

  final String? note;

  final String? status;

  final String? createAt;

  final String? updateAt;

  final String? deleteAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WallethistoriesMaxAggregateOutputType {
  const WallethistoriesMaxAggregateOutputType({
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  factory WallethistoriesMaxAggregateOutputType.fromJson(Map json) =>
      WallethistoriesMaxAggregateOutputType(
        id: json['id'],
        uuid: json['uuid'],
        walletUuid: json['wallet_uuid'],
        type: json['type'],
        price: json['price'],
        note: json['note'],
        status: json['status'],
        createAt: json['create_at'],
        updateAt: json['update_at'],
        deleteAt: json['delete_at'],
      );

  final int? id;

  final String? uuid;

  final String? walletUuid;

  final String? type;

  final int? price;

  final String? note;

  final String? status;

  final String? createAt;

  final String? updateAt;

  final String? deleteAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WallethistoriesGroupByOutputType {
  const WallethistoriesGroupByOutputType({
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory WallethistoriesGroupByOutputType.fromJson(Map json) =>
      WallethistoriesGroupByOutputType(
        id: json['id'],
        uuid: json['uuid'],
        walletUuid: json['wallet_uuid'],
        type: json['type'],
        price: json['price'],
        note: json['note'],
        status: json['status'],
        createAt: json['create_at'],
        updateAt: json['update_at'],
        deleteAt: json['delete_at'],
        $count: json['_count'] is Map
            ? _i2.WallethistoriesCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.WallethistoriesAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.WallethistoriesSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.WallethistoriesMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.WallethistoriesMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? uuid;

  final String? walletUuid;

  final String? type;

  final int? price;

  final String? note;

  final String? status;

  final String? createAt;

  final String? updateAt;

  final String? deleteAt;

  final _i2.WallethistoriesCountAggregateOutputType? $count;

  final _i2.WallethistoriesAvgAggregateOutputType? $avg;

  final _i2.WallethistoriesSumAggregateOutputType? $sum;

  final _i2.WallethistoriesMinAggregateOutputType? $min;

  final _i2.WallethistoriesMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class WallethistoriesCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesCountOrderByAggregateInput({
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? walletUuid;

  final _i2.SortOrder? type;

  final _i2.SortOrder? price;

  final _i2.SortOrder? note;

  final _i2.SortOrder? status;

  final _i2.SortOrder? createAt;

  final _i2.SortOrder? updateAt;

  final _i2.SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WallethistoriesAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesAvgOrderByAggregateInput({
    this.id,
    this.price,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? price;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'price': price,
      };
}

class WallethistoriesMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesMaxOrderByAggregateInput({
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? walletUuid;

  final _i2.SortOrder? type;

  final _i2.SortOrder? price;

  final _i2.SortOrder? note;

  final _i2.SortOrder? status;

  final _i2.SortOrder? createAt;

  final _i2.SortOrder? updateAt;

  final _i2.SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WallethistoriesMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesMinOrderByAggregateInput({
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? uuid;

  final _i2.SortOrder? walletUuid;

  final _i2.SortOrder? type;

  final _i2.SortOrder? price;

  final _i2.SortOrder? note;

  final _i2.SortOrder? status;

  final _i2.SortOrder? createAt;

  final _i2.SortOrder? updateAt;

  final _i2.SortOrder? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WallethistoriesSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesSumOrderByAggregateInput({
    this.id,
    this.price,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? price;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'price': price,
      };
}

class WallethistoriesOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesOrderByWithAggregationInput({
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? uuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? walletUuid;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? type;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? price;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? note;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updateAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? deleteAt;

  final _i2.WallethistoriesCountOrderByAggregateInput? $count;

  final _i2.WallethistoriesAvgOrderByAggregateInput? $avg;

  final _i2.WallethistoriesMaxOrderByAggregateInput? $max;

  final _i2.WallethistoriesMinOrderByAggregateInput? $min;

  final _i2.WallethistoriesSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class WallethistoriesScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final _i1.PrismaUnion<_i2.WallethistoriesScalarWhereWithAggregatesInput,
      Iterable<_i2.WallethistoriesScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.WallethistoriesScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.WallethistoriesScalarWhereWithAggregatesInput,
      Iterable<_i2.WallethistoriesScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? uuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? walletUuid;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? type;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? note;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? createAt;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? updateAt;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WallethistoriesCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesCountAggregateOutputTypeSelect({
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
    this.$all,
  });

  final bool? id;

  final bool? uuid;

  final bool? walletUuid;

  final bool? type;

  final bool? price;

  final bool? note;

  final bool? status;

  final bool? createAt;

  final bool? updateAt;

  final bool? deleteAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
        '_all': $all,
      };
}

class WallethistoriesGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesGroupByOutputTypeCountArgs({this.select});

  final _i2.WallethistoriesCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WallethistoriesAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesAvgAggregateOutputTypeSelect({
    this.id,
    this.price,
  });

  final bool? id;

  final bool? price;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'price': price,
      };
}

class WallethistoriesGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesGroupByOutputTypeAvgArgs({this.select});

  final _i2.WallethistoriesAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WallethistoriesSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesSumAggregateOutputTypeSelect({
    this.id,
    this.price,
  });

  final bool? id;

  final bool? price;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'price': price,
      };
}

class WallethistoriesGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesGroupByOutputTypeSumArgs({this.select});

  final _i2.WallethistoriesSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WallethistoriesMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesMinAggregateOutputTypeSelect({
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final bool? id;

  final bool? uuid;

  final bool? walletUuid;

  final bool? type;

  final bool? price;

  final bool? note;

  final bool? status;

  final bool? createAt;

  final bool? updateAt;

  final bool? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WallethistoriesGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesGroupByOutputTypeMinArgs({this.select});

  final _i2.WallethistoriesMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WallethistoriesMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesMaxAggregateOutputTypeSelect({
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
  });

  final bool? id;

  final bool? uuid;

  final bool? walletUuid;

  final bool? type;

  final bool? price;

  final bool? note;

  final bool? status;

  final bool? createAt;

  final bool? updateAt;

  final bool? deleteAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
      };
}

class WallethistoriesGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesGroupByOutputTypeMaxArgs({this.select});

  final _i2.WallethistoriesMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class WallethistoriesGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const WallethistoriesGroupByOutputTypeSelect({
    this.id,
    this.uuid,
    this.walletUuid,
    this.type,
    this.price,
    this.note,
    this.status,
    this.createAt,
    this.updateAt,
    this.deleteAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? uuid;

  final bool? walletUuid;

  final bool? type;

  final bool? price;

  final bool? note;

  final bool? status;

  final bool? createAt;

  final bool? updateAt;

  final bool? deleteAt;

  final _i1.PrismaUnion<bool, _i2.WallethistoriesGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.WallethistoriesGroupByOutputTypeAvgArgs>?
      $avg;

  final _i1.PrismaUnion<bool, _i2.WallethistoriesGroupByOutputTypeSumArgs>?
      $sum;

  final _i1.PrismaUnion<bool, _i2.WallethistoriesGroupByOutputTypeMinArgs>?
      $min;

  final _i1.PrismaUnion<bool, _i2.WallethistoriesGroupByOutputTypeMaxArgs>?
      $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'uuid': uuid,
        'wallet_uuid': walletUuid,
        'type': type,
        'price': price,
        'note': note,
        'status': status,
        'create_at': createAt,
        'update_at': updateAt,
        'delete_at': deleteAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateWallethistories {
  const AggregateWallethistories({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateWallethistories.fromJson(Map json) =>
      AggregateWallethistories(
        $count: json['_count'] is Map
            ? _i2.WallethistoriesCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.WallethistoriesAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.WallethistoriesSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.WallethistoriesMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.WallethistoriesMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.WallethistoriesCountAggregateOutputType? $count;

  final _i2.WallethistoriesAvgAggregateOutputType? $avg;

  final _i2.WallethistoriesSumAggregateOutputType? $sum;

  final _i2.WallethistoriesMinAggregateOutputType? $min;

  final _i2.WallethistoriesMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateWallethistoriesCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWallethistoriesCountArgs({this.select});

  final _i2.WallethistoriesCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWallethistoriesAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWallethistoriesAvgArgs({this.select});

  final _i2.WallethistoriesAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWallethistoriesSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWallethistoriesSumArgs({this.select});

  final _i2.WallethistoriesSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWallethistoriesMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWallethistoriesMinArgs({this.select});

  final _i2.WallethistoriesMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWallethistoriesMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWallethistoriesMaxArgs({this.select});

  final _i2.WallethistoriesMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateWallethistoriesSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateWallethistoriesSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateWallethistoriesCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateWallethistoriesAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateWallethistoriesSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateWallethistoriesMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateWallethistoriesMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class UserNotificationWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.UserNotificationWhereInput,
      Iterable<_i2.UserNotificationWhereInput>>? AND;

  final Iterable<_i2.UserNotificationWhereInput>? OR;

  final _i1.PrismaUnion<_i2.UserNotificationWhereInput,
      Iterable<_i2.UserNotificationWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? data;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      userId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      vendorId;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserNotificationWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.UserNotificationWhereInput,
      Iterable<_i2.UserNotificationWhereInput>>? AND;

  final Iterable<_i2.UserNotificationWhereInput>? OR;

  final _i1.PrismaUnion<_i2.UserNotificationWhereInput,
      Iterable<_i2.UserNotificationWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? data;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      userId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      vendorId;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserNotificationSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationSelect({
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? data;

  final bool? status;

  final bool? userId;

  final bool? vendorId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserNotificationOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationOrderByWithRelationInput({
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? data;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? userId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? vendorId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

enum UserNotificationScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'UserNotification'),
  data<String>('data', 'UserNotification'),
  status<bool>('status', 'UserNotification'),
  userId<int>('user_id', 'UserNotification'),
  vendorId<int>('vendor_id', 'UserNotification'),
  createdAt<DateTime>('created_at', 'UserNotification'),
  updatedAt<DateTime>('updated_at', 'UserNotification');

  const UserNotificationScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class UserNotificationCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationCreateInput({
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? data;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? vendorId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserNotificationUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationUncheckedCreateInput({
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? data;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? vendorId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserNotificationCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationCreateManyInput({
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? data;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? vendorId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserNotificationUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationUpdateInput({
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? data;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserNotificationUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationUncheckedUpdateInput({
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? data;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserNotificationUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationUpdateManyMutationInput({
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? data;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserNotificationUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationUncheckedUpdateManyInput({
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? data;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserNotificationCountAggregateOutputType {
  const UserNotificationCountAggregateOutputType({
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory UserNotificationCountAggregateOutputType.fromJson(Map json) =>
      UserNotificationCountAggregateOutputType(
        id: json['id'],
        data: json['data'],
        status: json['status'],
        userId: json['user_id'],
        vendorId: json['vendor_id'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? data;

  final int? status;

  final int? userId;

  final int? vendorId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class UserNotificationAvgAggregateOutputType {
  const UserNotificationAvgAggregateOutputType({
    this.id,
    this.userId,
    this.vendorId,
  });

  factory UserNotificationAvgAggregateOutputType.fromJson(Map json) =>
      UserNotificationAvgAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        vendorId: json['vendor_id'],
      );

  final double? id;

  final double? userId;

  final double? vendorId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'vendor_id': vendorId,
      };
}

class UserNotificationSumAggregateOutputType {
  const UserNotificationSumAggregateOutputType({
    this.id,
    this.userId,
    this.vendorId,
  });

  factory UserNotificationSumAggregateOutputType.fromJson(Map json) =>
      UserNotificationSumAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        vendorId: json['vendor_id'],
      );

  final int? id;

  final int? userId;

  final int? vendorId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'vendor_id': vendorId,
      };
}

class UserNotificationMinAggregateOutputType {
  const UserNotificationMinAggregateOutputType({
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  factory UserNotificationMinAggregateOutputType.fromJson(Map json) =>
      UserNotificationMinAggregateOutputType(
        id: json['id'],
        data: json['data'],
        status: json['status'],
        userId: json['user_id'],
        vendorId: json['vendor_id'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final String? data;

  final bool? status;

  final int? userId;

  final int? vendorId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class UserNotificationMaxAggregateOutputType {
  const UserNotificationMaxAggregateOutputType({
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  factory UserNotificationMaxAggregateOutputType.fromJson(Map json) =>
      UserNotificationMaxAggregateOutputType(
        id: json['id'],
        data: json['data'],
        status: json['status'],
        userId: json['user_id'],
        vendorId: json['vendor_id'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final String? data;

  final bool? status;

  final int? userId;

  final int? vendorId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class UserNotificationGroupByOutputType {
  const UserNotificationGroupByOutputType({
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory UserNotificationGroupByOutputType.fromJson(Map json) =>
      UserNotificationGroupByOutputType(
        id: json['id'],
        data: json['data'],
        status: json['status'],
        userId: json['user_id'],
        vendorId: json['vendor_id'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        $count: json['_count'] is Map
            ? _i2.UserNotificationCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.UserNotificationAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.UserNotificationSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.UserNotificationMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.UserNotificationMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? data;

  final bool? status;

  final int? userId;

  final int? vendorId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.UserNotificationCountAggregateOutputType? $count;

  final _i2.UserNotificationAvgAggregateOutputType? $avg;

  final _i2.UserNotificationSumAggregateOutputType? $sum;

  final _i2.UserNotificationMinAggregateOutputType? $min;

  final _i2.UserNotificationMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class UserNotificationCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationCountOrderByAggregateInput({
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? data;

  final _i2.SortOrder? status;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserNotificationAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationAvgOrderByAggregateInput({
    this.id,
    this.userId,
    this.vendorId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? vendorId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'vendor_id': vendorId,
      };
}

class UserNotificationMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationMaxOrderByAggregateInput({
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? data;

  final _i2.SortOrder? status;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserNotificationMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationMinOrderByAggregateInput({
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? data;

  final _i2.SortOrder? status;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserNotificationSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationSumOrderByAggregateInput({
    this.id,
    this.userId,
    this.vendorId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? vendorId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'vendor_id': vendorId,
      };
}

class UserNotificationOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationOrderByWithAggregationInput({
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? data;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? userId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? vendorId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i2.UserNotificationCountOrderByAggregateInput? $count;

  final _i2.UserNotificationAvgOrderByAggregateInput? $avg;

  final _i2.UserNotificationMaxOrderByAggregateInput? $max;

  final _i2.UserNotificationMinOrderByAggregateInput? $min;

  final _i2.UserNotificationSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class UserNotificationScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.UserNotificationScalarWhereWithAggregatesInput,
      Iterable<_i2.UserNotificationScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.UserNotificationScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.UserNotificationScalarWhereWithAggregatesInput,
      Iterable<_i2.UserNotificationScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? data;

  final _i1.PrismaUnion<_i2.BoolNullableWithAggregatesFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserNotificationCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationCountAggregateOutputTypeSelect({
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? data;

  final bool? status;

  final bool? userId;

  final bool? vendorId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class UserNotificationGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationGroupByOutputTypeCountArgs({this.select});

  final _i2.UserNotificationCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserNotificationAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationAvgAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.vendorId,
  });

  final bool? id;

  final bool? userId;

  final bool? vendorId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'vendor_id': vendorId,
      };
}

class UserNotificationGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationGroupByOutputTypeAvgArgs({this.select});

  final _i2.UserNotificationAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserNotificationSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationSumAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.vendorId,
  });

  final bool? id;

  final bool? userId;

  final bool? vendorId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'vendor_id': vendorId,
      };
}

class UserNotificationGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationGroupByOutputTypeSumArgs({this.select});

  final _i2.UserNotificationSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserNotificationMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationMinAggregateOutputTypeSelect({
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? data;

  final bool? status;

  final bool? userId;

  final bool? vendorId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserNotificationGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationGroupByOutputTypeMinArgs({this.select});

  final _i2.UserNotificationMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserNotificationMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationMaxAggregateOutputTypeSelect({
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? data;

  final bool? status;

  final bool? userId;

  final bool? vendorId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class UserNotificationGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationGroupByOutputTypeMaxArgs({this.select});

  final _i2.UserNotificationMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class UserNotificationGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const UserNotificationGroupByOutputTypeSelect({
    this.id,
    this.data,
    this.status,
    this.userId,
    this.vendorId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? data;

  final bool? status;

  final bool? userId;

  final bool? vendorId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.UserNotificationGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.UserNotificationGroupByOutputTypeAvgArgs>?
      $avg;

  final _i1.PrismaUnion<bool, _i2.UserNotificationGroupByOutputTypeSumArgs>?
      $sum;

  final _i1.PrismaUnion<bool, _i2.UserNotificationGroupByOutputTypeMinArgs>?
      $min;

  final _i1.PrismaUnion<bool, _i2.UserNotificationGroupByOutputTypeMaxArgs>?
      $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'data': data,
        'status': status,
        'user_id': userId,
        'vendor_id': vendorId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateUserNotification {
  const AggregateUserNotification({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateUserNotification.fromJson(Map json) =>
      AggregateUserNotification(
        $count: json['_count'] is Map
            ? _i2.UserNotificationCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.UserNotificationAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.UserNotificationSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.UserNotificationMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.UserNotificationMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.UserNotificationCountAggregateOutputType? $count;

  final _i2.UserNotificationAvgAggregateOutputType? $avg;

  final _i2.UserNotificationSumAggregateOutputType? $sum;

  final _i2.UserNotificationMinAggregateOutputType? $min;

  final _i2.UserNotificationMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateUserNotificationCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserNotificationCountArgs({this.select});

  final _i2.UserNotificationCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserNotificationAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserNotificationAvgArgs({this.select});

  final _i2.UserNotificationAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserNotificationSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserNotificationSumArgs({this.select});

  final _i2.UserNotificationSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserNotificationMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserNotificationMinArgs({this.select});

  final _i2.UserNotificationMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserNotificationMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserNotificationMaxArgs({this.select});

  final _i2.UserNotificationMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateUserNotificationSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateUserNotificationSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateUserNotificationCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateUserNotificationAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateUserNotificationSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateUserNotificationMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateUserNotificationMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class SubcriptionWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.SubcriptionWhereInput,
      Iterable<_i2.SubcriptionWhereInput>>? AND;

  final Iterable<_i2.SubcriptionWhereInput>? OR;

  final _i1.PrismaUnion<_i2.SubcriptionWhereInput,
      Iterable<_i2.SubcriptionWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class SubcriptionWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.SubcriptionWhereInput,
      Iterable<_i2.SubcriptionWhereInput>>? AND;

  final Iterable<_i2.SubcriptionWhereInput>? OR;

  final _i1.PrismaUnion<_i2.SubcriptionWhereInput,
      Iterable<_i2.SubcriptionWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.DecimalNullableFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class SubcriptionSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionSelect({
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? price;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class SubcriptionOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionOrderByWithRelationInput({
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? price;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

enum SubcriptionScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Subcription'),
  name$<String>('name', 'Subcription'),
  price<_i1.Decimal>('price', 'Subcription'),
  createdAt<DateTime>('created_at', 'Subcription'),
  updatedAt<DateTime>('updated_at', 'Subcription');

  const SubcriptionScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class SubcriptionCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionCreateInput({
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? price;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class SubcriptionUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionUncheckedCreateInput({
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? price;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class SubcriptionCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionCreateManyInput({
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>? price;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class SubcriptionUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionUpdateInput({
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class SubcriptionUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionUncheckedUpdateInput({
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class SubcriptionUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionUpdateManyMutationInput({
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class SubcriptionUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionUncheckedUpdateManyInput({
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      _i1.Decimal,
      _i1.PrismaUnion<_i2.NullableDecimalFieldUpdateOperationsInput,
          _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class SubcriptionCountAggregateOutputType {
  const SubcriptionCountAggregateOutputType({
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory SubcriptionCountAggregateOutputType.fromJson(Map json) =>
      SubcriptionCountAggregateOutputType(
        id: json['id'],
        name: json['name'],
        price: json['price'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? name;

  final int? price;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class SubcriptionAvgAggregateOutputType {
  const SubcriptionAvgAggregateOutputType({
    this.id,
    this.price,
  });

  factory SubcriptionAvgAggregateOutputType.fromJson(Map json) =>
      SubcriptionAvgAggregateOutputType(
        id: json['id'],
        price: json['price'],
      );

  final double? id;

  final _i1.Decimal? price;

  Map<String, dynamic> toJson() => {
        'id': id,
        'price': price,
      };
}

class SubcriptionSumAggregateOutputType {
  const SubcriptionSumAggregateOutputType({
    this.id,
    this.price,
  });

  factory SubcriptionSumAggregateOutputType.fromJson(Map json) =>
      SubcriptionSumAggregateOutputType(
        id: json['id'],
        price: json['price'],
      );

  final int? id;

  final _i1.Decimal? price;

  Map<String, dynamic> toJson() => {
        'id': id,
        'price': price,
      };
}

class SubcriptionMinAggregateOutputType {
  const SubcriptionMinAggregateOutputType({
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  factory SubcriptionMinAggregateOutputType.fromJson(Map json) =>
      SubcriptionMinAggregateOutputType(
        id: json['id'],
        name: json['name'],
        price: json['price'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final String? name;

  final _i1.Decimal? price;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class SubcriptionMaxAggregateOutputType {
  const SubcriptionMaxAggregateOutputType({
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  factory SubcriptionMaxAggregateOutputType.fromJson(Map json) =>
      SubcriptionMaxAggregateOutputType(
        id: json['id'],
        name: json['name'],
        price: json['price'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final String? name;

  final _i1.Decimal? price;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class SubcriptionGroupByOutputType {
  const SubcriptionGroupByOutputType({
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory SubcriptionGroupByOutputType.fromJson(Map json) =>
      SubcriptionGroupByOutputType(
        id: json['id'],
        name: json['name'],
        price: json['price'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        $count: json['_count'] is Map
            ? _i2.SubcriptionCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.SubcriptionAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.SubcriptionSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.SubcriptionMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SubcriptionMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? name;

  final _i1.Decimal? price;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.SubcriptionCountAggregateOutputType? $count;

  final _i2.SubcriptionAvgAggregateOutputType? $avg;

  final _i2.SubcriptionSumAggregateOutputType? $sum;

  final _i2.SubcriptionMinAggregateOutputType? $min;

  final _i2.SubcriptionMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class SubcriptionCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionCountOrderByAggregateInput({
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? price;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class SubcriptionAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionAvgOrderByAggregateInput({
    this.id,
    this.price,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? price;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'price': price,
      };
}

class SubcriptionMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionMaxOrderByAggregateInput({
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? price;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class SubcriptionMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionMinOrderByAggregateInput({
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? price;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class SubcriptionSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionSumOrderByAggregateInput({
    this.id,
    this.price,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? price;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'price': price,
      };
}

class SubcriptionOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionOrderByWithAggregationInput({
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? price;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i2.SubcriptionCountOrderByAggregateInput? $count;

  final _i2.SubcriptionAvgOrderByAggregateInput? $avg;

  final _i2.SubcriptionMaxOrderByAggregateInput? $max;

  final _i2.SubcriptionMinOrderByAggregateInput? $min;

  final _i2.SubcriptionSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class SubcriptionScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.SubcriptionScalarWhereWithAggregatesInput,
      Iterable<_i2.SubcriptionScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.SubcriptionScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.SubcriptionScalarWhereWithAggregatesInput,
      Iterable<_i2.SubcriptionScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.DecimalNullableWithAggregatesFilter,
      _i1.PrismaUnion<_i1.Decimal, _i1.PrismaNull>>? price;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class SubcriptionCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionCountAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? name;

  final bool? price;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class SubcriptionGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionGroupByOutputTypeCountArgs({this.select});

  final _i2.SubcriptionCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubcriptionAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionAvgAggregateOutputTypeSelect({
    this.id,
    this.price,
  });

  final bool? id;

  final bool? price;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'price': price,
      };
}

class SubcriptionGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionGroupByOutputTypeAvgArgs({this.select});

  final _i2.SubcriptionAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubcriptionSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionSumAggregateOutputTypeSelect({
    this.id,
    this.price,
  });

  final bool? id;

  final bool? price;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'price': price,
      };
}

class SubcriptionGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionGroupByOutputTypeSumArgs({this.select});

  final _i2.SubcriptionSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubcriptionMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionMinAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? price;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class SubcriptionGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionGroupByOutputTypeMinArgs({this.select});

  final _i2.SubcriptionMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubcriptionMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionMaxAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? price;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class SubcriptionGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionGroupByOutputTypeMaxArgs({this.select});

  final _i2.SubcriptionMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SubcriptionGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SubcriptionGroupByOutputTypeSelect({
    this.id,
    this.name,
    this.price,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? name;

  final bool? price;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.SubcriptionGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.SubcriptionGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.SubcriptionGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.SubcriptionGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.SubcriptionGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'price': price,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateSubcription {
  const AggregateSubcription({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateSubcription.fromJson(Map json) => AggregateSubcription(
        $count: json['_count'] is Map
            ? _i2.SubcriptionCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.SubcriptionAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.SubcriptionSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.SubcriptionMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SubcriptionMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.SubcriptionCountAggregateOutputType? $count;

  final _i2.SubcriptionAvgAggregateOutputType? $avg;

  final _i2.SubcriptionSumAggregateOutputType? $sum;

  final _i2.SubcriptionMinAggregateOutputType? $min;

  final _i2.SubcriptionMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateSubcriptionCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubcriptionCountArgs({this.select});

  final _i2.SubcriptionCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSubcriptionAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubcriptionAvgArgs({this.select});

  final _i2.SubcriptionAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSubcriptionSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubcriptionSumArgs({this.select});

  final _i2.SubcriptionSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSubcriptionMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubcriptionMinArgs({this.select});

  final _i2.SubcriptionMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSubcriptionMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubcriptionMaxArgs({this.select});

  final _i2.SubcriptionMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSubcriptionSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSubcriptionSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateSubcriptionCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateSubcriptionAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateSubcriptionSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateSubcriptionMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateSubcriptionMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class ModulesWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  final _i1.PrismaUnion<_i2.ModulesWhereInput, Iterable<_i2.ModulesWhereInput>>?
      AND;

  final Iterable<_i2.ModulesWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ModulesWhereInput, Iterable<_i2.ModulesWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? moduleName;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      storeCount;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? icon;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? description;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

class ModulesWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.ModulesWhereInput, Iterable<_i2.ModulesWhereInput>>?
      AND;

  final Iterable<_i2.ModulesWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ModulesWhereInput, Iterable<_i2.ModulesWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? moduleName;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      storeCount;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? icon;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? description;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

class ModulesSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesSelect({
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  final bool? id;

  final bool? moduleName;

  final bool? urlImagen;

  final bool? status;

  final bool? storeCount;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? icon;

  final bool? description;

  final bool? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

class ModulesOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesOrderByWithRelationInput({
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? moduleName;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? urlImagen;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? storeCount;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? icon;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? description;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

enum ModulesScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Modules'),
  moduleName<String>('module_name', 'Modules'),
  urlImagen<String>('url_imagen', 'Modules'),
  status<bool>('status', 'Modules'),
  storeCount<int>('store_count', 'Modules'),
  createdAt<DateTime>('created_at', 'Modules'),
  updatedAt<DateTime>('updated_at', 'Modules'),
  icon<String>('icon', 'Modules'),
  description<String>('description', 'Modules'),
  allZoneServices<int>('all_zone_services', 'Modules');

  const ModulesScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ModulesCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesCreateInput({
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduleName;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? urlImagen;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? storeCount;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? icon;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

class ModulesUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesUncheckedCreateInput({
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduleName;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? urlImagen;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? storeCount;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? icon;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

class ModulesCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesCreateManyInput({
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? moduleName;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? urlImagen;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? storeCount;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? icon;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? description;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

class ModulesUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesUpdateInput({
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduleName;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? storeCount;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? icon;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

class ModulesUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesUncheckedUpdateInput({
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduleName;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? storeCount;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? icon;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

class ModulesUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesUpdateManyMutationInput({
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduleName;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? storeCount;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? icon;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

class ModulesUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesUncheckedUpdateManyInput({
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduleName;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? storeCount;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? icon;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

class ModulesCountAggregateOutputType {
  const ModulesCountAggregateOutputType({
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
    this.$all,
  });

  factory ModulesCountAggregateOutputType.fromJson(Map json) =>
      ModulesCountAggregateOutputType(
        id: json['id'],
        moduleName: json['module_name'],
        urlImagen: json['url_imagen'],
        status: json['status'],
        storeCount: json['store_count'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        icon: json['icon'],
        description: json['description'],
        allZoneServices: json['all_zone_services'],
        $all: json['_all'],
      );

  final int? id;

  final int? moduleName;

  final int? urlImagen;

  final int? status;

  final int? storeCount;

  final int? createdAt;

  final int? updatedAt;

  final int? icon;

  final int? description;

  final int? allZoneServices;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
        '_all': $all,
      };
}

class ModulesAvgAggregateOutputType {
  const ModulesAvgAggregateOutputType({
    this.id,
    this.storeCount,
    this.allZoneServices,
  });

  factory ModulesAvgAggregateOutputType.fromJson(Map json) =>
      ModulesAvgAggregateOutputType(
        id: json['id'],
        storeCount: json['store_count'],
        allZoneServices: json['all_zone_services'],
      );

  final double? id;

  final double? storeCount;

  final double? allZoneServices;

  Map<String, dynamic> toJson() => {
        'id': id,
        'store_count': storeCount,
        'all_zone_services': allZoneServices,
      };
}

class ModulesSumAggregateOutputType {
  const ModulesSumAggregateOutputType({
    this.id,
    this.storeCount,
    this.allZoneServices,
  });

  factory ModulesSumAggregateOutputType.fromJson(Map json) =>
      ModulesSumAggregateOutputType(
        id: json['id'],
        storeCount: json['store_count'],
        allZoneServices: json['all_zone_services'],
      );

  final int? id;

  final int? storeCount;

  final int? allZoneServices;

  Map<String, dynamic> toJson() => {
        'id': id,
        'store_count': storeCount,
        'all_zone_services': allZoneServices,
      };
}

class ModulesMinAggregateOutputType {
  const ModulesMinAggregateOutputType({
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  factory ModulesMinAggregateOutputType.fromJson(Map json) =>
      ModulesMinAggregateOutputType(
        id: json['id'],
        moduleName: json['module_name'],
        urlImagen: json['url_imagen'],
        status: json['status'],
        storeCount: json['store_count'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        icon: json['icon'],
        description: json['description'],
        allZoneServices: json['all_zone_services'],
      );

  final int? id;

  final String? moduleName;

  final String? urlImagen;

  final bool? status;

  final int? storeCount;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final String? icon;

  final String? description;

  final int? allZoneServices;

  Map<String, dynamic> toJson() => {
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

class ModulesMaxAggregateOutputType {
  const ModulesMaxAggregateOutputType({
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  factory ModulesMaxAggregateOutputType.fromJson(Map json) =>
      ModulesMaxAggregateOutputType(
        id: json['id'],
        moduleName: json['module_name'],
        urlImagen: json['url_imagen'],
        status: json['status'],
        storeCount: json['store_count'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        icon: json['icon'],
        description: json['description'],
        allZoneServices: json['all_zone_services'],
      );

  final int? id;

  final String? moduleName;

  final String? urlImagen;

  final bool? status;

  final int? storeCount;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final String? icon;

  final String? description;

  final int? allZoneServices;

  Map<String, dynamic> toJson() => {
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

class ModulesGroupByOutputType {
  const ModulesGroupByOutputType({
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ModulesGroupByOutputType.fromJson(Map json) =>
      ModulesGroupByOutputType(
        id: json['id'],
        moduleName: json['module_name'],
        urlImagen: json['url_imagen'],
        status: json['status'],
        storeCount: json['store_count'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        icon: json['icon'],
        description: json['description'],
        allZoneServices: json['all_zone_services'],
        $count: json['_count'] is Map
            ? _i2.ModulesCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ModulesAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ModulesSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ModulesMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ModulesMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? moduleName;

  final String? urlImagen;

  final bool? status;

  final int? storeCount;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final String? icon;

  final String? description;

  final int? allZoneServices;

  final _i2.ModulesCountAggregateOutputType? $count;

  final _i2.ModulesAvgAggregateOutputType? $avg;

  final _i2.ModulesSumAggregateOutputType? $sum;

  final _i2.ModulesMinAggregateOutputType? $min;

  final _i2.ModulesMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class ModulesCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesCountOrderByAggregateInput({
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? moduleName;

  final _i2.SortOrder? urlImagen;

  final _i2.SortOrder? status;

  final _i2.SortOrder? storeCount;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SortOrder? icon;

  final _i2.SortOrder? description;

  final _i2.SortOrder? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

class ModulesAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesAvgOrderByAggregateInput({
    this.id,
    this.storeCount,
    this.allZoneServices,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? storeCount;

  final _i2.SortOrder? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'store_count': storeCount,
        'all_zone_services': allZoneServices,
      };
}

class ModulesMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesMaxOrderByAggregateInput({
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? moduleName;

  final _i2.SortOrder? urlImagen;

  final _i2.SortOrder? status;

  final _i2.SortOrder? storeCount;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SortOrder? icon;

  final _i2.SortOrder? description;

  final _i2.SortOrder? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

class ModulesMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesMinOrderByAggregateInput({
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? moduleName;

  final _i2.SortOrder? urlImagen;

  final _i2.SortOrder? status;

  final _i2.SortOrder? storeCount;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SortOrder? icon;

  final _i2.SortOrder? description;

  final _i2.SortOrder? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

class ModulesSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesSumOrderByAggregateInput({
    this.id,
    this.storeCount,
    this.allZoneServices,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? storeCount;

  final _i2.SortOrder? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'store_count': storeCount,
        'all_zone_services': allZoneServices,
      };
}

class ModulesOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesOrderByWithAggregationInput({
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? moduleName;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? urlImagen;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? storeCount;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? icon;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? description;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? allZoneServices;

  final _i2.ModulesCountOrderByAggregateInput? $count;

  final _i2.ModulesAvgOrderByAggregateInput? $avg;

  final _i2.ModulesMaxOrderByAggregateInput? $max;

  final _i2.ModulesMinOrderByAggregateInput? $min;

  final _i2.ModulesSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class ModulesScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  final _i1.PrismaUnion<_i2.ModulesScalarWhereWithAggregatesInput,
      Iterable<_i2.ModulesScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ModulesScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ModulesScalarWhereWithAggregatesInput,
      Iterable<_i2.ModulesScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? moduleName;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<_i2.BoolNullableWithAggregatesFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? storeCount;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? icon;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? description;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

class ModulesCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesCountAggregateOutputTypeSelect({
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
    this.$all,
  });

  final bool? id;

  final bool? moduleName;

  final bool? urlImagen;

  final bool? status;

  final bool? storeCount;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? icon;

  final bool? description;

  final bool? allZoneServices;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
        '_all': $all,
      };
}

class ModulesGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesGroupByOutputTypeCountArgs({this.select});

  final _i2.ModulesCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ModulesAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesAvgAggregateOutputTypeSelect({
    this.id,
    this.storeCount,
    this.allZoneServices,
  });

  final bool? id;

  final bool? storeCount;

  final bool? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'store_count': storeCount,
        'all_zone_services': allZoneServices,
      };
}

class ModulesGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesGroupByOutputTypeAvgArgs({this.select});

  final _i2.ModulesAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ModulesSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesSumAggregateOutputTypeSelect({
    this.id,
    this.storeCount,
    this.allZoneServices,
  });

  final bool? id;

  final bool? storeCount;

  final bool? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'store_count': storeCount,
        'all_zone_services': allZoneServices,
      };
}

class ModulesGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesGroupByOutputTypeSumArgs({this.select});

  final _i2.ModulesSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ModulesMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesMinAggregateOutputTypeSelect({
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  final bool? id;

  final bool? moduleName;

  final bool? urlImagen;

  final bool? status;

  final bool? storeCount;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? icon;

  final bool? description;

  final bool? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

class ModulesGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesGroupByOutputTypeMinArgs({this.select});

  final _i2.ModulesMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ModulesMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesMaxAggregateOutputTypeSelect({
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
  });

  final bool? id;

  final bool? moduleName;

  final bool? urlImagen;

  final bool? status;

  final bool? storeCount;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? icon;

  final bool? description;

  final bool? allZoneServices;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
      };
}

class ModulesGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesGroupByOutputTypeMaxArgs({this.select});

  final _i2.ModulesMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ModulesGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ModulesGroupByOutputTypeSelect({
    this.id,
    this.moduleName,
    this.urlImagen,
    this.status,
    this.storeCount,
    this.createdAt,
    this.updatedAt,
    this.icon,
    this.description,
    this.allZoneServices,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? moduleName;

  final bool? urlImagen;

  final bool? status;

  final bool? storeCount;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? icon;

  final bool? description;

  final bool? allZoneServices;

  final _i1.PrismaUnion<bool, _i2.ModulesGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.ModulesGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.ModulesGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.ModulesGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.ModulesGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'module_name': moduleName,
        'url_imagen': urlImagen,
        'status': status,
        'store_count': storeCount,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'icon': icon,
        'description': description,
        'all_zone_services': allZoneServices,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateModules {
  const AggregateModules({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateModules.fromJson(Map json) => AggregateModules(
        $count: json['_count'] is Map
            ? _i2.ModulesCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ModulesAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ModulesSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ModulesMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ModulesMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ModulesCountAggregateOutputType? $count;

  final _i2.ModulesAvgAggregateOutputType? $avg;

  final _i2.ModulesSumAggregateOutputType? $sum;

  final _i2.ModulesMinAggregateOutputType? $min;

  final _i2.ModulesMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateModulesCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateModulesCountArgs({this.select});

  final _i2.ModulesCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateModulesAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateModulesAvgArgs({this.select});

  final _i2.ModulesAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateModulesSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateModulesSumArgs({this.select});

  final _i2.ModulesSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateModulesMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateModulesMinArgs({this.select});

  final _i2.ModulesMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateModulesMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateModulesMaxArgs({this.select});

  final _i2.ModulesMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateModulesSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateModulesSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateModulesCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateModulesAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateModulesSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateModulesMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateModulesMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class CategoryWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1
      .PrismaUnion<_i2.CategoryWhereInput, Iterable<_i2.CategoryWhereInput>>?
      AND;

  final Iterable<_i2.CategoryWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.CategoryWhereInput, Iterable<_i2.CategoryWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      moduleId;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class CategoryWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1
      .PrismaUnion<_i2.CategoryWhereInput, Iterable<_i2.CategoryWhereInput>>?
      AND;

  final Iterable<_i2.CategoryWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.CategoryWhereInput, Iterable<_i2.CategoryWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      moduleId;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class CategorySelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategorySelect({
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? urlImagen;

  final bool? status;

  final bool? moduleId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class CategoryOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryOrderByWithRelationInput({
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? urlImagen;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? moduleId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

enum CategoryScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Category'),
  name$<String>('name', 'Category'),
  urlImagen<String>('url_imagen', 'Category'),
  status<bool>('status', 'Category'),
  moduleId<int>('module_id', 'Category'),
  createdAt<DateTime>('created_at', 'Category'),
  updatedAt<DateTime>('updated_at', 'Category');

  const CategoryScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class CategoryCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCreateInput({
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? urlImagen;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? moduleId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class CategoryUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUncheckedCreateInput({
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? urlImagen;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? moduleId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class CategoryCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCreateManyInput({
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? urlImagen;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? moduleId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class CategoryUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUpdateInput({
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduleId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class CategoryUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUncheckedUpdateInput({
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduleId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class CategoryUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUpdateManyMutationInput({
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduleId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class CategoryUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryUncheckedUpdateManyInput({
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? moduleId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class CategoryCountAggregateOutputType {
  const CategoryCountAggregateOutputType({
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory CategoryCountAggregateOutputType.fromJson(Map json) =>
      CategoryCountAggregateOutputType(
        id: json['id'],
        name: json['name'],
        urlImagen: json['url_imagen'],
        status: json['status'],
        moduleId: json['module_id'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? name;

  final int? urlImagen;

  final int? status;

  final int? moduleId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class CategoryAvgAggregateOutputType {
  const CategoryAvgAggregateOutputType({
    this.id,
    this.moduleId,
  });

  factory CategoryAvgAggregateOutputType.fromJson(Map json) =>
      CategoryAvgAggregateOutputType(
        id: json['id'],
        moduleId: json['module_id'],
      );

  final double? id;

  final double? moduleId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'module_id': moduleId,
      };
}

class CategorySumAggregateOutputType {
  const CategorySumAggregateOutputType({
    this.id,
    this.moduleId,
  });

  factory CategorySumAggregateOutputType.fromJson(Map json) =>
      CategorySumAggregateOutputType(
        id: json['id'],
        moduleId: json['module_id'],
      );

  final int? id;

  final int? moduleId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'module_id': moduleId,
      };
}

class CategoryMinAggregateOutputType {
  const CategoryMinAggregateOutputType({
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  factory CategoryMinAggregateOutputType.fromJson(Map json) =>
      CategoryMinAggregateOutputType(
        id: json['id'],
        name: json['name'],
        urlImagen: json['url_imagen'],
        status: json['status'],
        moduleId: json['module_id'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final String? name;

  final String? urlImagen;

  final bool? status;

  final int? moduleId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class CategoryMaxAggregateOutputType {
  const CategoryMaxAggregateOutputType({
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  factory CategoryMaxAggregateOutputType.fromJson(Map json) =>
      CategoryMaxAggregateOutputType(
        id: json['id'],
        name: json['name'],
        urlImagen: json['url_imagen'],
        status: json['status'],
        moduleId: json['module_id'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final String? name;

  final String? urlImagen;

  final bool? status;

  final int? moduleId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class CategoryGroupByOutputType {
  const CategoryGroupByOutputType({
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory CategoryGroupByOutputType.fromJson(Map json) =>
      CategoryGroupByOutputType(
        id: json['id'],
        name: json['name'],
        urlImagen: json['url_imagen'],
        status: json['status'],
        moduleId: json['module_id'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        $count: json['_count'] is Map
            ? _i2.CategoryCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.CategoryAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.CategorySumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.CategoryMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.CategoryMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? name;

  final String? urlImagen;

  final bool? status;

  final int? moduleId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.CategoryCountAggregateOutputType? $count;

  final _i2.CategoryAvgAggregateOutputType? $avg;

  final _i2.CategorySumAggregateOutputType? $sum;

  final _i2.CategoryMinAggregateOutputType? $min;

  final _i2.CategoryMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class CategoryCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCountOrderByAggregateInput({
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? urlImagen;

  final _i2.SortOrder? status;

  final _i2.SortOrder? moduleId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class CategoryAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryAvgOrderByAggregateInput({
    this.id,
    this.moduleId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? moduleId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'module_id': moduleId,
      };
}

class CategoryMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryMaxOrderByAggregateInput({
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? urlImagen;

  final _i2.SortOrder? status;

  final _i2.SortOrder? moduleId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class CategoryMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryMinOrderByAggregateInput({
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? urlImagen;

  final _i2.SortOrder? status;

  final _i2.SortOrder? moduleId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class CategorySumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategorySumOrderByAggregateInput({
    this.id,
    this.moduleId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? moduleId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'module_id': moduleId,
      };
}

class CategoryOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryOrderByWithAggregationInput({
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? urlImagen;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? moduleId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i2.CategoryCountOrderByAggregateInput? $count;

  final _i2.CategoryAvgOrderByAggregateInput? $avg;

  final _i2.CategoryMaxOrderByAggregateInput? $max;

  final _i2.CategoryMinOrderByAggregateInput? $min;

  final _i2.CategorySumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class CategoryScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.CategoryScalarWhereWithAggregatesInput,
      Iterable<_i2.CategoryScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.CategoryScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.CategoryScalarWhereWithAggregatesInput,
      Iterable<_i2.CategoryScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<_i2.BoolNullableWithAggregatesFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? moduleId;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class CategoryCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryCountAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? name;

  final bool? urlImagen;

  final bool? status;

  final bool? moduleId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class CategoryGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryGroupByOutputTypeCountArgs({this.select});

  final _i2.CategoryCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CategoryAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryAvgAggregateOutputTypeSelect({
    this.id,
    this.moduleId,
  });

  final bool? id;

  final bool? moduleId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'module_id': moduleId,
      };
}

class CategoryGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryGroupByOutputTypeAvgArgs({this.select});

  final _i2.CategoryAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CategorySumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategorySumAggregateOutputTypeSelect({
    this.id,
    this.moduleId,
  });

  final bool? id;

  final bool? moduleId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'module_id': moduleId,
      };
}

class CategoryGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryGroupByOutputTypeSumArgs({this.select});

  final _i2.CategorySumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CategoryMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryMinAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? urlImagen;

  final bool? status;

  final bool? moduleId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class CategoryGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryGroupByOutputTypeMinArgs({this.select});

  final _i2.CategoryMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CategoryMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryMaxAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? urlImagen;

  final bool? status;

  final bool? moduleId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class CategoryGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryGroupByOutputTypeMaxArgs({this.select});

  final _i2.CategoryMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class CategoryGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const CategoryGroupByOutputTypeSelect({
    this.id,
    this.name,
    this.urlImagen,
    this.status,
    this.moduleId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? name;

  final bool? urlImagen;

  final bool? status;

  final bool? moduleId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.CategoryGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.CategoryGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.CategoryGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.CategoryGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.CategoryGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'url_imagen': urlImagen,
        'status': status,
        'module_id': moduleId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateCategory {
  const AggregateCategory({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateCategory.fromJson(Map json) => AggregateCategory(
        $count: json['_count'] is Map
            ? _i2.CategoryCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.CategoryAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.CategorySumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.CategoryMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.CategoryMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.CategoryCountAggregateOutputType? $count;

  final _i2.CategoryAvgAggregateOutputType? $avg;

  final _i2.CategorySumAggregateOutputType? $sum;

  final _i2.CategoryMinAggregateOutputType? $min;

  final _i2.CategoryMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateCategoryCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCategoryCountArgs({this.select});

  final _i2.CategoryCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCategoryAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCategoryAvgArgs({this.select});

  final _i2.CategoryAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCategorySumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCategorySumArgs({this.select});

  final _i2.CategorySumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCategoryMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCategoryMinArgs({this.select});

  final _i2.CategoryMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCategoryMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCategoryMaxArgs({this.select});

  final _i2.CategoryMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateCategorySelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateCategorySelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateCategoryCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateCategoryAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateCategorySumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateCategoryMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateCategoryMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

enum JsonNullValueFilter implements _i1.PrismaEnum {
  dbNull._('DbNull'),
  jsonNull._('JsonNull'),
  anyNull._('AnyNull');

  const JsonNullValueFilter._(this.name);

  @override
  final String name;
}

class JsonNullableFilter implements _i1.JsonConvertible<Map<String, dynamic>> {
  const JsonNullableFilter({
    this.equals,
    this.path,
    this.stringContains,
    this.stringStartsWith,
    this.stringEndsWith,
    this.arrayContains,
    this.arrayStartsWith,
    this.arrayEndsWith,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<
          _i1.PrismaJson,
          _i1
          .PrismaUnion<_i1.Reference<_i1.PrismaJson>, _i2.JsonNullValueFilter>>?
      equals;

  final String? path;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? stringContains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? stringStartsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? stringEndsWith;

  final _i1.PrismaUnion<_i1.PrismaJson,
          _i1.PrismaUnion<_i1.Reference<_i1.PrismaJson>, _i1.PrismaNull>>?
      arrayContains;

  final _i1.PrismaUnion<_i1.PrismaJson,
          _i1.PrismaUnion<_i1.Reference<_i1.PrismaJson>, _i1.PrismaNull>>?
      arrayStartsWith;

  final _i1.PrismaUnion<_i1.PrismaJson,
          _i1.PrismaUnion<_i1.Reference<_i1.PrismaJson>, _i1.PrismaNull>>?
      arrayEndsWith;

  final _i1.PrismaJson? lt;

  final _i1.PrismaJson? lte;

  final _i1.PrismaJson? gt;

  final _i1.PrismaJson? gte;

  final _i1.PrismaUnion<
          _i1.PrismaJson,
          _i1
          .PrismaUnion<_i1.Reference<_i1.PrismaJson>, _i2.JsonNullValueFilter>>?
      not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'path': path,
        'string_contains': stringContains,
        'string_starts_with': stringStartsWith,
        'string_ends_with': stringEndsWith,
        'array_contains': arrayContains,
        'array_starts_with': arrayStartsWith,
        'array_ends_with': arrayEndsWith,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class ZonesWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.coordinates,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.ZonesWhereInput, Iterable<_i2.ZonesWhereInput>>?
      AND;

  final Iterable<_i2.ZonesWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ZonesWhereInput, Iterable<_i2.ZonesWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i2.JsonNullableFilter? coordinates;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'coordinates': coordinates,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class ZonesWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.coordinates,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.ZonesWhereInput, Iterable<_i2.ZonesWhereInput>>?
      AND;

  final Iterable<_i2.ZonesWhereInput>? OR;

  final _i1.PrismaUnion<_i2.ZonesWhereInput, Iterable<_i2.ZonesWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i2.JsonNullableFilter? coordinates;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'name': name,
        'coordinates': coordinates,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class ZonesSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesSelect({
    this.id,
    this.name,
    this.coordinates,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? coordinates;

  final bool? status;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'coordinates': coordinates,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class ZonesOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesOrderByWithRelationInput({
    this.id,
    this.name,
    this.coordinates,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? coordinates;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'coordinates': coordinates,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

enum ZonesScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Zones'),
  name$<String>('name', 'Zones'),
  coordinates<_i1.PrismaJson>('coordinates', 'Zones'),
  status<bool>('status', 'Zones'),
  createdAt<DateTime>('created_at', 'Zones'),
  updatedAt<DateTime>('updated_at', 'Zones');

  const ZonesScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

enum NullableJsonNullValueInput implements _i1.PrismaEnum {
  dbNull._('DbNull'),
  jsonNull._('JsonNull');

  const NullableJsonNullValueInput._(this.name);

  @override
  final String name;
}

class ZonesCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesCreateInput({
    this.name,
    this.coordinates,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
      coordinates;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'coordinates': coordinates,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class ZonesUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesUncheckedCreateInput({
    this.id,
    this.name,
    this.coordinates,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
      coordinates;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'coordinates': coordinates,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class ZonesCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesCreateManyInput({
    this.id,
    this.name,
    this.coordinates,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
      coordinates;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? status;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'coordinates': coordinates,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class ZonesUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesUpdateInput({
    this.name,
    this.coordinates,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
      coordinates;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'coordinates': coordinates,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class ZonesUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesUncheckedUpdateInput({
    this.id,
    this.name,
    this.coordinates,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
      coordinates;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'coordinates': coordinates,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class ZonesUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesUpdateManyMutationInput({
    this.name,
    this.coordinates,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
      coordinates;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'coordinates': coordinates,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class ZonesUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesUncheckedUpdateManyInput({
    this.id,
    this.name,
    this.coordinates,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.NullableJsonNullValueInput, _i1.PrismaJson>?
      coordinates;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'coordinates': coordinates,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class ZonesCountAggregateOutputType {
  const ZonesCountAggregateOutputType({
    this.id,
    this.name,
    this.coordinates,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory ZonesCountAggregateOutputType.fromJson(Map json) =>
      ZonesCountAggregateOutputType(
        id: json['id'],
        name: json['name'],
        coordinates: json['coordinates'],
        status: json['status'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? name;

  final int? coordinates;

  final int? status;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'coordinates': coordinates,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class ZonesAvgAggregateOutputType {
  const ZonesAvgAggregateOutputType({this.id});

  factory ZonesAvgAggregateOutputType.fromJson(Map json) =>
      ZonesAvgAggregateOutputType(id: json['id']);

  final double? id;

  Map<String, dynamic> toJson() => {'id': id};
}

class ZonesSumAggregateOutputType {
  const ZonesSumAggregateOutputType({this.id});

  factory ZonesSumAggregateOutputType.fromJson(Map json) =>
      ZonesSumAggregateOutputType(id: json['id']);

  final int? id;

  Map<String, dynamic> toJson() => {'id': id};
}

class ZonesMinAggregateOutputType {
  const ZonesMinAggregateOutputType({
    this.id,
    this.name,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  factory ZonesMinAggregateOutputType.fromJson(Map json) =>
      ZonesMinAggregateOutputType(
        id: json['id'],
        name: json['name'],
        status: json['status'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final String? name;

  final bool? status;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'status': status,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class ZonesMaxAggregateOutputType {
  const ZonesMaxAggregateOutputType({
    this.id,
    this.name,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  factory ZonesMaxAggregateOutputType.fromJson(Map json) =>
      ZonesMaxAggregateOutputType(
        id: json['id'],
        name: json['name'],
        status: json['status'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final String? name;

  final bool? status;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'status': status,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class ZonesGroupByOutputType {
  const ZonesGroupByOutputType({
    this.id,
    this.name,
    this.coordinates,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ZonesGroupByOutputType.fromJson(Map json) => ZonesGroupByOutputType(
        id: json['id'],
        name: json['name'],
        coordinates: json['coordinates'],
        status: json['status'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        $count: json['_count'] is Map
            ? _i2.ZonesCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ZonesAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ZonesSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ZonesMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ZonesMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? name;

  final Object? coordinates;

  final bool? status;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.ZonesCountAggregateOutputType? $count;

  final _i2.ZonesAvgAggregateOutputType? $avg;

  final _i2.ZonesSumAggregateOutputType? $sum;

  final _i2.ZonesMinAggregateOutputType? $min;

  final _i2.ZonesMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'coordinates': coordinates,
        'status': status,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class ZonesCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesCountOrderByAggregateInput({
    this.id,
    this.name,
    this.coordinates,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? coordinates;

  final _i2.SortOrder? status;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'coordinates': coordinates,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class ZonesAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesAvgOrderByAggregateInput({this.id});

  final _i2.SortOrder? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class ZonesMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesMaxOrderByAggregateInput({
    this.id,
    this.name,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? status;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class ZonesMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesMinOrderByAggregateInput({
    this.id,
    this.name,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? status;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class ZonesSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesSumOrderByAggregateInput({this.id});

  final _i2.SortOrder? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class ZonesOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesOrderByWithAggregationInput({
    this.id,
    this.name,
    this.coordinates,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? coordinates;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? status;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i2.ZonesCountOrderByAggregateInput? $count;

  final _i2.ZonesAvgOrderByAggregateInput? $avg;

  final _i2.ZonesMaxOrderByAggregateInput? $max;

  final _i2.ZonesMinOrderByAggregateInput? $min;

  final _i2.ZonesSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'coordinates': coordinates,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class NestedJsonNullableFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const NestedJsonNullableFilter({
    this.equals,
    this.path,
    this.stringContains,
    this.stringStartsWith,
    this.stringEndsWith,
    this.arrayContains,
    this.arrayStartsWith,
    this.arrayEndsWith,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
  });

  final _i1.PrismaUnion<
          _i1.PrismaJson,
          _i1
          .PrismaUnion<_i1.Reference<_i1.PrismaJson>, _i2.JsonNullValueFilter>>?
      equals;

  final String? path;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? stringContains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? stringStartsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? stringEndsWith;

  final _i1.PrismaUnion<_i1.PrismaJson,
          _i1.PrismaUnion<_i1.Reference<_i1.PrismaJson>, _i1.PrismaNull>>?
      arrayContains;

  final _i1.PrismaUnion<_i1.PrismaJson,
          _i1.PrismaUnion<_i1.Reference<_i1.PrismaJson>, _i1.PrismaNull>>?
      arrayStartsWith;

  final _i1.PrismaUnion<_i1.PrismaJson,
          _i1.PrismaUnion<_i1.Reference<_i1.PrismaJson>, _i1.PrismaNull>>?
      arrayEndsWith;

  final _i1.PrismaJson? lt;

  final _i1.PrismaJson? lte;

  final _i1.PrismaJson? gt;

  final _i1.PrismaJson? gte;

  final _i1.PrismaUnion<
          _i1.PrismaJson,
          _i1
          .PrismaUnion<_i1.Reference<_i1.PrismaJson>, _i2.JsonNullValueFilter>>?
      not;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'path': path,
        'string_contains': stringContains,
        'string_starts_with': stringStartsWith,
        'string_ends_with': stringEndsWith,
        'array_contains': arrayContains,
        'array_starts_with': arrayStartsWith,
        'array_ends_with': arrayEndsWith,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
      };
}

class JsonNullableWithAggregatesFilter
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const JsonNullableWithAggregatesFilter({
    this.equals,
    this.path,
    this.stringContains,
    this.stringStartsWith,
    this.stringEndsWith,
    this.arrayContains,
    this.arrayStartsWith,
    this.arrayEndsWith,
    this.lt,
    this.lte,
    this.gt,
    this.gte,
    this.not,
    this.$count,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<
          _i1.PrismaJson,
          _i1
          .PrismaUnion<_i1.Reference<_i1.PrismaJson>, _i2.JsonNullValueFilter>>?
      equals;

  final String? path;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? stringContains;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? stringStartsWith;

  final _i1.PrismaUnion<String, _i1.Reference<String>>? stringEndsWith;

  final _i1.PrismaUnion<_i1.PrismaJson,
          _i1.PrismaUnion<_i1.Reference<_i1.PrismaJson>, _i1.PrismaNull>>?
      arrayContains;

  final _i1.PrismaUnion<_i1.PrismaJson,
          _i1.PrismaUnion<_i1.Reference<_i1.PrismaJson>, _i1.PrismaNull>>?
      arrayStartsWith;

  final _i1.PrismaUnion<_i1.PrismaJson,
          _i1.PrismaUnion<_i1.Reference<_i1.PrismaJson>, _i1.PrismaNull>>?
      arrayEndsWith;

  final _i1.PrismaJson? lt;

  final _i1.PrismaJson? lte;

  final _i1.PrismaJson? gt;

  final _i1.PrismaJson? gte;

  final _i1.PrismaUnion<
          _i1.PrismaJson,
          _i1
          .PrismaUnion<_i1.Reference<_i1.PrismaJson>, _i2.JsonNullValueFilter>>?
      not;

  final _i2.NestedIntNullableFilter? $count;

  final _i2.NestedJsonNullableFilter? $min;

  final _i2.NestedJsonNullableFilter? $max;

  @override
  Map<String, dynamic> toJson() => {
        'equals': equals,
        'path': path,
        'string_contains': stringContains,
        'string_starts_with': stringStartsWith,
        'string_ends_with': stringEndsWith,
        'array_contains': arrayContains,
        'array_starts_with': arrayStartsWith,
        'array_ends_with': arrayEndsWith,
        'lt': lt,
        'lte': lte,
        'gt': gt,
        'gte': gte,
        'not': not,
        '_count': $count,
        '_min': $min,
        '_max': $max,
      };
}

class ZonesScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.coordinates,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.ZonesScalarWhereWithAggregatesInput,
      Iterable<_i2.ZonesScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ZonesScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ZonesScalarWhereWithAggregatesInput,
      Iterable<_i2.ZonesScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i2.JsonNullableWithAggregatesFilter? coordinates;

  final _i1.PrismaUnion<_i2.BoolNullableWithAggregatesFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? status;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'coordinates': coordinates,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class ZonesCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesCountAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.coordinates,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? name;

  final bool? coordinates;

  final bool? status;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'coordinates': coordinates,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class ZonesGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesGroupByOutputTypeCountArgs({this.select});

  final _i2.ZonesCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ZonesAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesAvgAggregateOutputTypeSelect({this.id});

  final bool? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class ZonesGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesGroupByOutputTypeAvgArgs({this.select});

  final _i2.ZonesAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ZonesSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesSumAggregateOutputTypeSelect({this.id});

  final bool? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class ZonesGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesGroupByOutputTypeSumArgs({this.select});

  final _i2.ZonesSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ZonesMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesMinAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? status;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class ZonesGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesGroupByOutputTypeMinArgs({this.select});

  final _i2.ZonesMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ZonesMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesMaxAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.status,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? name;

  final bool? status;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class ZonesGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesGroupByOutputTypeMaxArgs({this.select});

  final _i2.ZonesMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ZonesGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ZonesGroupByOutputTypeSelect({
    this.id,
    this.name,
    this.coordinates,
    this.status,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? name;

  final bool? coordinates;

  final bool? status;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.ZonesGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.ZonesGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.ZonesGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.ZonesGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.ZonesGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'coordinates': coordinates,
        'status': status,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateZones {
  const AggregateZones({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateZones.fromJson(Map json) => AggregateZones(
        $count: json['_count'] is Map
            ? _i2.ZonesCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ZonesAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ZonesSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ZonesMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ZonesMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ZonesCountAggregateOutputType? $count;

  final _i2.ZonesAvgAggregateOutputType? $avg;

  final _i2.ZonesSumAggregateOutputType? $sum;

  final _i2.ZonesMinAggregateOutputType? $min;

  final _i2.ZonesMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateZonesCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateZonesCountArgs({this.select});

  final _i2.ZonesCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateZonesAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateZonesAvgArgs({this.select});

  final _i2.ZonesAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateZonesSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateZonesSumArgs({this.select});

  final _i2.ZonesSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateZonesMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateZonesMinArgs({this.select});

  final _i2.ZonesMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateZonesMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateZonesMaxArgs({this.select});

  final _i2.ZonesMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateZonesSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateZonesSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateZonesCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateZonesAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateZonesSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateZonesMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateZonesMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class SurveysWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  final _i1.PrismaUnion<_i2.SurveysWhereInput, Iterable<_i2.SurveysWhereInput>>?
      AND;

  final Iterable<_i2.SurveysWhereInput>? OR;

  final _i1.PrismaUnion<_i2.SurveysWhereInput, Iterable<_i2.SurveysWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      vendorId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      storeId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? urlImagen;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      categoryId;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? isDeleted;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
      };
}

class SurveysWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.SurveysWhereInput, Iterable<_i2.SurveysWhereInput>>?
      AND;

  final Iterable<_i2.SurveysWhereInput>? OR;

  final _i1.PrismaUnion<_i2.SurveysWhereInput, Iterable<_i2.SurveysWhereInput>>?
      NOT;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      vendorId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      storeId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? urlImagen;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      categoryId;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<_i2.BoolNullableFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? isDeleted;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
      };
}

class SurveysSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysSelect({
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  final bool? id;

  final bool? vendorId;

  final bool? storeId;

  final bool? title;

  final bool? points;

  final bool? urlImagen;

  final bool? categoryId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? isDeleted;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
      };
}

class SurveysOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysOrderByWithRelationInput({
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? vendorId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? storeId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? title;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? points;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? urlImagen;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? categoryId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? isDeleted;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
      };
}

enum SurveysScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Surveys'),
  vendorId<int>('vendor_id', 'Surveys'),
  storeId<int>('store_id', 'Surveys'),
  title<String>('title', 'Surveys'),
  points<String>('points', 'Surveys'),
  urlImagen<String>('url_imagen', 'Surveys'),
  categoryId<int>('category_id', 'Surveys'),
  createdAt<DateTime>('created_at', 'Surveys'),
  updatedAt<DateTime>('updated_at', 'Surveys'),
  isDeleted<bool>('is_deleted', 'Surveys');

  const SurveysScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class SurveysCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysCreateInput({
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  final _i1.PrismaUnion<int, _i1.PrismaNull>? vendorId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? storeId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? points;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? urlImagen;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? categoryId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? isDeleted;

  @override
  Map<String, dynamic> toJson() => {
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
      };
}

class SurveysUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysUncheckedCreateInput({
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  final int? id;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? vendorId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? storeId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? points;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? urlImagen;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? categoryId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? isDeleted;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
      };
}

class SurveysCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysCreateManyInput({
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  final int? id;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? vendorId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? storeId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? title;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? points;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? urlImagen;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? categoryId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  final _i1.PrismaUnion<bool, _i1.PrismaNull>? isDeleted;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
      };
}

class SurveysUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysUpdateInput({
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? storeId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? categoryId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? isDeleted;

  @override
  Map<String, dynamic> toJson() => {
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
      };
}

class SurveysUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysUncheckedUpdateInput({
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? storeId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? categoryId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? isDeleted;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
      };
}

class SurveysUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysUpdateManyMutationInput({
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? storeId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? categoryId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? isDeleted;

  @override
  Map<String, dynamic> toJson() => {
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
      };
}

class SurveysUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysUncheckedUpdateManyInput({
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? storeId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? categoryId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      bool,
      _i1.PrismaUnion<_i2.NullableBoolFieldUpdateOperationsInput,
          _i1.PrismaNull>>? isDeleted;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
      };
}

class SurveysCountAggregateOutputType {
  const SurveysCountAggregateOutputType({
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
    this.$all,
  });

  factory SurveysCountAggregateOutputType.fromJson(Map json) =>
      SurveysCountAggregateOutputType(
        id: json['id'],
        vendorId: json['vendor_id'],
        storeId: json['store_id'],
        title: json['title'],
        points: json['points'],
        urlImagen: json['url_imagen'],
        categoryId: json['category_id'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        isDeleted: json['is_deleted'],
        $all: json['_all'],
      );

  final int? id;

  final int? vendorId;

  final int? storeId;

  final int? title;

  final int? points;

  final int? urlImagen;

  final int? categoryId;

  final int? createdAt;

  final int? updatedAt;

  final int? isDeleted;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
        '_all': $all,
      };
}

class SurveysAvgAggregateOutputType {
  const SurveysAvgAggregateOutputType({
    this.id,
    this.vendorId,
    this.storeId,
    this.categoryId,
  });

  factory SurveysAvgAggregateOutputType.fromJson(Map json) =>
      SurveysAvgAggregateOutputType(
        id: json['id'],
        vendorId: json['vendor_id'],
        storeId: json['store_id'],
        categoryId: json['category_id'],
      );

  final double? id;

  final double? vendorId;

  final double? storeId;

  final double? categoryId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'category_id': categoryId,
      };
}

class SurveysSumAggregateOutputType {
  const SurveysSumAggregateOutputType({
    this.id,
    this.vendorId,
    this.storeId,
    this.categoryId,
  });

  factory SurveysSumAggregateOutputType.fromJson(Map json) =>
      SurveysSumAggregateOutputType(
        id: json['id'],
        vendorId: json['vendor_id'],
        storeId: json['store_id'],
        categoryId: json['category_id'],
      );

  final int? id;

  final int? vendorId;

  final int? storeId;

  final int? categoryId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'category_id': categoryId,
      };
}

class SurveysMinAggregateOutputType {
  const SurveysMinAggregateOutputType({
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  factory SurveysMinAggregateOutputType.fromJson(Map json) =>
      SurveysMinAggregateOutputType(
        id: json['id'],
        vendorId: json['vendor_id'],
        storeId: json['store_id'],
        title: json['title'],
        points: json['points'],
        urlImagen: json['url_imagen'],
        categoryId: json['category_id'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        isDeleted: json['is_deleted'],
      );

  final int? id;

  final int? vendorId;

  final int? storeId;

  final String? title;

  final String? points;

  final String? urlImagen;

  final int? categoryId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final bool? isDeleted;

  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        'is_deleted': isDeleted,
      };
}

class SurveysMaxAggregateOutputType {
  const SurveysMaxAggregateOutputType({
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  factory SurveysMaxAggregateOutputType.fromJson(Map json) =>
      SurveysMaxAggregateOutputType(
        id: json['id'],
        vendorId: json['vendor_id'],
        storeId: json['store_id'],
        title: json['title'],
        points: json['points'],
        urlImagen: json['url_imagen'],
        categoryId: json['category_id'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        isDeleted: json['is_deleted'],
      );

  final int? id;

  final int? vendorId;

  final int? storeId;

  final String? title;

  final String? points;

  final String? urlImagen;

  final int? categoryId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final bool? isDeleted;

  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        'is_deleted': isDeleted,
      };
}

class SurveysGroupByOutputType {
  const SurveysGroupByOutputType({
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory SurveysGroupByOutputType.fromJson(Map json) =>
      SurveysGroupByOutputType(
        id: json['id'],
        vendorId: json['vendor_id'],
        storeId: json['store_id'],
        title: json['title'],
        points: json['points'],
        urlImagen: json['url_imagen'],
        categoryId: json['category_id'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        isDeleted: json['is_deleted'],
        $count: json['_count'] is Map
            ? _i2.SurveysCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.SurveysAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.SurveysSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.SurveysMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SurveysMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final int? vendorId;

  final int? storeId;

  final String? title;

  final String? points;

  final String? urlImagen;

  final int? categoryId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final bool? isDeleted;

  final _i2.SurveysCountAggregateOutputType? $count;

  final _i2.SurveysAvgAggregateOutputType? $avg;

  final _i2.SurveysSumAggregateOutputType? $sum;

  final _i2.SurveysMinAggregateOutputType? $min;

  final _i2.SurveysMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        'is_deleted': isDeleted,
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class SurveysCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysCountOrderByAggregateInput({
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? storeId;

  final _i2.SortOrder? title;

  final _i2.SortOrder? points;

  final _i2.SortOrder? urlImagen;

  final _i2.SortOrder? categoryId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SortOrder? isDeleted;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
      };
}

class SurveysAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysAvgOrderByAggregateInput({
    this.id,
    this.vendorId,
    this.storeId,
    this.categoryId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? storeId;

  final _i2.SortOrder? categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'category_id': categoryId,
      };
}

class SurveysMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysMaxOrderByAggregateInput({
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? storeId;

  final _i2.SortOrder? title;

  final _i2.SortOrder? points;

  final _i2.SortOrder? urlImagen;

  final _i2.SortOrder? categoryId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SortOrder? isDeleted;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
      };
}

class SurveysMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysMinOrderByAggregateInput({
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? storeId;

  final _i2.SortOrder? title;

  final _i2.SortOrder? points;

  final _i2.SortOrder? urlImagen;

  final _i2.SortOrder? categoryId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SortOrder? isDeleted;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
      };
}

class SurveysSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysSumOrderByAggregateInput({
    this.id,
    this.vendorId,
    this.storeId,
    this.categoryId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? vendorId;

  final _i2.SortOrder? storeId;

  final _i2.SortOrder? categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'category_id': categoryId,
      };
}

class SurveysOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysOrderByWithAggregationInput({
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? vendorId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? storeId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? title;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? points;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? urlImagen;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? categoryId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? isDeleted;

  final _i2.SurveysCountOrderByAggregateInput? $count;

  final _i2.SurveysAvgOrderByAggregateInput? $avg;

  final _i2.SurveysMaxOrderByAggregateInput? $max;

  final _i2.SurveysMinOrderByAggregateInput? $min;

  final _i2.SurveysSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class SurveysScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  final _i1.PrismaUnion<_i2.SurveysScalarWhereWithAggregatesInput,
      Iterable<_i2.SurveysScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.SurveysScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.SurveysScalarWhereWithAggregatesInput,
      Iterable<_i2.SurveysScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? vendorId;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? storeId;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? title;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? urlImagen;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? categoryId;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<_i2.BoolNullableWithAggregatesFilter,
      _i1.PrismaUnion<bool, _i1.PrismaNull>>? isDeleted;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
      };
}

class SurveysCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysCountAggregateOutputTypeSelect({
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
    this.$all,
  });

  final bool? id;

  final bool? vendorId;

  final bool? storeId;

  final bool? title;

  final bool? points;

  final bool? urlImagen;

  final bool? categoryId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? isDeleted;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
        '_all': $all,
      };
}

class SurveysGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysGroupByOutputTypeCountArgs({this.select});

  final _i2.SurveysCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SurveysAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysAvgAggregateOutputTypeSelect({
    this.id,
    this.vendorId,
    this.storeId,
    this.categoryId,
  });

  final bool? id;

  final bool? vendorId;

  final bool? storeId;

  final bool? categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'category_id': categoryId,
      };
}

class SurveysGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysGroupByOutputTypeAvgArgs({this.select});

  final _i2.SurveysAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SurveysSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysSumAggregateOutputTypeSelect({
    this.id,
    this.vendorId,
    this.storeId,
    this.categoryId,
  });

  final bool? id;

  final bool? vendorId;

  final bool? storeId;

  final bool? categoryId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'category_id': categoryId,
      };
}

class SurveysGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysGroupByOutputTypeSumArgs({this.select});

  final _i2.SurveysSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SurveysMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysMinAggregateOutputTypeSelect({
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  final bool? id;

  final bool? vendorId;

  final bool? storeId;

  final bool? title;

  final bool? points;

  final bool? urlImagen;

  final bool? categoryId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? isDeleted;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
      };
}

class SurveysGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysGroupByOutputTypeMinArgs({this.select});

  final _i2.SurveysMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SurveysMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysMaxAggregateOutputTypeSelect({
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
  });

  final bool? id;

  final bool? vendorId;

  final bool? storeId;

  final bool? title;

  final bool? points;

  final bool? urlImagen;

  final bool? categoryId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? isDeleted;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
      };
}

class SurveysGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysGroupByOutputTypeMaxArgs({this.select});

  final _i2.SurveysMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SurveysGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysGroupByOutputTypeSelect({
    this.id,
    this.vendorId,
    this.storeId,
    this.title,
    this.points,
    this.urlImagen,
    this.categoryId,
    this.createdAt,
    this.updatedAt,
    this.isDeleted,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? vendorId;

  final bool? storeId;

  final bool? title;

  final bool? points;

  final bool? urlImagen;

  final bool? categoryId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? isDeleted;

  final _i1.PrismaUnion<bool, _i2.SurveysGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.SurveysGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.SurveysGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.SurveysGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.SurveysGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'vendor_id': vendorId,
        'store_id': storeId,
        'title': title,
        'points': points,
        'url_imagen': urlImagen,
        'category_id': categoryId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'is_deleted': isDeleted,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateSurveys {
  const AggregateSurveys({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateSurveys.fromJson(Map json) => AggregateSurveys(
        $count: json['_count'] is Map
            ? _i2.SurveysCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.SurveysAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.SurveysSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.SurveysMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SurveysMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.SurveysCountAggregateOutputType? $count;

  final _i2.SurveysAvgAggregateOutputType? $avg;

  final _i2.SurveysSumAggregateOutputType? $sum;

  final _i2.SurveysMinAggregateOutputType? $min;

  final _i2.SurveysMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateSurveysCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSurveysCountArgs({this.select});

  final _i2.SurveysCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSurveysAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSurveysAvgArgs({this.select});

  final _i2.SurveysAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSurveysSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSurveysSumArgs({this.select});

  final _i2.SurveysSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSurveysMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSurveysMinArgs({this.select});

  final _i2.SurveysMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSurveysMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSurveysMaxArgs({this.select});

  final _i2.SurveysMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSurveysSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSurveysSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateSurveysCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateSurveysAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateSurveysSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateSurveysMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateSurveysMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class SurveysResultWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i1.PrismaUnion<_i2.SurveysResultWhereInput,
      Iterable<_i2.SurveysResultWhereInput>>? AND;

  final Iterable<_i2.SurveysResultWhereInput>? OR;

  final _i1.PrismaUnion<_i2.SurveysResultWhereInput,
      Iterable<_i2.SurveysResultWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      userId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      surveyId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      storeId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class SurveysResultWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.SurveysResultWhereInput,
      Iterable<_i2.SurveysResultWhereInput>>? AND;

  final Iterable<_i2.SurveysResultWhereInput>? OR;

  final _i1.PrismaUnion<_i2.SurveysResultWhereInput,
      Iterable<_i2.SurveysResultWhereInput>>? NOT;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      userId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      surveyId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      storeId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class SurveysResultSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultSelect({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final bool? id;

  final bool? userId;

  final bool? surveyId;

  final bool? storeId;

  final bool? points;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class SurveysResultOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultOrderByWithRelationInput({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? userId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? surveyId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? storeId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? points;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

enum SurveysResultScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'SurveysResult'),
  userId<int>('user_id', 'SurveysResult'),
  surveyId<int>('survey_id', 'SurveysResult'),
  storeId<int>('store_id', 'SurveysResult'),
  points<String>('points', 'SurveysResult'),
  createdAt<DateTime>('created_at', 'SurveysResult'),
  updatedAt<DateTime>('updated_at', 'SurveysResult'),
  deletedAt<DateTime>('deleted_at', 'SurveysResult');

  const SurveysResultScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class SurveysResultCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultCreateInput({
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? surveyId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? storeId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? points;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class SurveysResultUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultUncheckedCreateInput({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final int? id;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? surveyId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? storeId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? points;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class SurveysResultCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultCreateManyInput({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final int? id;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? surveyId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? storeId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? points;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class SurveysResultUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultUpdateInput({
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? surveyId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? storeId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class SurveysResultUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultUncheckedUpdateInput({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? surveyId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? storeId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class SurveysResultUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultUpdateManyMutationInput({
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? surveyId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? storeId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class SurveysResultUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultUncheckedUpdateManyInput({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? surveyId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? storeId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class SurveysResultCountAggregateOutputType {
  const SurveysResultCountAggregateOutputType({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.$all,
  });

  factory SurveysResultCountAggregateOutputType.fromJson(Map json) =>
      SurveysResultCountAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        surveyId: json['survey_id'],
        storeId: json['store_id'],
        points: json['points'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        deletedAt: json['deleted_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? userId;

  final int? surveyId;

  final int? storeId;

  final int? points;

  final int? createdAt;

  final int? updatedAt;

  final int? deletedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        '_all': $all,
      };
}

class SurveysResultAvgAggregateOutputType {
  const SurveysResultAvgAggregateOutputType({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
  });

  factory SurveysResultAvgAggregateOutputType.fromJson(Map json) =>
      SurveysResultAvgAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        surveyId: json['survey_id'],
        storeId: json['store_id'],
      );

  final double? id;

  final double? userId;

  final double? surveyId;

  final double? storeId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
      };
}

class SurveysResultSumAggregateOutputType {
  const SurveysResultSumAggregateOutputType({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
  });

  factory SurveysResultSumAggregateOutputType.fromJson(Map json) =>
      SurveysResultSumAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        surveyId: json['survey_id'],
        storeId: json['store_id'],
      );

  final int? id;

  final int? userId;

  final int? surveyId;

  final int? storeId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
      };
}

class SurveysResultMinAggregateOutputType {
  const SurveysResultMinAggregateOutputType({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  factory SurveysResultMinAggregateOutputType.fromJson(Map json) =>
      SurveysResultMinAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        surveyId: json['survey_id'],
        storeId: json['store_id'],
        points: json['points'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        deletedAt: switch (json['deleted_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['deleted_at']
        },
      );

  final int? id;

  final int? userId;

  final int? surveyId;

  final int? storeId;

  final String? points;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final DateTime? deletedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        'deleted_at': deletedAt?.toIso8601String(),
      };
}

class SurveysResultMaxAggregateOutputType {
  const SurveysResultMaxAggregateOutputType({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  factory SurveysResultMaxAggregateOutputType.fromJson(Map json) =>
      SurveysResultMaxAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        surveyId: json['survey_id'],
        storeId: json['store_id'],
        points: json['points'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        deletedAt: switch (json['deleted_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['deleted_at']
        },
      );

  final int? id;

  final int? userId;

  final int? surveyId;

  final int? storeId;

  final String? points;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final DateTime? deletedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        'deleted_at': deletedAt?.toIso8601String(),
      };
}

class SurveysResultGroupByOutputType {
  const SurveysResultGroupByOutputType({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory SurveysResultGroupByOutputType.fromJson(Map json) =>
      SurveysResultGroupByOutputType(
        id: json['id'],
        userId: json['user_id'],
        surveyId: json['survey_id'],
        storeId: json['store_id'],
        points: json['points'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        deletedAt: switch (json['deleted_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['deleted_at']
        },
        $count: json['_count'] is Map
            ? _i2.SurveysResultCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.SurveysResultAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.SurveysResultSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.SurveysResultMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SurveysResultMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final int? userId;

  final int? surveyId;

  final int? storeId;

  final String? points;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final DateTime? deletedAt;

  final _i2.SurveysResultCountAggregateOutputType? $count;

  final _i2.SurveysResultAvgAggregateOutputType? $avg;

  final _i2.SurveysResultSumAggregateOutputType? $sum;

  final _i2.SurveysResultMinAggregateOutputType? $min;

  final _i2.SurveysResultMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        'deleted_at': deletedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class SurveysResultCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultCountOrderByAggregateInput({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? surveyId;

  final _i2.SortOrder? storeId;

  final _i2.SortOrder? points;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SortOrder? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class SurveysResultAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultAvgOrderByAggregateInput({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? surveyId;

  final _i2.SortOrder? storeId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
      };
}

class SurveysResultMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultMaxOrderByAggregateInput({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? surveyId;

  final _i2.SortOrder? storeId;

  final _i2.SortOrder? points;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SortOrder? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class SurveysResultMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultMinOrderByAggregateInput({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? surveyId;

  final _i2.SortOrder? storeId;

  final _i2.SortOrder? points;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.SortOrder? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class SurveysResultSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultSumOrderByAggregateInput({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? surveyId;

  final _i2.SortOrder? storeId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
      };
}

class SurveysResultOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultOrderByWithAggregationInput({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? userId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? surveyId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? storeId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? points;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? deletedAt;

  final _i2.SurveysResultCountOrderByAggregateInput? $count;

  final _i2.SurveysResultAvgOrderByAggregateInput? $avg;

  final _i2.SurveysResultMaxOrderByAggregateInput? $max;

  final _i2.SurveysResultMinOrderByAggregateInput? $min;

  final _i2.SurveysResultSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class SurveysResultScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final _i1.PrismaUnion<_i2.SurveysResultScalarWhereWithAggregatesInput,
      Iterable<_i2.SurveysResultScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.SurveysResultScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.SurveysResultScalarWhereWithAggregatesInput,
      Iterable<_i2.SurveysResultScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? surveyId;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? storeId;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class SurveysResultCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultCountAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.$all,
  });

  final bool? id;

  final bool? userId;

  final bool? surveyId;

  final bool? storeId;

  final bool? points;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? deletedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        '_all': $all,
      };
}

class SurveysResultGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultGroupByOutputTypeCountArgs({this.select});

  final _i2.SurveysResultCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SurveysResultAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultAvgAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
  });

  final bool? id;

  final bool? userId;

  final bool? surveyId;

  final bool? storeId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
      };
}

class SurveysResultGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultGroupByOutputTypeAvgArgs({this.select});

  final _i2.SurveysResultAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SurveysResultSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultSumAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
  });

  final bool? id;

  final bool? userId;

  final bool? surveyId;

  final bool? storeId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
      };
}

class SurveysResultGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultGroupByOutputTypeSumArgs({this.select});

  final _i2.SurveysResultSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SurveysResultMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultMinAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final bool? id;

  final bool? userId;

  final bool? surveyId;

  final bool? storeId;

  final bool? points;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class SurveysResultGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultGroupByOutputTypeMinArgs({this.select});

  final _i2.SurveysResultMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SurveysResultMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultMaxAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
  });

  final bool? id;

  final bool? userId;

  final bool? surveyId;

  final bool? storeId;

  final bool? points;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? deletedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
      };
}

class SurveysResultGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultGroupByOutputTypeMaxArgs({this.select});

  final _i2.SurveysResultMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class SurveysResultGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const SurveysResultGroupByOutputTypeSelect({
    this.id,
    this.userId,
    this.surveyId,
    this.storeId,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.deletedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? userId;

  final bool? surveyId;

  final bool? storeId;

  final bool? points;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? deletedAt;

  final _i1.PrismaUnion<bool, _i2.SurveysResultGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.SurveysResultGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.SurveysResultGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.SurveysResultGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.SurveysResultGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'survey_id': surveyId,
        'store_id': storeId,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        'deleted_at': deletedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateSurveysResult {
  const AggregateSurveysResult({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateSurveysResult.fromJson(Map json) => AggregateSurveysResult(
        $count: json['_count'] is Map
            ? _i2.SurveysResultCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.SurveysResultAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.SurveysResultSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.SurveysResultMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.SurveysResultMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.SurveysResultCountAggregateOutputType? $count;

  final _i2.SurveysResultAvgAggregateOutputType? $avg;

  final _i2.SurveysResultSumAggregateOutputType? $sum;

  final _i2.SurveysResultMinAggregateOutputType? $min;

  final _i2.SurveysResultMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateSurveysResultCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSurveysResultCountArgs({this.select});

  final _i2.SurveysResultCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSurveysResultAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSurveysResultAvgArgs({this.select});

  final _i2.SurveysResultAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSurveysResultSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSurveysResultSumArgs({this.select});

  final _i2.SurveysResultSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSurveysResultMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSurveysResultMinArgs({this.select});

  final _i2.SurveysResultMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSurveysResultMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSurveysResultMaxArgs({this.select});

  final _i2.SurveysResultMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateSurveysResultSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateSurveysResultSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateSurveysResultCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateSurveysResultAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateSurveysResultSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateSurveysResultMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateSurveysResultMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class QuestionsWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  final _i1
      .PrismaUnion<_i2.QuestionsWhereInput, Iterable<_i2.QuestionsWhereInput>>?
      AND;

  final Iterable<_i2.QuestionsWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.QuestionsWhereInput, Iterable<_i2.QuestionsWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      surveyId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? questionText;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class QuestionsWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1
      .PrismaUnion<_i2.QuestionsWhereInput, Iterable<_i2.QuestionsWhereInput>>?
      AND;

  final Iterable<_i2.QuestionsWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.QuestionsWhereInput, Iterable<_i2.QuestionsWhereInput>>?
      NOT;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      surveyId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? questionText;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class QuestionsSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsSelect({
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? surveyId;

  final bool? questionText;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class QuestionsOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsOrderByWithRelationInput({
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? surveyId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? questionText;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

enum QuestionsScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Questions'),
  surveyId<int>('survey_id', 'Questions'),
  questionText<String>('question_text', 'Questions'),
  createdAt<DateTime>('created_at', 'Questions'),
  updatedAt<DateTime>('updated_at', 'Questions');

  const QuestionsScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class QuestionsCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsCreateInput({
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i1.PrismaNull>? surveyId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? questionText;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class QuestionsUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsUncheckedCreateInput({
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? surveyId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? questionText;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class QuestionsCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsCreateManyInput({
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? surveyId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? questionText;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class QuestionsUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsUpdateInput({
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? surveyId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? questionText;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class QuestionsUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsUncheckedUpdateInput({
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? surveyId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? questionText;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class QuestionsUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsUpdateManyMutationInput({
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? surveyId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? questionText;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class QuestionsUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsUncheckedUpdateManyInput({
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? surveyId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? questionText;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class QuestionsCountAggregateOutputType {
  const QuestionsCountAggregateOutputType({
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory QuestionsCountAggregateOutputType.fromJson(Map json) =>
      QuestionsCountAggregateOutputType(
        id: json['id'],
        surveyId: json['survey_id'],
        questionText: json['question_text'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? surveyId;

  final int? questionText;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class QuestionsAvgAggregateOutputType {
  const QuestionsAvgAggregateOutputType({
    this.id,
    this.surveyId,
  });

  factory QuestionsAvgAggregateOutputType.fromJson(Map json) =>
      QuestionsAvgAggregateOutputType(
        id: json['id'],
        surveyId: json['survey_id'],
      );

  final double? id;

  final double? surveyId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
      };
}

class QuestionsSumAggregateOutputType {
  const QuestionsSumAggregateOutputType({
    this.id,
    this.surveyId,
  });

  factory QuestionsSumAggregateOutputType.fromJson(Map json) =>
      QuestionsSumAggregateOutputType(
        id: json['id'],
        surveyId: json['survey_id'],
      );

  final int? id;

  final int? surveyId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
      };
}

class QuestionsMinAggregateOutputType {
  const QuestionsMinAggregateOutputType({
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  factory QuestionsMinAggregateOutputType.fromJson(Map json) =>
      QuestionsMinAggregateOutputType(
        id: json['id'],
        surveyId: json['survey_id'],
        questionText: json['question_text'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final int? surveyId;

  final String? questionText;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class QuestionsMaxAggregateOutputType {
  const QuestionsMaxAggregateOutputType({
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  factory QuestionsMaxAggregateOutputType.fromJson(Map json) =>
      QuestionsMaxAggregateOutputType(
        id: json['id'],
        surveyId: json['survey_id'],
        questionText: json['question_text'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final int? surveyId;

  final String? questionText;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class QuestionsGroupByOutputType {
  const QuestionsGroupByOutputType({
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory QuestionsGroupByOutputType.fromJson(Map json) =>
      QuestionsGroupByOutputType(
        id: json['id'],
        surveyId: json['survey_id'],
        questionText: json['question_text'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        $count: json['_count'] is Map
            ? _i2.QuestionsCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.QuestionsAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.QuestionsSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.QuestionsMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.QuestionsMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final int? surveyId;

  final String? questionText;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.QuestionsCountAggregateOutputType? $count;

  final _i2.QuestionsAvgAggregateOutputType? $avg;

  final _i2.QuestionsSumAggregateOutputType? $sum;

  final _i2.QuestionsMinAggregateOutputType? $min;

  final _i2.QuestionsMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class QuestionsCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsCountOrderByAggregateInput({
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? surveyId;

  final _i2.SortOrder? questionText;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class QuestionsAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsAvgOrderByAggregateInput({
    this.id,
    this.surveyId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? surveyId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
      };
}

class QuestionsMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsMaxOrderByAggregateInput({
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? surveyId;

  final _i2.SortOrder? questionText;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class QuestionsMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsMinOrderByAggregateInput({
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? surveyId;

  final _i2.SortOrder? questionText;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class QuestionsSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsSumOrderByAggregateInput({
    this.id,
    this.surveyId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? surveyId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
      };
}

class QuestionsOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsOrderByWithAggregationInput({
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? surveyId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? questionText;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i2.QuestionsCountOrderByAggregateInput? $count;

  final _i2.QuestionsAvgOrderByAggregateInput? $avg;

  final _i2.QuestionsMaxOrderByAggregateInput? $max;

  final _i2.QuestionsMinOrderByAggregateInput? $min;

  final _i2.QuestionsSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class QuestionsScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.QuestionsScalarWhereWithAggregatesInput,
      Iterable<_i2.QuestionsScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.QuestionsScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.QuestionsScalarWhereWithAggregatesInput,
      Iterable<_i2.QuestionsScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? surveyId;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? questionText;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class QuestionsCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsCountAggregateOutputTypeSelect({
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? surveyId;

  final bool? questionText;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class QuestionsGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsGroupByOutputTypeCountArgs({this.select});

  final _i2.QuestionsCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class QuestionsAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsAvgAggregateOutputTypeSelect({
    this.id,
    this.surveyId,
  });

  final bool? id;

  final bool? surveyId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
      };
}

class QuestionsGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsGroupByOutputTypeAvgArgs({this.select});

  final _i2.QuestionsAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class QuestionsSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsSumAggregateOutputTypeSelect({
    this.id,
    this.surveyId,
  });

  final bool? id;

  final bool? surveyId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
      };
}

class QuestionsGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsGroupByOutputTypeSumArgs({this.select});

  final _i2.QuestionsSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class QuestionsMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsMinAggregateOutputTypeSelect({
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? surveyId;

  final bool? questionText;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class QuestionsGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsGroupByOutputTypeMinArgs({this.select});

  final _i2.QuestionsMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class QuestionsMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsMaxAggregateOutputTypeSelect({
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? surveyId;

  final bool? questionText;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class QuestionsGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsGroupByOutputTypeMaxArgs({this.select});

  final _i2.QuestionsMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class QuestionsGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const QuestionsGroupByOutputTypeSelect({
    this.id,
    this.surveyId,
    this.questionText,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? surveyId;

  final bool? questionText;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.QuestionsGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.QuestionsGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.QuestionsGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.QuestionsGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.QuestionsGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'survey_id': surveyId,
        'question_text': questionText,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateQuestions {
  const AggregateQuestions({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateQuestions.fromJson(Map json) => AggregateQuestions(
        $count: json['_count'] is Map
            ? _i2.QuestionsCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.QuestionsAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.QuestionsSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.QuestionsMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.QuestionsMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.QuestionsCountAggregateOutputType? $count;

  final _i2.QuestionsAvgAggregateOutputType? $avg;

  final _i2.QuestionsSumAggregateOutputType? $sum;

  final _i2.QuestionsMinAggregateOutputType? $min;

  final _i2.QuestionsMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateQuestionsCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateQuestionsCountArgs({this.select});

  final _i2.QuestionsCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateQuestionsAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateQuestionsAvgArgs({this.select});

  final _i2.QuestionsAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateQuestionsSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateQuestionsSumArgs({this.select});

  final _i2.QuestionsSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateQuestionsMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateQuestionsMinArgs({this.select});

  final _i2.QuestionsMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateQuestionsMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateQuestionsMaxArgs({this.select});

  final _i2.QuestionsMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateQuestionsSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateQuestionsSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateQuestionsCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateQuestionsAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateQuestionsSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateQuestionsMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateQuestionsMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AnswersWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.AnswersWhereInput, Iterable<_i2.AnswersWhereInput>>?
      AND;

  final Iterable<_i2.AnswersWhereInput>? OR;

  final _i1.PrismaUnion<_i2.AnswersWhereInput, Iterable<_i2.AnswersWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      questionId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? answerText;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.AnswersWhereInput, Iterable<_i2.AnswersWhereInput>>?
      AND;

  final Iterable<_i2.AnswersWhereInput>? OR;

  final _i1.PrismaUnion<_i2.AnswersWhereInput, Iterable<_i2.AnswersWhereInput>>?
      NOT;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      questionId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? answerText;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersSelect({
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? questionId;

  final bool? answerText;

  final bool? points;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersOrderByWithRelationInput({
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? questionId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? answerText;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? points;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

enum AnswersScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Answers'),
  questionId<int>('question_id', 'Answers'),
  answerText<String>('answer_text', 'Answers'),
  points<String>('points', 'Answers'),
  createdAt<DateTime>('created_at', 'Answers'),
  updatedAt<DateTime>('updated_at', 'Answers');

  const AnswersScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class AnswersCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersCreateInput({
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i1.PrismaNull>? questionId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? answerText;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? points;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersUncheckedCreateInput({
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? questionId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? answerText;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? points;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersCreateManyInput({
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? questionId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? answerText;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? points;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersUpdateInput({
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? questionId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? answerText;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersUncheckedUpdateInput({
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? questionId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? answerText;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersUpdateManyMutationInput({
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? questionId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? answerText;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersUncheckedUpdateManyInput({
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? questionId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? answerText;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersCountAggregateOutputType {
  const AnswersCountAggregateOutputType({
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory AnswersCountAggregateOutputType.fromJson(Map json) =>
      AnswersCountAggregateOutputType(
        id: json['id'],
        questionId: json['question_id'],
        answerText: json['answer_text'],
        points: json['points'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? questionId;

  final int? answerText;

  final int? points;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class AnswersAvgAggregateOutputType {
  const AnswersAvgAggregateOutputType({
    this.id,
    this.questionId,
  });

  factory AnswersAvgAggregateOutputType.fromJson(Map json) =>
      AnswersAvgAggregateOutputType(
        id: json['id'],
        questionId: json['question_id'],
      );

  final double? id;

  final double? questionId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
      };
}

class AnswersSumAggregateOutputType {
  const AnswersSumAggregateOutputType({
    this.id,
    this.questionId,
  });

  factory AnswersSumAggregateOutputType.fromJson(Map json) =>
      AnswersSumAggregateOutputType(
        id: json['id'],
        questionId: json['question_id'],
      );

  final int? id;

  final int? questionId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
      };
}

class AnswersMinAggregateOutputType {
  const AnswersMinAggregateOutputType({
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  factory AnswersMinAggregateOutputType.fromJson(Map json) =>
      AnswersMinAggregateOutputType(
        id: json['id'],
        questionId: json['question_id'],
        answerText: json['answer_text'],
        points: json['points'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final int? questionId;

  final String? answerText;

  final String? points;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class AnswersMaxAggregateOutputType {
  const AnswersMaxAggregateOutputType({
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  factory AnswersMaxAggregateOutputType.fromJson(Map json) =>
      AnswersMaxAggregateOutputType(
        id: json['id'],
        questionId: json['question_id'],
        answerText: json['answer_text'],
        points: json['points'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final int? questionId;

  final String? answerText;

  final String? points;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class AnswersGroupByOutputType {
  const AnswersGroupByOutputType({
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AnswersGroupByOutputType.fromJson(Map json) =>
      AnswersGroupByOutputType(
        id: json['id'],
        questionId: json['question_id'],
        answerText: json['answer_text'],
        points: json['points'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        $count: json['_count'] is Map
            ? _i2.AnswersCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.AnswersAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.AnswersSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.AnswersMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.AnswersMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final int? questionId;

  final String? answerText;

  final String? points;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AnswersCountAggregateOutputType? $count;

  final _i2.AnswersAvgAggregateOutputType? $avg;

  final _i2.AnswersSumAggregateOutputType? $sum;

  final _i2.AnswersMinAggregateOutputType? $min;

  final _i2.AnswersMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AnswersCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersCountOrderByAggregateInput({
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? questionId;

  final _i2.SortOrder? answerText;

  final _i2.SortOrder? points;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersAvgOrderByAggregateInput({
    this.id,
    this.questionId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? questionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
      };
}

class AnswersMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersMaxOrderByAggregateInput({
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? questionId;

  final _i2.SortOrder? answerText;

  final _i2.SortOrder? points;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersMinOrderByAggregateInput({
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? questionId;

  final _i2.SortOrder? answerText;

  final _i2.SortOrder? points;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersSumOrderByAggregateInput({
    this.id,
    this.questionId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? questionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
      };
}

class AnswersOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersOrderByWithAggregationInput({
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? questionId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? answerText;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? points;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i2.AnswersCountOrderByAggregateInput? $count;

  final _i2.AnswersAvgOrderByAggregateInput? $avg;

  final _i2.AnswersMaxOrderByAggregateInput? $max;

  final _i2.AnswersMinOrderByAggregateInput? $min;

  final _i2.AnswersSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class AnswersScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.AnswersScalarWhereWithAggregatesInput,
      Iterable<_i2.AnswersScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.AnswersScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.AnswersScalarWhereWithAggregatesInput,
      Iterable<_i2.AnswersScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? questionId;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? answerText;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? points;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersCountAggregateOutputTypeSelect({
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? questionId;

  final bool? answerText;

  final bool? points;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class AnswersGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersGroupByOutputTypeCountArgs({this.select});

  final _i2.AnswersCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AnswersAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersAvgAggregateOutputTypeSelect({
    this.id,
    this.questionId,
  });

  final bool? id;

  final bool? questionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
      };
}

class AnswersGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersGroupByOutputTypeAvgArgs({this.select});

  final _i2.AnswersAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AnswersSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersSumAggregateOutputTypeSelect({
    this.id,
    this.questionId,
  });

  final bool? id;

  final bool? questionId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
      };
}

class AnswersGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersGroupByOutputTypeSumArgs({this.select});

  final _i2.AnswersSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AnswersMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersMinAggregateOutputTypeSelect({
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? questionId;

  final bool? answerText;

  final bool? points;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersGroupByOutputTypeMinArgs({this.select});

  final _i2.AnswersMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AnswersMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersMaxAggregateOutputTypeSelect({
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? questionId;

  final bool? answerText;

  final bool? points;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersGroupByOutputTypeMaxArgs({this.select});

  final _i2.AnswersMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AnswersGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersGroupByOutputTypeSelect({
    this.id,
    this.questionId,
    this.answerText,
    this.points,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? questionId;

  final bool? answerText;

  final bool? points;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.AnswersGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AnswersGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AnswersGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AnswersGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AnswersGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'question_id': questionId,
        'answer_text': answerText,
        'points': points,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateAnswers {
  const AggregateAnswers({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateAnswers.fromJson(Map json) => AggregateAnswers(
        $count: json['_count'] is Map
            ? _i2.AnswersCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.AnswersAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.AnswersSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.AnswersMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.AnswersMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.AnswersCountAggregateOutputType? $count;

  final _i2.AnswersAvgAggregateOutputType? $avg;

  final _i2.AnswersSumAggregateOutputType? $sum;

  final _i2.AnswersMinAggregateOutputType? $min;

  final _i2.AnswersMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateAnswersCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAnswersCountArgs({this.select});

  final _i2.AnswersCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAnswersAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAnswersAvgArgs({this.select});

  final _i2.AnswersAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAnswersSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAnswersSumArgs({this.select});

  final _i2.AnswersSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAnswersMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAnswersMinArgs({this.select});

  final _i2.AnswersMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAnswersMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAnswersMaxArgs({this.select});

  final _i2.AnswersMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAnswersSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAnswersSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateAnswersCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateAnswersAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateAnswersSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateAnswersMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateAnswersMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AnswersResultWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.AnswersResultWhereInput,
      Iterable<_i2.AnswersResultWhereInput>>? AND;

  final Iterable<_i2.AnswersResultWhereInput>? OR;

  final _i1.PrismaUnion<_i2.AnswersResultWhereInput,
      Iterable<_i2.AnswersResultWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      userId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      questionId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      answerId;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersResultWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.AnswersResultWhereInput,
      Iterable<_i2.AnswersResultWhereInput>>? AND;

  final Iterable<_i2.AnswersResultWhereInput>? OR;

  final _i1.PrismaUnion<_i2.AnswersResultWhereInput,
      Iterable<_i2.AnswersResultWhereInput>>? NOT;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      userId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      questionId;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      answerId;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersResultSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultSelect({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? userId;

  final bool? questionId;

  final bool? answerId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersResultOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultOrderByWithRelationInput({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? userId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? questionId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? answerId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

enum AnswersResultScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'AnswersResult'),
  userId<int>('user_id', 'AnswersResult'),
  questionId<int>('question_id', 'AnswersResult'),
  answerId<int>('answer_id', 'AnswersResult'),
  createdAt<DateTime>('created_at', 'AnswersResult'),
  updatedAt<DateTime>('updated_at', 'AnswersResult');

  const AnswersResultScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class AnswersResultCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultCreateInput({
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? questionId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? answerId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersResultUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultUncheckedCreateInput({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? questionId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? answerId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersResultCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultCreateManyInput({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? userId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? questionId;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? answerId;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? createdAt;

  final _i1.PrismaUnion<DateTime, _i1.PrismaNull>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersResultUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultUpdateInput({
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? questionId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? answerId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersResultUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultUncheckedUpdateInput({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? questionId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? answerId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersResultUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultUpdateManyMutationInput({
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? questionId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? answerId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersResultUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultUncheckedUpdateManyInput({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? questionId;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? answerId;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<
      DateTime,
      _i1.PrismaUnion<_i2.NullableDateTimeFieldUpdateOperationsInput,
          _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersResultCountAggregateOutputType {
  const AnswersResultCountAggregateOutputType({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory AnswersResultCountAggregateOutputType.fromJson(Map json) =>
      AnswersResultCountAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        questionId: json['question_id'],
        answerId: json['answer_id'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? userId;

  final int? questionId;

  final int? answerId;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class AnswersResultAvgAggregateOutputType {
  const AnswersResultAvgAggregateOutputType({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
  });

  factory AnswersResultAvgAggregateOutputType.fromJson(Map json) =>
      AnswersResultAvgAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        questionId: json['question_id'],
        answerId: json['answer_id'],
      );

  final double? id;

  final double? userId;

  final double? questionId;

  final double? answerId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
      };
}

class AnswersResultSumAggregateOutputType {
  const AnswersResultSumAggregateOutputType({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
  });

  factory AnswersResultSumAggregateOutputType.fromJson(Map json) =>
      AnswersResultSumAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        questionId: json['question_id'],
        answerId: json['answer_id'],
      );

  final int? id;

  final int? userId;

  final int? questionId;

  final int? answerId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
      };
}

class AnswersResultMinAggregateOutputType {
  const AnswersResultMinAggregateOutputType({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  factory AnswersResultMinAggregateOutputType.fromJson(Map json) =>
      AnswersResultMinAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        questionId: json['question_id'],
        answerId: json['answer_id'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final int? userId;

  final int? questionId;

  final int? answerId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class AnswersResultMaxAggregateOutputType {
  const AnswersResultMaxAggregateOutputType({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  factory AnswersResultMaxAggregateOutputType.fromJson(Map json) =>
      AnswersResultMaxAggregateOutputType(
        id: json['id'],
        userId: json['user_id'],
        questionId: json['question_id'],
        answerId: json['answer_id'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final int? userId;

  final int? questionId;

  final int? answerId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class AnswersResultGroupByOutputType {
  const AnswersResultGroupByOutputType({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AnswersResultGroupByOutputType.fromJson(Map json) =>
      AnswersResultGroupByOutputType(
        id: json['id'],
        userId: json['user_id'],
        questionId: json['question_id'],
        answerId: json['answer_id'],
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        $count: json['_count'] is Map
            ? _i2.AnswersResultCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.AnswersResultAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.AnswersResultSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.AnswersResultMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.AnswersResultMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final int? userId;

  final int? questionId;

  final int? answerId;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.AnswersResultCountAggregateOutputType? $count;

  final _i2.AnswersResultAvgAggregateOutputType? $avg;

  final _i2.AnswersResultSumAggregateOutputType? $sum;

  final _i2.AnswersResultMinAggregateOutputType? $min;

  final _i2.AnswersResultMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AnswersResultCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultCountOrderByAggregateInput({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? questionId;

  final _i2.SortOrder? answerId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersResultAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultAvgOrderByAggregateInput({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? questionId;

  final _i2.SortOrder? answerId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
      };
}

class AnswersResultMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultMaxOrderByAggregateInput({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? questionId;

  final _i2.SortOrder? answerId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersResultMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultMinOrderByAggregateInput({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? questionId;

  final _i2.SortOrder? answerId;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersResultSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultSumOrderByAggregateInput({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? userId;

  final _i2.SortOrder? questionId;

  final _i2.SortOrder? answerId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
      };
}

class AnswersResultOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultOrderByWithAggregationInput({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? userId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? questionId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? answerId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? createdAt;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? updatedAt;

  final _i2.AnswersResultCountOrderByAggregateInput? $count;

  final _i2.AnswersResultAvgOrderByAggregateInput? $avg;

  final _i2.AnswersResultMaxOrderByAggregateInput? $max;

  final _i2.AnswersResultMinOrderByAggregateInput? $min;

  final _i2.AnswersResultSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class AnswersResultScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.AnswersResultScalarWhereWithAggregatesInput,
      Iterable<_i2.AnswersResultScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.AnswersResultScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.AnswersResultScalarWhereWithAggregatesInput,
      Iterable<_i2.AnswersResultScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? userId;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? questionId;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? answerId;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeNullableWithAggregatesFilter,
      _i1.PrismaUnion<DateTime, _i1.PrismaNull>>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersResultCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultCountAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? userId;

  final bool? questionId;

  final bool? answerId;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class AnswersResultGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultGroupByOutputTypeCountArgs({this.select});

  final _i2.AnswersResultCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AnswersResultAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultAvgAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
  });

  final bool? id;

  final bool? userId;

  final bool? questionId;

  final bool? answerId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
      };
}

class AnswersResultGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultGroupByOutputTypeAvgArgs({this.select});

  final _i2.AnswersResultAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AnswersResultSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultSumAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
  });

  final bool? id;

  final bool? userId;

  final bool? questionId;

  final bool? answerId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
      };
}

class AnswersResultGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultGroupByOutputTypeSumArgs({this.select});

  final _i2.AnswersResultSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AnswersResultMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultMinAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? userId;

  final bool? questionId;

  final bool? answerId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersResultGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultGroupByOutputTypeMinArgs({this.select});

  final _i2.AnswersResultMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AnswersResultMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultMaxAggregateOutputTypeSelect({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? userId;

  final bool? questionId;

  final bool? answerId;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class AnswersResultGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultGroupByOutputTypeMaxArgs({this.select});

  final _i2.AnswersResultMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AnswersResultGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AnswersResultGroupByOutputTypeSelect({
    this.id,
    this.userId,
    this.questionId,
    this.answerId,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? userId;

  final bool? questionId;

  final bool? answerId;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.AnswersResultGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.AnswersResultGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AnswersResultGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AnswersResultGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AnswersResultGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'user_id': userId,
        'question_id': questionId,
        'answer_id': answerId,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateAnswersResult {
  const AggregateAnswersResult({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateAnswersResult.fromJson(Map json) => AggregateAnswersResult(
        $count: json['_count'] is Map
            ? _i2.AnswersResultCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.AnswersResultAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.AnswersResultSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.AnswersResultMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.AnswersResultMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.AnswersResultCountAggregateOutputType? $count;

  final _i2.AnswersResultAvgAggregateOutputType? $avg;

  final _i2.AnswersResultSumAggregateOutputType? $sum;

  final _i2.AnswersResultMinAggregateOutputType? $min;

  final _i2.AnswersResultMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateAnswersResultCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAnswersResultCountArgs({this.select});

  final _i2.AnswersResultCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAnswersResultAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAnswersResultAvgArgs({this.select});

  final _i2.AnswersResultAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAnswersResultSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAnswersResultSumArgs({this.select});

  final _i2.AnswersResultSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAnswersResultMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAnswersResultMinArgs({this.select});

  final _i2.AnswersResultMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAnswersResultMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAnswersResultMaxArgs({this.select});

  final _i2.AnswersResultMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateAnswersResultSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateAnswersResultSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateAnswersResultCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateAnswersResultAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateAnswersResultSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateAnswersResultMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateAnswersResultMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class DepartamentWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.departament,
  });

  final _i1.PrismaUnion<_i2.DepartamentWhereInput,
      Iterable<_i2.DepartamentWhereInput>>? AND;

  final Iterable<_i2.DepartamentWhereInput>? OR;

  final _i1.PrismaUnion<_i2.DepartamentWhereInput,
      Iterable<_i2.DepartamentWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? departament;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'departament': departament,
      };
}

class DepartamentWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.departament,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.DepartamentWhereInput,
      Iterable<_i2.DepartamentWhereInput>>? AND;

  final Iterable<_i2.DepartamentWhereInput>? OR;

  final _i1.PrismaUnion<_i2.DepartamentWhereInput,
      Iterable<_i2.DepartamentWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? departament;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'departament': departament,
      };
}

class DepartamentSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentSelect({
    this.id,
    this.departament,
  });

  final bool? id;

  final bool? departament;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'departament': departament,
      };
}

class DepartamentOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentOrderByWithRelationInput({
    this.id,
    this.departament,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? departament;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'departament': departament,
      };
}

enum DepartamentScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Departament'),
  departament<String>('departament', 'Departament');

  const DepartamentScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class DepartamentCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentCreateInput({this.departament});

  final _i1.PrismaUnion<String, _i1.PrismaNull>? departament;

  @override
  Map<String, dynamic> toJson() => {'departament': departament};
}

class DepartamentUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentUncheckedCreateInput({
    this.id,
    this.departament,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? departament;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'departament': departament,
      };
}

class DepartamentCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentCreateManyInput({
    this.id,
    this.departament,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? departament;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'departament': departament,
      };
}

class DepartamentUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentUpdateInput({this.departament});

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? departament;

  @override
  Map<String, dynamic> toJson() => {'departament': departament};
}

class DepartamentUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentUncheckedUpdateInput({
    this.id,
    this.departament,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? departament;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'departament': departament,
      };
}

class DepartamentUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentUpdateManyMutationInput({this.departament});

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? departament;

  @override
  Map<String, dynamic> toJson() => {'departament': departament};
}

class DepartamentUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentUncheckedUpdateManyInput({
    this.id,
    this.departament,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? departament;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'departament': departament,
      };
}

class DepartamentCountAggregateOutputType {
  const DepartamentCountAggregateOutputType({
    this.id,
    this.departament,
    this.$all,
  });

  factory DepartamentCountAggregateOutputType.fromJson(Map json) =>
      DepartamentCountAggregateOutputType(
        id: json['id'],
        departament: json['departament'],
        $all: json['_all'],
      );

  final int? id;

  final int? departament;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'departament': departament,
        '_all': $all,
      };
}

class DepartamentAvgAggregateOutputType {
  const DepartamentAvgAggregateOutputType({this.id});

  factory DepartamentAvgAggregateOutputType.fromJson(Map json) =>
      DepartamentAvgAggregateOutputType(id: json['id']);

  final double? id;

  Map<String, dynamic> toJson() => {'id': id};
}

class DepartamentSumAggregateOutputType {
  const DepartamentSumAggregateOutputType({this.id});

  factory DepartamentSumAggregateOutputType.fromJson(Map json) =>
      DepartamentSumAggregateOutputType(id: json['id']);

  final int? id;

  Map<String, dynamic> toJson() => {'id': id};
}

class DepartamentMinAggregateOutputType {
  const DepartamentMinAggregateOutputType({
    this.id,
    this.departament,
  });

  factory DepartamentMinAggregateOutputType.fromJson(Map json) =>
      DepartamentMinAggregateOutputType(
        id: json['id'],
        departament: json['departament'],
      );

  final int? id;

  final String? departament;

  Map<String, dynamic> toJson() => {
        'id': id,
        'departament': departament,
      };
}

class DepartamentMaxAggregateOutputType {
  const DepartamentMaxAggregateOutputType({
    this.id,
    this.departament,
  });

  factory DepartamentMaxAggregateOutputType.fromJson(Map json) =>
      DepartamentMaxAggregateOutputType(
        id: json['id'],
        departament: json['departament'],
      );

  final int? id;

  final String? departament;

  Map<String, dynamic> toJson() => {
        'id': id,
        'departament': departament,
      };
}

class DepartamentGroupByOutputType {
  const DepartamentGroupByOutputType({
    this.id,
    this.departament,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory DepartamentGroupByOutputType.fromJson(Map json) =>
      DepartamentGroupByOutputType(
        id: json['id'],
        departament: json['departament'],
        $count: json['_count'] is Map
            ? _i2.DepartamentCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.DepartamentAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.DepartamentSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.DepartamentMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.DepartamentMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? departament;

  final _i2.DepartamentCountAggregateOutputType? $count;

  final _i2.DepartamentAvgAggregateOutputType? $avg;

  final _i2.DepartamentSumAggregateOutputType? $sum;

  final _i2.DepartamentMinAggregateOutputType? $min;

  final _i2.DepartamentMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'departament': departament,
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class DepartamentCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentCountOrderByAggregateInput({
    this.id,
    this.departament,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? departament;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'departament': departament,
      };
}

class DepartamentAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentAvgOrderByAggregateInput({this.id});

  final _i2.SortOrder? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class DepartamentMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentMaxOrderByAggregateInput({
    this.id,
    this.departament,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? departament;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'departament': departament,
      };
}

class DepartamentMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentMinOrderByAggregateInput({
    this.id,
    this.departament,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? departament;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'departament': departament,
      };
}

class DepartamentSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentSumOrderByAggregateInput({this.id});

  final _i2.SortOrder? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class DepartamentOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentOrderByWithAggregationInput({
    this.id,
    this.departament,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? departament;

  final _i2.DepartamentCountOrderByAggregateInput? $count;

  final _i2.DepartamentAvgOrderByAggregateInput? $avg;

  final _i2.DepartamentMaxOrderByAggregateInput? $max;

  final _i2.DepartamentMinOrderByAggregateInput? $min;

  final _i2.DepartamentSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'departament': departament,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class DepartamentScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.departament,
  });

  final _i1.PrismaUnion<_i2.DepartamentScalarWhereWithAggregatesInput,
      Iterable<_i2.DepartamentScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.DepartamentScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.DepartamentScalarWhereWithAggregatesInput,
      Iterable<_i2.DepartamentScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? departament;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'departament': departament,
      };
}

class DepartamentCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentCountAggregateOutputTypeSelect({
    this.id,
    this.departament,
    this.$all,
  });

  final bool? id;

  final bool? departament;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'departament': departament,
        '_all': $all,
      };
}

class DepartamentGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentGroupByOutputTypeCountArgs({this.select});

  final _i2.DepartamentCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DepartamentAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentAvgAggregateOutputTypeSelect({this.id});

  final bool? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class DepartamentGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentGroupByOutputTypeAvgArgs({this.select});

  final _i2.DepartamentAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DepartamentSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentSumAggregateOutputTypeSelect({this.id});

  final bool? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class DepartamentGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentGroupByOutputTypeSumArgs({this.select});

  final _i2.DepartamentSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DepartamentMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentMinAggregateOutputTypeSelect({
    this.id,
    this.departament,
  });

  final bool? id;

  final bool? departament;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'departament': departament,
      };
}

class DepartamentGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentGroupByOutputTypeMinArgs({this.select});

  final _i2.DepartamentMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DepartamentMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentMaxAggregateOutputTypeSelect({
    this.id,
    this.departament,
  });

  final bool? id;

  final bool? departament;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'departament': departament,
      };
}

class DepartamentGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentGroupByOutputTypeMaxArgs({this.select});

  final _i2.DepartamentMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DepartamentGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DepartamentGroupByOutputTypeSelect({
    this.id,
    this.departament,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? departament;

  final _i1.PrismaUnion<bool, _i2.DepartamentGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.DepartamentGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.DepartamentGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.DepartamentGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.DepartamentGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'departament': departament,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateDepartament {
  const AggregateDepartament({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateDepartament.fromJson(Map json) => AggregateDepartament(
        $count: json['_count'] is Map
            ? _i2.DepartamentCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.DepartamentAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.DepartamentSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.DepartamentMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.DepartamentMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.DepartamentCountAggregateOutputType? $count;

  final _i2.DepartamentAvgAggregateOutputType? $avg;

  final _i2.DepartamentSumAggregateOutputType? $sum;

  final _i2.DepartamentMinAggregateOutputType? $min;

  final _i2.DepartamentMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateDepartamentCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDepartamentCountArgs({this.select});

  final _i2.DepartamentCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDepartamentAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDepartamentAvgArgs({this.select});

  final _i2.DepartamentAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDepartamentSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDepartamentSumArgs({this.select});

  final _i2.DepartamentSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDepartamentMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDepartamentMinArgs({this.select});

  final _i2.DepartamentMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDepartamentMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDepartamentMaxArgs({this.select});

  final _i2.DepartamentMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDepartamentSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDepartamentSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateDepartamentCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateDepartamentAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateDepartamentSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateDepartamentMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateDepartamentMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class ProvinceWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.province,
    this.departamentId,
  });

  final _i1
      .PrismaUnion<_i2.ProvinceWhereInput, Iterable<_i2.ProvinceWhereInput>>?
      AND;

  final Iterable<_i2.ProvinceWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.ProvinceWhereInput, Iterable<_i2.ProvinceWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? province;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'province': province,
        'departament_id': departamentId,
      };
}

class ProvinceWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.province,
    this.departamentId,
  });

  final int? id;

  final _i1
      .PrismaUnion<_i2.ProvinceWhereInput, Iterable<_i2.ProvinceWhereInput>>?
      AND;

  final Iterable<_i2.ProvinceWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.ProvinceWhereInput, Iterable<_i2.ProvinceWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? province;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'province': province,
        'departament_id': departamentId,
      };
}

class ProvinceSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceSelect({
    this.id,
    this.province,
    this.departamentId,
  });

  final bool? id;

  final bool? province;

  final bool? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'province': province,
        'departament_id': departamentId,
      };
}

class ProvinceOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceOrderByWithRelationInput({
    this.id,
    this.province,
    this.departamentId,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? province;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'province': province,
        'departament_id': departamentId,
      };
}

enum ProvinceScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Province'),
  province<String>('province', 'Province'),
  departamentId<int>('departament_id', 'Province');

  const ProvinceScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class ProvinceCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceCreateInput({
    this.province,
    this.departamentId,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? province;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'province': province,
        'departament_id': departamentId,
      };
}

class ProvinceUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceUncheckedCreateInput({
    this.id,
    this.province,
    this.departamentId,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? province;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'province': province,
        'departament_id': departamentId,
      };
}

class ProvinceCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceCreateManyInput({
    this.id,
    this.province,
    this.departamentId,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? province;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'province': province,
        'departament_id': departamentId,
      };
}

class ProvinceUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceUpdateInput({
    this.province,
    this.departamentId,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? province;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'province': province,
        'departament_id': departamentId,
      };
}

class ProvinceUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceUncheckedUpdateInput({
    this.id,
    this.province,
    this.departamentId,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? province;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'province': province,
        'departament_id': departamentId,
      };
}

class ProvinceUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceUpdateManyMutationInput({
    this.province,
    this.departamentId,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? province;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'province': province,
        'departament_id': departamentId,
      };
}

class ProvinceUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceUncheckedUpdateManyInput({
    this.id,
    this.province,
    this.departamentId,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? province;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'province': province,
        'departament_id': departamentId,
      };
}

class ProvinceCountAggregateOutputType {
  const ProvinceCountAggregateOutputType({
    this.id,
    this.province,
    this.departamentId,
    this.$all,
  });

  factory ProvinceCountAggregateOutputType.fromJson(Map json) =>
      ProvinceCountAggregateOutputType(
        id: json['id'],
        province: json['province'],
        departamentId: json['departament_id'],
        $all: json['_all'],
      );

  final int? id;

  final int? province;

  final int? departamentId;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'province': province,
        'departament_id': departamentId,
        '_all': $all,
      };
}

class ProvinceAvgAggregateOutputType {
  const ProvinceAvgAggregateOutputType({
    this.id,
    this.departamentId,
  });

  factory ProvinceAvgAggregateOutputType.fromJson(Map json) =>
      ProvinceAvgAggregateOutputType(
        id: json['id'],
        departamentId: json['departament_id'],
      );

  final double? id;

  final double? departamentId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'departament_id': departamentId,
      };
}

class ProvinceSumAggregateOutputType {
  const ProvinceSumAggregateOutputType({
    this.id,
    this.departamentId,
  });

  factory ProvinceSumAggregateOutputType.fromJson(Map json) =>
      ProvinceSumAggregateOutputType(
        id: json['id'],
        departamentId: json['departament_id'],
      );

  final int? id;

  final int? departamentId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'departament_id': departamentId,
      };
}

class ProvinceMinAggregateOutputType {
  const ProvinceMinAggregateOutputType({
    this.id,
    this.province,
    this.departamentId,
  });

  factory ProvinceMinAggregateOutputType.fromJson(Map json) =>
      ProvinceMinAggregateOutputType(
        id: json['id'],
        province: json['province'],
        departamentId: json['departament_id'],
      );

  final int? id;

  final String? province;

  final int? departamentId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'province': province,
        'departament_id': departamentId,
      };
}

class ProvinceMaxAggregateOutputType {
  const ProvinceMaxAggregateOutputType({
    this.id,
    this.province,
    this.departamentId,
  });

  factory ProvinceMaxAggregateOutputType.fromJson(Map json) =>
      ProvinceMaxAggregateOutputType(
        id: json['id'],
        province: json['province'],
        departamentId: json['departament_id'],
      );

  final int? id;

  final String? province;

  final int? departamentId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'province': province,
        'departament_id': departamentId,
      };
}

class ProvinceGroupByOutputType {
  const ProvinceGroupByOutputType({
    this.id,
    this.province,
    this.departamentId,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory ProvinceGroupByOutputType.fromJson(Map json) =>
      ProvinceGroupByOutputType(
        id: json['id'],
        province: json['province'],
        departamentId: json['departament_id'],
        $count: json['_count'] is Map
            ? _i2.ProvinceCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ProvinceAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ProvinceSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ProvinceMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ProvinceMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? province;

  final int? departamentId;

  final _i2.ProvinceCountAggregateOutputType? $count;

  final _i2.ProvinceAvgAggregateOutputType? $avg;

  final _i2.ProvinceSumAggregateOutputType? $sum;

  final _i2.ProvinceMinAggregateOutputType? $min;

  final _i2.ProvinceMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'province': province,
        'departament_id': departamentId,
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class ProvinceCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceCountOrderByAggregateInput({
    this.id,
    this.province,
    this.departamentId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? province;

  final _i2.SortOrder? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'province': province,
        'departament_id': departamentId,
      };
}

class ProvinceAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceAvgOrderByAggregateInput({
    this.id,
    this.departamentId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'departament_id': departamentId,
      };
}

class ProvinceMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceMaxOrderByAggregateInput({
    this.id,
    this.province,
    this.departamentId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? province;

  final _i2.SortOrder? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'province': province,
        'departament_id': departamentId,
      };
}

class ProvinceMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceMinOrderByAggregateInput({
    this.id,
    this.province,
    this.departamentId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? province;

  final _i2.SortOrder? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'province': province,
        'departament_id': departamentId,
      };
}

class ProvinceSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceSumOrderByAggregateInput({
    this.id,
    this.departamentId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'departament_id': departamentId,
      };
}

class ProvinceOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceOrderByWithAggregationInput({
    this.id,
    this.province,
    this.departamentId,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? province;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? departamentId;

  final _i2.ProvinceCountOrderByAggregateInput? $count;

  final _i2.ProvinceAvgOrderByAggregateInput? $avg;

  final _i2.ProvinceMaxOrderByAggregateInput? $max;

  final _i2.ProvinceMinOrderByAggregateInput? $min;

  final _i2.ProvinceSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'province': province,
        'departament_id': departamentId,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class ProvinceScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.province,
    this.departamentId,
  });

  final _i1.PrismaUnion<_i2.ProvinceScalarWhereWithAggregatesInput,
      Iterable<_i2.ProvinceScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.ProvinceScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.ProvinceScalarWhereWithAggregatesInput,
      Iterable<_i2.ProvinceScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? province;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'province': province,
        'departament_id': departamentId,
      };
}

class ProvinceCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceCountAggregateOutputTypeSelect({
    this.id,
    this.province,
    this.departamentId,
    this.$all,
  });

  final bool? id;

  final bool? province;

  final bool? departamentId;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'province': province,
        'departament_id': departamentId,
        '_all': $all,
      };
}

class ProvinceGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceGroupByOutputTypeCountArgs({this.select});

  final _i2.ProvinceCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProvinceAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceAvgAggregateOutputTypeSelect({
    this.id,
    this.departamentId,
  });

  final bool? id;

  final bool? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'departament_id': departamentId,
      };
}

class ProvinceGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceGroupByOutputTypeAvgArgs({this.select});

  final _i2.ProvinceAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProvinceSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceSumAggregateOutputTypeSelect({
    this.id,
    this.departamentId,
  });

  final bool? id;

  final bool? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'departament_id': departamentId,
      };
}

class ProvinceGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceGroupByOutputTypeSumArgs({this.select});

  final _i2.ProvinceSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProvinceMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceMinAggregateOutputTypeSelect({
    this.id,
    this.province,
    this.departamentId,
  });

  final bool? id;

  final bool? province;

  final bool? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'province': province,
        'departament_id': departamentId,
      };
}

class ProvinceGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceGroupByOutputTypeMinArgs({this.select});

  final _i2.ProvinceMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProvinceMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceMaxAggregateOutputTypeSelect({
    this.id,
    this.province,
    this.departamentId,
  });

  final bool? id;

  final bool? province;

  final bool? departamentId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'province': province,
        'departament_id': departamentId,
      };
}

class ProvinceGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceGroupByOutputTypeMaxArgs({this.select});

  final _i2.ProvinceMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class ProvinceGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const ProvinceGroupByOutputTypeSelect({
    this.id,
    this.province,
    this.departamentId,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? province;

  final bool? departamentId;

  final _i1.PrismaUnion<bool, _i2.ProvinceGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.ProvinceGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.ProvinceGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.ProvinceGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.ProvinceGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'province': province,
        'departament_id': departamentId,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateProvince {
  const AggregateProvince({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateProvince.fromJson(Map json) => AggregateProvince(
        $count: json['_count'] is Map
            ? _i2.ProvinceCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.ProvinceAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.ProvinceSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.ProvinceMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.ProvinceMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.ProvinceCountAggregateOutputType? $count;

  final _i2.ProvinceAvgAggregateOutputType? $avg;

  final _i2.ProvinceSumAggregateOutputType? $sum;

  final _i2.ProvinceMinAggregateOutputType? $min;

  final _i2.ProvinceMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateProvinceCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProvinceCountArgs({this.select});

  final _i2.ProvinceCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProvinceAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProvinceAvgArgs({this.select});

  final _i2.ProvinceAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProvinceSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProvinceSumArgs({this.select});

  final _i2.ProvinceSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProvinceMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProvinceMinArgs({this.select});

  final _i2.ProvinceMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProvinceMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProvinceMaxArgs({this.select});

  final _i2.ProvinceMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateProvinceSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateProvinceSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateProvinceCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateProvinceAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateProvinceSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateProvinceMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateProvinceMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class DistrictWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.district,
    this.provinceId,
  });

  final _i1
      .PrismaUnion<_i2.DistrictWhereInput, Iterable<_i2.DistrictWhereInput>>?
      AND;

  final Iterable<_i2.DistrictWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.DistrictWhereInput, Iterable<_i2.DistrictWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? district;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'district': district,
        'province_id': provinceId,
      };
}

class DistrictWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.district,
    this.provinceId,
  });

  final int? id;

  final _i1
      .PrismaUnion<_i2.DistrictWhereInput, Iterable<_i2.DistrictWhereInput>>?
      AND;

  final Iterable<_i2.DistrictWhereInput>? OR;

  final _i1
      .PrismaUnion<_i2.DistrictWhereInput, Iterable<_i2.DistrictWhereInput>>?
      NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? district;

  final _i1
      .PrismaUnion<_i2.IntNullableFilter, _i1.PrismaUnion<int, _i1.PrismaNull>>?
      provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'district': district,
        'province_id': provinceId,
      };
}

class DistrictSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictSelect({
    this.id,
    this.district,
    this.provinceId,
  });

  final bool? id;

  final bool? district;

  final bool? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
        'province_id': provinceId,
      };
}

class DistrictOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictOrderByWithRelationInput({
    this.id,
    this.district,
    this.provinceId,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? district;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
        'province_id': provinceId,
      };
}

enum DistrictScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'District'),
  district<String>('district', 'District'),
  provinceId<int>('province_id', 'District');

  const DistrictScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class DistrictCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictCreateInput({
    this.district,
    this.provinceId,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? district;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'district': district,
        'province_id': provinceId,
      };
}

class DistrictUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictUncheckedCreateInput({
    this.id,
    this.district,
    this.provinceId,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? district;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
        'province_id': provinceId,
      };
}

class DistrictCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictCreateManyInput({
    this.id,
    this.district,
    this.provinceId,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? district;

  final _i1.PrismaUnion<int, _i1.PrismaNull>? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
        'province_id': provinceId,
      };
}

class DistrictUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictUpdateInput({
    this.district,
    this.provinceId,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? district;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'district': district,
        'province_id': provinceId,
      };
}

class DistrictUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictUncheckedUpdateInput({
    this.id,
    this.district,
    this.provinceId,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? district;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
        'province_id': provinceId,
      };
}

class DistrictUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictUpdateManyMutationInput({
    this.district,
    this.provinceId,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? district;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'district': district,
        'province_id': provinceId,
      };
}

class DistrictUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictUncheckedUpdateManyInput({
    this.id,
    this.district,
    this.provinceId,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? district;

  final _i1.PrismaUnion<
      int,
      _i1.PrismaUnion<_i2.NullableIntFieldUpdateOperationsInput,
          _i1.PrismaNull>>? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
        'province_id': provinceId,
      };
}

class DistrictCountAggregateOutputType {
  const DistrictCountAggregateOutputType({
    this.id,
    this.district,
    this.provinceId,
    this.$all,
  });

  factory DistrictCountAggregateOutputType.fromJson(Map json) =>
      DistrictCountAggregateOutputType(
        id: json['id'],
        district: json['district'],
        provinceId: json['province_id'],
        $all: json['_all'],
      );

  final int? id;

  final int? district;

  final int? provinceId;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
        'province_id': provinceId,
        '_all': $all,
      };
}

class DistrictAvgAggregateOutputType {
  const DistrictAvgAggregateOutputType({
    this.id,
    this.provinceId,
  });

  factory DistrictAvgAggregateOutputType.fromJson(Map json) =>
      DistrictAvgAggregateOutputType(
        id: json['id'],
        provinceId: json['province_id'],
      );

  final double? id;

  final double? provinceId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'province_id': provinceId,
      };
}

class DistrictSumAggregateOutputType {
  const DistrictSumAggregateOutputType({
    this.id,
    this.provinceId,
  });

  factory DistrictSumAggregateOutputType.fromJson(Map json) =>
      DistrictSumAggregateOutputType(
        id: json['id'],
        provinceId: json['province_id'],
      );

  final int? id;

  final int? provinceId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'province_id': provinceId,
      };
}

class DistrictMinAggregateOutputType {
  const DistrictMinAggregateOutputType({
    this.id,
    this.district,
    this.provinceId,
  });

  factory DistrictMinAggregateOutputType.fromJson(Map json) =>
      DistrictMinAggregateOutputType(
        id: json['id'],
        district: json['district'],
        provinceId: json['province_id'],
      );

  final int? id;

  final String? district;

  final int? provinceId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
        'province_id': provinceId,
      };
}

class DistrictMaxAggregateOutputType {
  const DistrictMaxAggregateOutputType({
    this.id,
    this.district,
    this.provinceId,
  });

  factory DistrictMaxAggregateOutputType.fromJson(Map json) =>
      DistrictMaxAggregateOutputType(
        id: json['id'],
        district: json['district'],
        provinceId: json['province_id'],
      );

  final int? id;

  final String? district;

  final int? provinceId;

  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
        'province_id': provinceId,
      };
}

class DistrictGroupByOutputType {
  const DistrictGroupByOutputType({
    this.id,
    this.district,
    this.provinceId,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory DistrictGroupByOutputType.fromJson(Map json) =>
      DistrictGroupByOutputType(
        id: json['id'],
        district: json['district'],
        provinceId: json['province_id'],
        $count: json['_count'] is Map
            ? _i2.DistrictCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.DistrictAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.DistrictSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.DistrictMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.DistrictMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? district;

  final int? provinceId;

  final _i2.DistrictCountAggregateOutputType? $count;

  final _i2.DistrictAvgAggregateOutputType? $avg;

  final _i2.DistrictSumAggregateOutputType? $sum;

  final _i2.DistrictMinAggregateOutputType? $min;

  final _i2.DistrictMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
        'province_id': provinceId,
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class DistrictCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictCountOrderByAggregateInput({
    this.id,
    this.district,
    this.provinceId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? district;

  final _i2.SortOrder? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
        'province_id': provinceId,
      };
}

class DistrictAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictAvgOrderByAggregateInput({
    this.id,
    this.provinceId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'province_id': provinceId,
      };
}

class DistrictMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictMaxOrderByAggregateInput({
    this.id,
    this.district,
    this.provinceId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? district;

  final _i2.SortOrder? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
        'province_id': provinceId,
      };
}

class DistrictMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictMinOrderByAggregateInput({
    this.id,
    this.district,
    this.provinceId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? district;

  final _i2.SortOrder? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
        'province_id': provinceId,
      };
}

class DistrictSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictSumOrderByAggregateInput({
    this.id,
    this.provinceId,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'province_id': provinceId,
      };
}

class DistrictOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictOrderByWithAggregationInput({
    this.id,
    this.district,
    this.provinceId,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? district;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? provinceId;

  final _i2.DistrictCountOrderByAggregateInput? $count;

  final _i2.DistrictAvgOrderByAggregateInput? $avg;

  final _i2.DistrictMaxOrderByAggregateInput? $max;

  final _i2.DistrictMinOrderByAggregateInput? $min;

  final _i2.DistrictSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
        'province_id': provinceId,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class DistrictScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.district,
    this.provinceId,
  });

  final _i1.PrismaUnion<_i2.DistrictScalarWhereWithAggregatesInput,
      Iterable<_i2.DistrictScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.DistrictScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.DistrictScalarWhereWithAggregatesInput,
      Iterable<_i2.DistrictScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? district;

  final _i1.PrismaUnion<_i2.IntNullableWithAggregatesFilter,
      _i1.PrismaUnion<int, _i1.PrismaNull>>? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'district': district,
        'province_id': provinceId,
      };
}

class DistrictCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictCountAggregateOutputTypeSelect({
    this.id,
    this.district,
    this.provinceId,
    this.$all,
  });

  final bool? id;

  final bool? district;

  final bool? provinceId;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
        'province_id': provinceId,
        '_all': $all,
      };
}

class DistrictGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictGroupByOutputTypeCountArgs({this.select});

  final _i2.DistrictCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DistrictAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictAvgAggregateOutputTypeSelect({
    this.id,
    this.provinceId,
  });

  final bool? id;

  final bool? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'province_id': provinceId,
      };
}

class DistrictGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictGroupByOutputTypeAvgArgs({this.select});

  final _i2.DistrictAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DistrictSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictSumAggregateOutputTypeSelect({
    this.id,
    this.provinceId,
  });

  final bool? id;

  final bool? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'province_id': provinceId,
      };
}

class DistrictGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictGroupByOutputTypeSumArgs({this.select});

  final _i2.DistrictSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DistrictMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictMinAggregateOutputTypeSelect({
    this.id,
    this.district,
    this.provinceId,
  });

  final bool? id;

  final bool? district;

  final bool? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
        'province_id': provinceId,
      };
}

class DistrictGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictGroupByOutputTypeMinArgs({this.select});

  final _i2.DistrictMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DistrictMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictMaxAggregateOutputTypeSelect({
    this.id,
    this.district,
    this.provinceId,
  });

  final bool? id;

  final bool? district;

  final bool? provinceId;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
        'province_id': provinceId,
      };
}

class DistrictGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictGroupByOutputTypeMaxArgs({this.select});

  final _i2.DistrictMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class DistrictGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const DistrictGroupByOutputTypeSelect({
    this.id,
    this.district,
    this.provinceId,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? district;

  final bool? provinceId;

  final _i1.PrismaUnion<bool, _i2.DistrictGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.DistrictGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.DistrictGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.DistrictGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.DistrictGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'district': district,
        'province_id': provinceId,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateDistrict {
  const AggregateDistrict({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateDistrict.fromJson(Map json) => AggregateDistrict(
        $count: json['_count'] is Map
            ? _i2.DistrictCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.DistrictAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.DistrictSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.DistrictMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.DistrictMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.DistrictCountAggregateOutputType? $count;

  final _i2.DistrictAvgAggregateOutputType? $avg;

  final _i2.DistrictSumAggregateOutputType? $sum;

  final _i2.DistrictMinAggregateOutputType? $min;

  final _i2.DistrictMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateDistrictCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDistrictCountArgs({this.select});

  final _i2.DistrictCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDistrictAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDistrictAvgArgs({this.select});

  final _i2.DistrictAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDistrictSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDistrictSumArgs({this.select});

  final _i2.DistrictSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDistrictMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDistrictMinArgs({this.select});

  final _i2.DistrictMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDistrictMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDistrictMaxArgs({this.select});

  final _i2.DistrictMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateDistrictSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateDistrictSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateDistrictCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateDistrictAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateDistrictSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateDistrictMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateDistrictMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class OtpWhereInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.OtpWhereInput, Iterable<_i2.OtpWhereInput>>? AND;

  final Iterable<_i2.OtpWhereInput>? OR;

  final _i1.PrismaUnion<_i2.OtpWhereInput, Iterable<_i2.OtpWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? number;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? code;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? expired;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OtpWhereUniqueInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.OtpWhereInput, Iterable<_i2.OtpWhereInput>>? AND;

  final Iterable<_i2.OtpWhereInput>? OR;

  final _i1.PrismaUnion<_i2.OtpWhereInput, Iterable<_i2.OtpWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? number;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? code;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? expired;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OtpSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpSelect({
    this.id,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? number;

  final bool? code;

  final bool? expired;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OtpOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpOrderByWithRelationInput({
    this.id,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? number;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? code;

  final _i2.SortOrder? expired;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

enum OtpScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'Otp'),
  number<String>('number', 'Otp'),
  code<String>('code', 'Otp'),
  expired<DateTime>('expired', 'Otp'),
  createdAt<DateTime>('created_at', 'Otp'),
  updatedAt<DateTime>('updated_at', 'Otp');

  const OtpScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class OtpCreateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpCreateInput({
    this.number,
    this.code,
    required this.expired,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? number;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? code;

  final DateTime expired;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OtpUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpUncheckedCreateInput({
    this.id,
    this.number,
    this.code,
    required this.expired,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? number;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? code;

  final DateTime expired;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OtpCreateManyInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpCreateManyInput({
    this.id,
    this.number,
    this.code,
    required this.expired,
    this.createdAt,
    this.updatedAt,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? number;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? code;

  final DateTime expired;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OtpUpdateInput implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpUpdateInput({
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? number;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? code;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      expired;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OtpUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpUncheckedUpdateInput({
    this.id,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? number;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? code;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      expired;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OtpUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpUpdateManyMutationInput({
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? number;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? code;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      expired;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OtpUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpUncheckedUpdateManyInput({
    this.id,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? number;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? code;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      expired;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      createdAt;

  final _i1.PrismaUnion<DateTime, _i2.DateTimeFieldUpdateOperationsInput>?
      updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OtpCountAggregateOutputType {
  const OtpCountAggregateOutputType({
    this.id,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  factory OtpCountAggregateOutputType.fromJson(Map json) =>
      OtpCountAggregateOutputType(
        id: json['id'],
        number: json['number'],
        code: json['code'],
        expired: json['expired'],
        createdAt: json['created_at'],
        updatedAt: json['updated_at'],
        $all: json['_all'],
      );

  final int? id;

  final int? number;

  final int? code;

  final int? expired;

  final int? createdAt;

  final int? updatedAt;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class OtpAvgAggregateOutputType {
  const OtpAvgAggregateOutputType({this.id});

  factory OtpAvgAggregateOutputType.fromJson(Map json) =>
      OtpAvgAggregateOutputType(id: json['id']);

  final double? id;

  Map<String, dynamic> toJson() => {'id': id};
}

class OtpSumAggregateOutputType {
  const OtpSumAggregateOutputType({this.id});

  factory OtpSumAggregateOutputType.fromJson(Map json) =>
      OtpSumAggregateOutputType(id: json['id']);

  final int? id;

  Map<String, dynamic> toJson() => {'id': id};
}

class OtpMinAggregateOutputType {
  const OtpMinAggregateOutputType({
    this.id,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
  });

  factory OtpMinAggregateOutputType.fromJson(Map json) =>
      OtpMinAggregateOutputType(
        id: json['id'],
        number: json['number'],
        code: json['code'],
        expired: switch (json['expired']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['expired']
        },
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final String? number;

  final String? code;

  final DateTime? expired;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'number': number,
        'code': code,
        'expired': expired?.toIso8601String(),
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class OtpMaxAggregateOutputType {
  const OtpMaxAggregateOutputType({
    this.id,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
  });

  factory OtpMaxAggregateOutputType.fromJson(Map json) =>
      OtpMaxAggregateOutputType(
        id: json['id'],
        number: json['number'],
        code: json['code'],
        expired: switch (json['expired']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['expired']
        },
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
      );

  final int? id;

  final String? number;

  final String? code;

  final DateTime? expired;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  Map<String, dynamic> toJson() => {
        'id': id,
        'number': number,
        'code': code,
        'expired': expired?.toIso8601String(),
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
      };
}

class OtpGroupByOutputType {
  const OtpGroupByOutputType({
    this.id,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory OtpGroupByOutputType.fromJson(Map json) => OtpGroupByOutputType(
        id: json['id'],
        number: json['number'],
        code: json['code'],
        expired: switch (json['expired']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['expired']
        },
        createdAt: switch (json['created_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['created_at']
        },
        updatedAt: switch (json['updated_at']) {
          DateTime value => value,
          String value => DateTime.parse(value),
          _ => json['updated_at']
        },
        $count: json['_count'] is Map
            ? _i2.OtpCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.OtpAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.OtpSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.OtpMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.OtpMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? number;

  final String? code;

  final DateTime? expired;

  final DateTime? createdAt;

  final DateTime? updatedAt;

  final _i2.OtpCountAggregateOutputType? $count;

  final _i2.OtpAvgAggregateOutputType? $avg;

  final _i2.OtpSumAggregateOutputType? $sum;

  final _i2.OtpMinAggregateOutputType? $min;

  final _i2.OtpMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'number': number,
        'code': code,
        'expired': expired?.toIso8601String(),
        'created_at': createdAt?.toIso8601String(),
        'updated_at': updatedAt?.toIso8601String(),
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class OtpCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpCountOrderByAggregateInput({
    this.id,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? number;

  final _i2.SortOrder? code;

  final _i2.SortOrder? expired;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OtpAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpAvgOrderByAggregateInput({this.id});

  final _i2.SortOrder? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class OtpMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpMaxOrderByAggregateInput({
    this.id,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? number;

  final _i2.SortOrder? code;

  final _i2.SortOrder? expired;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OtpMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpMinOrderByAggregateInput({
    this.id,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? number;

  final _i2.SortOrder? code;

  final _i2.SortOrder? expired;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OtpSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpSumOrderByAggregateInput({this.id});

  final _i2.SortOrder? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class OtpOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpOrderByWithAggregationInput({
    this.id,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? number;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? code;

  final _i2.SortOrder? expired;

  final _i2.SortOrder? createdAt;

  final _i2.SortOrder? updatedAt;

  final _i2.OtpCountOrderByAggregateInput? $count;

  final _i2.OtpAvgOrderByAggregateInput? $avg;

  final _i2.OtpMaxOrderByAggregateInput? $max;

  final _i2.OtpMinOrderByAggregateInput? $min;

  final _i2.OtpSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class OtpScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
  });

  final _i1.PrismaUnion<_i2.OtpScalarWhereWithAggregatesInput,
      Iterable<_i2.OtpScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.OtpScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.OtpScalarWhereWithAggregatesInput,
      Iterable<_i2.OtpScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? number;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? code;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? expired;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? createdAt;

  final _i1.PrismaUnion<_i2.DateTimeWithAggregatesFilter, DateTime>? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OtpCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpCountAggregateOutputTypeSelect({
    this.id,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
    this.$all,
  });

  final bool? id;

  final bool? number;

  final bool? code;

  final bool? expired;

  final bool? createdAt;

  final bool? updatedAt;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_all': $all,
      };
}

class OtpGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpGroupByOutputTypeCountArgs({this.select});

  final _i2.OtpCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OtpAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpAvgAggregateOutputTypeSelect({this.id});

  final bool? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class OtpGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpGroupByOutputTypeAvgArgs({this.select});

  final _i2.OtpAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OtpSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpSumAggregateOutputTypeSelect({this.id});

  final bool? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class OtpGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpGroupByOutputTypeSumArgs({this.select});

  final _i2.OtpSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OtpMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpMinAggregateOutputTypeSelect({
    this.id,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? number;

  final bool? code;

  final bool? expired;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OtpGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpGroupByOutputTypeMinArgs({this.select});

  final _i2.OtpMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OtpMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpMaxAggregateOutputTypeSelect({
    this.id,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
  });

  final bool? id;

  final bool? number;

  final bool? code;

  final bool? expired;

  final bool? createdAt;

  final bool? updatedAt;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
      };
}

class OtpGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpGroupByOutputTypeMaxArgs({this.select});

  final _i2.OtpMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class OtpGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const OtpGroupByOutputTypeSelect({
    this.id,
    this.number,
    this.code,
    this.expired,
    this.createdAt,
    this.updatedAt,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? number;

  final bool? code;

  final bool? expired;

  final bool? createdAt;

  final bool? updatedAt;

  final _i1.PrismaUnion<bool, _i2.OtpGroupByOutputTypeCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.OtpGroupByOutputTypeAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.OtpGroupByOutputTypeSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.OtpGroupByOutputTypeMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.OtpGroupByOutputTypeMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'number': number,
        'code': code,
        'expired': expired,
        'created_at': createdAt,
        'updated_at': updatedAt,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateOtp {
  const AggregateOtp({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateOtp.fromJson(Map json) => AggregateOtp(
        $count: json['_count'] is Map
            ? _i2.OtpCountAggregateOutputType.fromJson(json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.OtpAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.OtpSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.OtpMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.OtpMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.OtpCountAggregateOutputType? $count;

  final _i2.OtpAvgAggregateOutputType? $avg;

  final _i2.OtpSumAggregateOutputType? $sum;

  final _i2.OtpMinAggregateOutputType? $min;

  final _i2.OtpMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateOtpCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOtpCountArgs({this.select});

  final _i2.OtpCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOtpAvgArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOtpAvgArgs({this.select});

  final _i2.OtpAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOtpSumArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOtpSumArgs({this.select});

  final _i2.OtpSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOtpMinArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOtpMinArgs({this.select});

  final _i2.OtpMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOtpMaxArgs implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOtpMaxArgs({this.select});

  final _i2.OtpMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateOtpSelect implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateOtpSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateOtpCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateOtpAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateOtpSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateOtpMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateOtpMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class BussinessSettingWhereInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingWhereInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  final _i1.PrismaUnion<_i2.BussinessSettingWhereInput,
      Iterable<_i2.BussinessSettingWhereInput>>? AND;

  final Iterable<_i2.BussinessSettingWhereInput>? OR;

  final _i1.PrismaUnion<_i2.BussinessSettingWhereInput,
      Iterable<_i2.BussinessSettingWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? sendEmail;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? sendEmailPassword;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? awsS3;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? s3SecretKey;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? bucketS3;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? twilioId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? twilioKey;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? twilioPhone;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

class BussinessSettingWhereUniqueInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingWhereUniqueInput({
    this.id,
    this.AND,
    this.OR,
    this.NOT,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  final int? id;

  final _i1.PrismaUnion<_i2.BussinessSettingWhereInput,
      Iterable<_i2.BussinessSettingWhereInput>>? AND;

  final Iterable<_i2.BussinessSettingWhereInput>? OR;

  final _i1.PrismaUnion<_i2.BussinessSettingWhereInput,
      Iterable<_i2.BussinessSettingWhereInput>>? NOT;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? sendEmail;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? sendEmailPassword;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? awsS3;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? s3SecretKey;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? bucketS3;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? twilioId;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? twilioKey;

  final _i1.PrismaUnion<_i2.StringNullableFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? twilioPhone;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

class BussinessSettingSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingSelect({
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  final bool? id;

  final bool? name;

  final bool? sendEmail;

  final bool? sendEmailPassword;

  final bool? awsS3;

  final bool? s3SecretKey;

  final bool? bucketS3;

  final bool? twilioId;

  final bool? twilioKey;

  final bool? twilioPhone;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

class BussinessSettingOrderByWithRelationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingOrderByWithRelationInput({
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? sendEmail;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? sendEmailPassword;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? awsS3;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? s3SecretKey;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? bucketS3;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? twilioId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? twilioKey;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? twilioPhone;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

enum BussinessSettingScalar<T> implements _i1.PrismaEnum, _i1.Reference<T> {
  id<int>('id', 'BussinessSetting'),
  name$<String>('name', 'BussinessSetting'),
  sendEmail<String>('send_email', 'BussinessSetting'),
  sendEmailPassword<String>('send_email_password', 'BussinessSetting'),
  awsS3<String>('aws_s3', 'BussinessSetting'),
  s3SecretKey<String>('s3_secret_key', 'BussinessSetting'),
  bucketS3<String>('bucket_s3', 'BussinessSetting'),
  twilioId<String>('twilio_id', 'BussinessSetting'),
  twilioKey<String>('twilio_key', 'BussinessSetting'),
  twilioPhone<String>('twilio_phone', 'BussinessSetting');

  const BussinessSettingScalar(
    this.name,
    this.model,
  );

  @override
  final String name;

  @override
  final String model;
}

class BussinessSettingCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingCreateInput({
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sendEmail;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sendEmailPassword;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? awsS3;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? s3SecretKey;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? bucketS3;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? twilioId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? twilioKey;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? twilioPhone;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

class BussinessSettingUncheckedCreateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingUncheckedCreateInput({
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sendEmail;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sendEmailPassword;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? awsS3;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? s3SecretKey;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? bucketS3;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? twilioId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? twilioKey;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? twilioPhone;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

class BussinessSettingCreateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingCreateManyInput({
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  final int? id;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? name;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sendEmail;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? sendEmailPassword;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? awsS3;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? s3SecretKey;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? bucketS3;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? twilioId;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? twilioKey;

  final _i1.PrismaUnion<String, _i1.PrismaNull>? twilioPhone;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

class BussinessSettingUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingUpdateInput({
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sendEmail;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sendEmailPassword;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? awsS3;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? s3SecretKey;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? bucketS3;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? twilioId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? twilioKey;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? twilioPhone;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

class BussinessSettingUncheckedUpdateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingUncheckedUpdateInput({
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sendEmail;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sendEmailPassword;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? awsS3;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? s3SecretKey;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? bucketS3;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? twilioId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? twilioKey;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? twilioPhone;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

class BussinessSettingUpdateManyMutationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingUpdateManyMutationInput({
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sendEmail;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sendEmailPassword;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? awsS3;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? s3SecretKey;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? bucketS3;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? twilioId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? twilioKey;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? twilioPhone;

  @override
  Map<String, dynamic> toJson() => {
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

class BussinessSettingUncheckedUpdateManyInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingUncheckedUpdateManyInput({
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  final _i1.PrismaUnion<int, _i2.IntFieldUpdateOperationsInput>? id;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sendEmail;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? sendEmailPassword;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? awsS3;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? s3SecretKey;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? bucketS3;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? twilioId;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? twilioKey;

  final _i1.PrismaUnion<
      String,
      _i1.PrismaUnion<_i2.NullableStringFieldUpdateOperationsInput,
          _i1.PrismaNull>>? twilioPhone;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

class BussinessSettingCountAggregateOutputType {
  const BussinessSettingCountAggregateOutputType({
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
    this.$all,
  });

  factory BussinessSettingCountAggregateOutputType.fromJson(Map json) =>
      BussinessSettingCountAggregateOutputType(
        id: json['id'],
        name: json['name'],
        sendEmail: json['send_email'],
        sendEmailPassword: json['send_email_password'],
        awsS3: json['aws_s3'],
        s3SecretKey: json['s3_secret_key'],
        bucketS3: json['bucket_s3'],
        twilioId: json['twilio_id'],
        twilioKey: json['twilio_key'],
        twilioPhone: json['twilio_phone'],
        $all: json['_all'],
      );

  final int? id;

  final int? name;

  final int? sendEmail;

  final int? sendEmailPassword;

  final int? awsS3;

  final int? s3SecretKey;

  final int? bucketS3;

  final int? twilioId;

  final int? twilioKey;

  final int? twilioPhone;

  final int? $all;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
        '_all': $all,
      };
}

class BussinessSettingAvgAggregateOutputType {
  const BussinessSettingAvgAggregateOutputType({this.id});

  factory BussinessSettingAvgAggregateOutputType.fromJson(Map json) =>
      BussinessSettingAvgAggregateOutputType(id: json['id']);

  final double? id;

  Map<String, dynamic> toJson() => {'id': id};
}

class BussinessSettingSumAggregateOutputType {
  const BussinessSettingSumAggregateOutputType({this.id});

  factory BussinessSettingSumAggregateOutputType.fromJson(Map json) =>
      BussinessSettingSumAggregateOutputType(id: json['id']);

  final int? id;

  Map<String, dynamic> toJson() => {'id': id};
}

class BussinessSettingMinAggregateOutputType {
  const BussinessSettingMinAggregateOutputType({
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  factory BussinessSettingMinAggregateOutputType.fromJson(Map json) =>
      BussinessSettingMinAggregateOutputType(
        id: json['id'],
        name: json['name'],
        sendEmail: json['send_email'],
        sendEmailPassword: json['send_email_password'],
        awsS3: json['aws_s3'],
        s3SecretKey: json['s3_secret_key'],
        bucketS3: json['bucket_s3'],
        twilioId: json['twilio_id'],
        twilioKey: json['twilio_key'],
        twilioPhone: json['twilio_phone'],
      );

  final int? id;

  final String? name;

  final String? sendEmail;

  final String? sendEmailPassword;

  final String? awsS3;

  final String? s3SecretKey;

  final String? bucketS3;

  final String? twilioId;

  final String? twilioKey;

  final String? twilioPhone;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

class BussinessSettingMaxAggregateOutputType {
  const BussinessSettingMaxAggregateOutputType({
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  factory BussinessSettingMaxAggregateOutputType.fromJson(Map json) =>
      BussinessSettingMaxAggregateOutputType(
        id: json['id'],
        name: json['name'],
        sendEmail: json['send_email'],
        sendEmailPassword: json['send_email_password'],
        awsS3: json['aws_s3'],
        s3SecretKey: json['s3_secret_key'],
        bucketS3: json['bucket_s3'],
        twilioId: json['twilio_id'],
        twilioKey: json['twilio_key'],
        twilioPhone: json['twilio_phone'],
      );

  final int? id;

  final String? name;

  final String? sendEmail;

  final String? sendEmailPassword;

  final String? awsS3;

  final String? s3SecretKey;

  final String? bucketS3;

  final String? twilioId;

  final String? twilioKey;

  final String? twilioPhone;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

class BussinessSettingGroupByOutputType {
  const BussinessSettingGroupByOutputType({
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory BussinessSettingGroupByOutputType.fromJson(Map json) =>
      BussinessSettingGroupByOutputType(
        id: json['id'],
        name: json['name'],
        sendEmail: json['send_email'],
        sendEmailPassword: json['send_email_password'],
        awsS3: json['aws_s3'],
        s3SecretKey: json['s3_secret_key'],
        bucketS3: json['bucket_s3'],
        twilioId: json['twilio_id'],
        twilioKey: json['twilio_key'],
        twilioPhone: json['twilio_phone'],
        $count: json['_count'] is Map
            ? _i2.BussinessSettingCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.BussinessSettingAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.BussinessSettingSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.BussinessSettingMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.BussinessSettingMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final int? id;

  final String? name;

  final String? sendEmail;

  final String? sendEmailPassword;

  final String? awsS3;

  final String? s3SecretKey;

  final String? bucketS3;

  final String? twilioId;

  final String? twilioKey;

  final String? twilioPhone;

  final _i2.BussinessSettingCountAggregateOutputType? $count;

  final _i2.BussinessSettingAvgAggregateOutputType? $avg;

  final _i2.BussinessSettingSumAggregateOutputType? $sum;

  final _i2.BussinessSettingMinAggregateOutputType? $min;

  final _i2.BussinessSettingMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class BussinessSettingCountOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingCountOrderByAggregateInput({
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? sendEmail;

  final _i2.SortOrder? sendEmailPassword;

  final _i2.SortOrder? awsS3;

  final _i2.SortOrder? s3SecretKey;

  final _i2.SortOrder? bucketS3;

  final _i2.SortOrder? twilioId;

  final _i2.SortOrder? twilioKey;

  final _i2.SortOrder? twilioPhone;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

class BussinessSettingAvgOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingAvgOrderByAggregateInput({this.id});

  final _i2.SortOrder? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class BussinessSettingMaxOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingMaxOrderByAggregateInput({
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? sendEmail;

  final _i2.SortOrder? sendEmailPassword;

  final _i2.SortOrder? awsS3;

  final _i2.SortOrder? s3SecretKey;

  final _i2.SortOrder? bucketS3;

  final _i2.SortOrder? twilioId;

  final _i2.SortOrder? twilioKey;

  final _i2.SortOrder? twilioPhone;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

class BussinessSettingMinOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingMinOrderByAggregateInput({
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  final _i2.SortOrder? id;

  final _i2.SortOrder? name;

  final _i2.SortOrder? sendEmail;

  final _i2.SortOrder? sendEmailPassword;

  final _i2.SortOrder? awsS3;

  final _i2.SortOrder? s3SecretKey;

  final _i2.SortOrder? bucketS3;

  final _i2.SortOrder? twilioId;

  final _i2.SortOrder? twilioKey;

  final _i2.SortOrder? twilioPhone;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

class BussinessSettingSumOrderByAggregateInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingSumOrderByAggregateInput({this.id});

  final _i2.SortOrder? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class BussinessSettingOrderByWithAggregationInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingOrderByWithAggregationInput({
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
    this.$count,
    this.$avg,
    this.$max,
    this.$min,
    this.$sum,
  });

  final _i2.SortOrder? id;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? name;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? sendEmail;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? sendEmailPassword;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? awsS3;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? s3SecretKey;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? bucketS3;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? twilioId;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? twilioKey;

  final _i1.PrismaUnion<_i2.SortOrder, _i2.SortOrderInput>? twilioPhone;

  final _i2.BussinessSettingCountOrderByAggregateInput? $count;

  final _i2.BussinessSettingAvgOrderByAggregateInput? $avg;

  final _i2.BussinessSettingMaxOrderByAggregateInput? $max;

  final _i2.BussinessSettingMinOrderByAggregateInput? $min;

  final _i2.BussinessSettingSumOrderByAggregateInput? $sum;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
        '_count': $count,
        '_avg': $avg,
        '_max': $max,
        '_min': $min,
        '_sum': $sum,
      };
}

class BussinessSettingScalarWhereWithAggregatesInput
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingScalarWhereWithAggregatesInput({
    this.AND,
    this.OR,
    this.NOT,
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  final _i1.PrismaUnion<_i2.BussinessSettingScalarWhereWithAggregatesInput,
      Iterable<_i2.BussinessSettingScalarWhereWithAggregatesInput>>? AND;

  final Iterable<_i2.BussinessSettingScalarWhereWithAggregatesInput>? OR;

  final _i1.PrismaUnion<_i2.BussinessSettingScalarWhereWithAggregatesInput,
      Iterable<_i2.BussinessSettingScalarWhereWithAggregatesInput>>? NOT;

  final _i1.PrismaUnion<_i2.IntWithAggregatesFilter, int>? id;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? name;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? sendEmail;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? sendEmailPassword;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? awsS3;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? s3SecretKey;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? bucketS3;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? twilioId;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? twilioKey;

  final _i1.PrismaUnion<_i2.StringNullableWithAggregatesFilter,
      _i1.PrismaUnion<String, _i1.PrismaNull>>? twilioPhone;

  @override
  Map<String, dynamic> toJson() => {
        'AND': AND,
        'OR': OR,
        'NOT': NOT,
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

class BussinessSettingCountAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingCountAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
    this.$all,
  });

  final bool? id;

  final bool? name;

  final bool? sendEmail;

  final bool? sendEmailPassword;

  final bool? awsS3;

  final bool? s3SecretKey;

  final bool? bucketS3;

  final bool? twilioId;

  final bool? twilioKey;

  final bool? twilioPhone;

  final bool? $all;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
        '_all': $all,
      };
}

class BussinessSettingGroupByOutputTypeCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingGroupByOutputTypeCountArgs({this.select});

  final _i2.BussinessSettingCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class BussinessSettingAvgAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingAvgAggregateOutputTypeSelect({this.id});

  final bool? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class BussinessSettingGroupByOutputTypeAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingGroupByOutputTypeAvgArgs({this.select});

  final _i2.BussinessSettingAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class BussinessSettingSumAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingSumAggregateOutputTypeSelect({this.id});

  final bool? id;

  @override
  Map<String, dynamic> toJson() => {'id': id};
}

class BussinessSettingGroupByOutputTypeSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingGroupByOutputTypeSumArgs({this.select});

  final _i2.BussinessSettingSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class BussinessSettingMinAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingMinAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  final bool? id;

  final bool? name;

  final bool? sendEmail;

  final bool? sendEmailPassword;

  final bool? awsS3;

  final bool? s3SecretKey;

  final bool? bucketS3;

  final bool? twilioId;

  final bool? twilioKey;

  final bool? twilioPhone;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

class BussinessSettingGroupByOutputTypeMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingGroupByOutputTypeMinArgs({this.select});

  final _i2.BussinessSettingMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class BussinessSettingMaxAggregateOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingMaxAggregateOutputTypeSelect({
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
  });

  final bool? id;

  final bool? name;

  final bool? sendEmail;

  final bool? sendEmailPassword;

  final bool? awsS3;

  final bool? s3SecretKey;

  final bool? bucketS3;

  final bool? twilioId;

  final bool? twilioKey;

  final bool? twilioPhone;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
      };
}

class BussinessSettingGroupByOutputTypeMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingGroupByOutputTypeMaxArgs({this.select});

  final _i2.BussinessSettingMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class BussinessSettingGroupByOutputTypeSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const BussinessSettingGroupByOutputTypeSelect({
    this.id,
    this.name,
    this.sendEmail,
    this.sendEmailPassword,
    this.awsS3,
    this.s3SecretKey,
    this.bucketS3,
    this.twilioId,
    this.twilioKey,
    this.twilioPhone,
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final bool? id;

  final bool? name;

  final bool? sendEmail;

  final bool? sendEmailPassword;

  final bool? awsS3;

  final bool? s3SecretKey;

  final bool? bucketS3;

  final bool? twilioId;

  final bool? twilioKey;

  final bool? twilioPhone;

  final _i1.PrismaUnion<bool, _i2.BussinessSettingGroupByOutputTypeCountArgs>?
      $count;

  final _i1.PrismaUnion<bool, _i2.BussinessSettingGroupByOutputTypeAvgArgs>?
      $avg;

  final _i1.PrismaUnion<bool, _i2.BussinessSettingGroupByOutputTypeSumArgs>?
      $sum;

  final _i1.PrismaUnion<bool, _i2.BussinessSettingGroupByOutputTypeMinArgs>?
      $min;

  final _i1.PrismaUnion<bool, _i2.BussinessSettingGroupByOutputTypeMaxArgs>?
      $max;

  @override
  Map<String, dynamic> toJson() => {
        'id': id,
        'name': name,
        'send_email': sendEmail,
        'send_email_password': sendEmailPassword,
        'aws_s3': awsS3,
        's3_secret_key': s3SecretKey,
        'bucket_s3': bucketS3,
        'twilio_id': twilioId,
        'twilio_key': twilioKey,
        'twilio_phone': twilioPhone,
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}

class AggregateBussinessSetting {
  const AggregateBussinessSetting({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  factory AggregateBussinessSetting.fromJson(Map json) =>
      AggregateBussinessSetting(
        $count: json['_count'] is Map
            ? _i2.BussinessSettingCountAggregateOutputType.fromJson(
                json['_count'])
            : null,
        $avg: json['_avg'] is Map
            ? _i2.BussinessSettingAvgAggregateOutputType.fromJson(json['_avg'])
            : null,
        $sum: json['_sum'] is Map
            ? _i2.BussinessSettingSumAggregateOutputType.fromJson(json['_sum'])
            : null,
        $min: json['_min'] is Map
            ? _i2.BussinessSettingMinAggregateOutputType.fromJson(json['_min'])
            : null,
        $max: json['_max'] is Map
            ? _i2.BussinessSettingMaxAggregateOutputType.fromJson(json['_max'])
            : null,
      );

  final _i2.BussinessSettingCountAggregateOutputType? $count;

  final _i2.BussinessSettingAvgAggregateOutputType? $avg;

  final _i2.BussinessSettingSumAggregateOutputType? $sum;

  final _i2.BussinessSettingMinAggregateOutputType? $min;

  final _i2.BussinessSettingMaxAggregateOutputType? $max;

  Map<String, dynamic> toJson() => {
        '_count': $count?.toJson(),
        '_avg': $avg?.toJson(),
        '_sum': $sum?.toJson(),
        '_min': $min?.toJson(),
        '_max': $max?.toJson(),
      };
}

class AggregateBussinessSettingCountArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateBussinessSettingCountArgs({this.select});

  final _i2.BussinessSettingCountAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateBussinessSettingAvgArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateBussinessSettingAvgArgs({this.select});

  final _i2.BussinessSettingAvgAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateBussinessSettingSumArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateBussinessSettingSumArgs({this.select});

  final _i2.BussinessSettingSumAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateBussinessSettingMinArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateBussinessSettingMinArgs({this.select});

  final _i2.BussinessSettingMinAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateBussinessSettingMaxArgs
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateBussinessSettingMaxArgs({this.select});

  final _i2.BussinessSettingMaxAggregateOutputTypeSelect? select;

  @override
  Map<String, dynamic> toJson() => {'select': select};
}

class AggregateBussinessSettingSelect
    implements _i1.JsonConvertible<Map<String, dynamic>> {
  const AggregateBussinessSettingSelect({
    this.$count,
    this.$avg,
    this.$sum,
    this.$min,
    this.$max,
  });

  final _i1.PrismaUnion<bool, _i2.AggregateBussinessSettingCountArgs>? $count;

  final _i1.PrismaUnion<bool, _i2.AggregateBussinessSettingAvgArgs>? $avg;

  final _i1.PrismaUnion<bool, _i2.AggregateBussinessSettingSumArgs>? $sum;

  final _i1.PrismaUnion<bool, _i2.AggregateBussinessSettingMinArgs>? $min;

  final _i1.PrismaUnion<bool, _i2.AggregateBussinessSettingMaxArgs>? $max;

  @override
  Map<String, dynamic> toJson() => {
        '_count': $count,
        '_avg': $avg,
        '_sum': $sum,
        '_min': $min,
        '_max': $max,
      };
}
